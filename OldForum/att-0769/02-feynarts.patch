diff --git FeynArts-3.7/FeynArts.m FeynArts-3.7/FeynArts.m
index da7c06f..1c31f8b 100644
--- FeynArts-3.7/FeynArts.m
+++ FeynArts-3.7/FeynArts.m
@@ -1,32 +1,23 @@
 (*
-
 This is FeynArts, Version 3.7
 Copyright by Sepp Kueblbeck, Hagen Eck, and Thomas Hahn 1991-2012
 last modified 2 Jun 12 by Thomas Hahn
-
 Release notes:
-
 FeynArts is free software, but is not in the public domain.
 Instead it is covered by the GNU Lesser General Public License.
 In plain English this means:
-
 1. We don't promise that this software works.
    (But if you find any bugs, please let us know!)
-
 2. You can use this software for whatever you want.
    You don't have to pay us.
-
 3. You may not pretend that you wrote this software.
    If you use it in a program, you must acknowledge
    somewhere in your publication that you've used
    our code.
-
 If you're a lawyer, you can find the legal stuff at
 http://www.fsf.org/copyleft/lgpl.html.
-
 The user guide for this program can be found at
 http://www.feynarts.de.
-
 If you find any bugs, or want to make suggestions, or
 just write fan mail, address it to:
 	Thomas Hahn
@@ -34,322 +25,251 @@ just write fan mail, address it to:
 	Foehringer Ring 6
 	D-80805 Munich, Germany
 	e-mail: hahn@feynarts.de
-
 There exists a low-traffic mailing list where updates will be
 announced.  Contact hahn@feynarts.de to be added to this list. 
-
 Have fun!
-
 *)
-
-
 Print[""];
 Print["FeynArts 3.7"];
 Print["by Hagen Eck, Sepp Kueblbeck, and Thomas Hahn"];
-Print["last revised 2 Jun 12"]
-
-
-BeginPackage["FeynArts`"]
-
+Print["last revised 2 Jun 12"];
+Print["patched for use with FeynCalc by Frederik Orellana and Rolf Mertig"];
+(*To avoid error messages on reload*)
+If[NumberQ[HighEnergyPhysics`FeynArts`$FeynArts],
+ClearAll[HighEnergyPhysics`FeynArts`Greek,HighEnergyPhysics`FeynArts`UCGreek],
+Remove[HighEnergyPhysics`FeynArts`$FeynArts]];
+BeginPackage["HighEnergyPhysics`FeynArts`"];
+SetAttributes[SetForm, HoldAll];
+SetForm[Global`a_, Global`b_, Global`c_:TraditionalForm] := (Format[Global`a, Global`c] := Global`b;);
+format1 /: SetDelayed[format1[Global`a_], Global`b_] := SetForm[Global`a, Global`b];
+format1 /: Set[format1[Global`a_], Global`b_] := SetForm[Global`a, Global`b];
 (* definitions for Utilities.m *)
-
 FAPrint::usage =
 "FAPrint[l, s] prints s if l <= $Verbose."
-
 ActualOptions::usage =
 "ActualOptions[sym, options] returns a list of options of sym with the
 valid options of sym replaced by their actual values."
-
 ResolveLevel::usage =
 "ResolveLevel[lev] returns a full set of levels selected by lev.  For
 example, ResolveLevel[Particles] gives {Generic, Classes, Particles}."
-
 ResolveType::usage =
 "ResolveType[t] returns an abridged class of propagator with values
-External, Internal, or Loop."
-
+External, Internal, or HighEnergyPhysics`FeynCalc`Loop`Loop."
 ContainsQ::usage =
 "ContainsQ[expr, items] gives True if expr contains every element in
 items."
-
 ToGeneric::usage =
 "ToGeneric[expr] returns expr with all classes and particle fields
 replaced by their generic fields.  Mind that this procedure removes the
 signs of the fields."
-
 ToClasses::usage =
 "ToClasses[expr] returns expr with all particle fields replaced by their
 classes fields."
-
 Seq::usage =
 "Seq is almost identical to Sequence except that it is not expanded
 automatically."
-
 TakeGraph::usage =
 "TakeGraph[ins -> graph] returns graph."
-
 TakeIns::usage =
 "TakeIns[ins -> graph] returns ins."
-
 Subst::usage =
 "Subst[expr, i, j] substitutes the elements of i by the corresponding
 elements of j, where j may be shorter than i."
-
 PSort::usage =
 "PSort[p] sorts the first two elements of a propagator p."
-
 VSort::usage =
 "VSort[v] sorts vertex v into canonical order."
-
 Vertices::usage =
 "Vertices[top] returns a list of all vertices of topology top."
-
 AddFieldNo::usage =
 "AddFieldNo[top] adds numbers of the form Field[n] to the propagators in
 topology top."
-
 Compare::usage =
 "Compare[t] is the `pure' compare function to eliminate equivalent
 topologies of a TopologyList t."
-
 ProcessName::usage =
 "ProcessName[amp] constructs a string suitable as filename for the
 inserted topology or amplitude list amp which is unique to the model
 and particle selection."
-
 Pluralize::usage =
 "Pluralize is an internal function."
-
 Statistics::usage =
 "Statistics is an internal function."
-
 Alph::usage =
 "Alph[n] gives the nth lowercase letter."
-
 UCAlph::usage =
 "UCAlph[n] gives the nth uppercase letter."
-
 Greek::usage =
 "Greek[n] gives the nth lowercase greek letter."
-
 UCGreek::usage =
 "UCGreek[n] gives the nth uppercase greek letter."
-
-
 (* definitions for Topology.m *)
-
 Topology::usage =
 "Topology is the head of a topology data structure.  Topology[s] is
 the head of a topology with combinatorial factor 1/s."
-
 TopologyList::usage =
 "TopologyList is the head of a list of topologies."
-
 Propagator::usage =
 "Propagator[v1, v2] is an (undirected) propagator joining the two 
 vertices v1 and v2.\n
 Propagator[v1, v2, f] is a (directed) propagator transporting field f
 from vertex v1 to v2.\n
 Propagator[t][...] is the representation of a propagator of type t.
-Possible types are: Incoming, Outgoing, External, Internal and Loop[n]."
-
+Possible types are: Incoming, Outgoing, External, Internal and HighEnergyPhysics`FeynCalc`Loop`Loop[n]."
 Incoming::usage =
 "Propagator[Incoming][...] denotes an incoming propagator."
-
 Outgoing::usage =
 "Propagator[Outgoing][...] denotes an outgoing propagator."
-
 External::usage =
 "Propagator[External][...] denotes an external propagator.\n
 External is also used in SumOver[index, range, External] to indicate
 that the index to be summed belongs to an external particle."
-
 Internal::usage =
 "Propagator[Internal][...] denotes an internal propagator.\n
 ExcludeTopologies -> Internal excludes topologies that contain
 Propagator[Internal], i.e. the one-particle reducible ones."
-
-Loop::usage =
-"Propagator[Loop[n]][...] denotes a propagator on loop n."
-
+HighEnergyPhysics`FeynCalc`Loop`Loop::usage =
+"Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[n]][...] denotes a propagator on loop n."
 Vertex::usage =
 "Vertex[e][n] is the representation of a vertex with e propagators in
 a topology.  Vertex[e, cto][n] is the representation of a vertex of
 counter-term order cto in a topology."
-
 CreateTopologies::usage =
 "CreateTopologies[l, i -> o] returns a TopologyList of topologies with
 i incoming and o outgoing legs and l loops (at the moment l = 0...3)."
-
 ExcludeTopologies::usage =
 "ExcludeTopologies is an option of CreateTopologies which specifies
 filters for excluding topologies.  You may use the built-in filters:
 Tadpoles, TadpoleCTs, SelfEnergies, SelfEnergyCTs, WFCorrections,
 WFCorrectionCTs, Triangles, TriangleCTs, Boxes[n], BoxCTs[n], AllBoxes,
 AllBoxCTs, or define new ones using $ExcludeTopologies."
-
 $ExcludeTopologies::usage =
 "$ExcludeTopologies[filt] is the function corresponding to filt in
 ExcludeTopologies -> {filt, ...}.  It must be defined as a pure function
 (i.e. func[#]&).  Given a topology, this function must return True if
 the topology shall not be discarded."
-
-Loops::usage =
-"Loops[n] is a filter used with ExcludeTopologies.  It excludes
+HighEnergyPhysics`FeynCalc`Loop`Loops::usage =
+"HighEnergyPhysics`FeynCalc`Loop`Loops[n] is a filter used with ExcludeTopologies.  It excludes
 topologies containing loops that are connected to the rest of the graph
 with n propagators."
-
 CTs::usage =
 "CTs[n] is a filter used with ExcludeTopologies.  It excludes the
-counter-term topologies corresponding to Loops[n]."
-
+counter-term topologies corresponding to HighEnergyPhysics`FeynCalc`Loop`Loops[n]."
 Tadpoles::usage =
 "Tadpoles is a filter used with ExcludeTopologies.  It excludes
 topologies containing loops that are connected to the rest of the graph
 with one propagator."
-
 TadpoleCTs::usage =
 "TadpoleCTs is a filter used with ExcludeTopologies.  It excludes
 counter-term topologies corresponding to Tadpoles."
-
 SelfEnergies::usage =
 "SelfEnergies is a filter used with ExcludeTopologies.  It excludes
 topologies containing loops that are connected to the rest of the graph
 with two propagators."
-
 SelfEnergyCTs::usage =
 "SelfEnergyCTs is a filter used with ExcludeTopologies.  It excludes
 counter-term topologies corresponding to SelfEnergies."
-
 WFCorrections::usage =
 "WFCorrections is a filter used with ExcludeTopologies.  It excludes
 wave-function-correction topologies, i.e. self-energy insertions and
 tadpoles on external legs.  It can also be used in the form
 WFCorrections[patt], which limits the selection to only those external 
 lines matching patt."
-
 WFCorrectionCTs::usage =
 "WFCorrectionCTs is a filter used with ExcludeTopologies.  It excludes
 wave-function-correction counter-term topologies, i.e. the counter-terms
 corresponding to WFCorrections.  It can also be used in the form
 WFCorrectionCTs[patt], which limits the selection to only those external
 lines matching patt."
-
 Triangles::usage =
 "Triangles is a filter used with ExcludeTopologies.  It excludes
 topologies containing loops that are connected to the rest of the graph
 with three propagators."
-
 TriangleCTs::usage =
 "TriangleCTs is a filter used with ExcludeTopologies.  It excludes the
 counter-term topologies corresponding to Triangles."
-
 Boxes::usage =
 "Boxes is a filter used with ExcludeTopologies.  It excludes
 topologies containing loops that are connected to the rest of the graph
 with four propagators."
-
 BoxCTs::usage =
 "BoxCTs is a filter used with ExcludeTopologies.  It excludes the
 counter-term topologies corresponding to Boxes."
-
 Pentagons::usage =
 "Pentagons is a filter used with ExcludeTopologies.  It excludes
 topologies containing loops that are connected to the rest of the graph
 with five propagators."
-
 PentagonCTs::usage =
 "PentagonCTs is a filter used with ExcludeTopologies.  It excludes the
 counter-term topologies corresponding to Pentagons."
-
 Hexagons::usage =
 "Hexagons is a filter used with ExcludeTopologies.  It excludes
 topologies containing loops that are connected to the rest of the graph
 with six propagators."
-
 HexagonCTs::usage =
 "HexagonCTs is a filter used with ExcludeTopologies.  It excludes the
 counter-term topologies corresponding to Hexagons."
-
 AllBoxes::usage =
 "AllBoxes is a filter used with ExcludeTopologies.  It excludes
 topologies containing loops that are connected to the rest of the graph
 with four or more propagators."
-
 AllBoxCTs::usage =
 "AllBoxCTs is a filter used with ExcludeTopologies.  It excludes
 counter-term topologies corresponding to AllBoxes."
-
 TadpolesOnly::usage =
 "TadpolesOnly is a short-cut used with CreateTopologies to keep only
 topologies containing tadpoles."
-
 TadpoleCTsOnly::usage =
 "TadpoleCTsOnly is a short-cut used with CreateCTTopologies to keep only
 topologies containing one-point counter-terms."
-
 SelfEnergiesOnly::usage =
 "SelfEnergiesOnly is a short-cut used with CreateTopologies to keep only
 topologies containing self-energies on internal lines."
-
 SelfEnergyCTsOnly::usage =
 "SelfEnergyCTsOnly is a short-cut used with CreateCTTopologies to keep
 only topologies containing two-point counter-terms on internal lines."
-
 TrianglesOnly::usage =
 "TrianglesOnly is a short-cut used with CreateTopologies to keep only
 topologies containing triangles."
-
 TriangleCTsOnly::usage =
 "TriangleCTsOnly is a short-cut used with CreateCTTopologies to keep
 only topologies containing three-point counter-terms."
-
 BoxesOnly::usage =
 "BoxesOnly is a short-cut used with CreateTopologies to keep only
 topologies containing boxes."
-
 BoxCTsOnly::usage =
 "BoxCTsOnly is a shortcut used with CreateCTTopologies to keep only
 topologies containing four-point counter-terms."
-
 PentagonsOnly::usage =
 "PentagonsOnly is a short-cut used with CreateTopologies to keep only
 topologies containing pentagons."
-
 PentagonCTsOnly::usage =
 "PentagonCTsOnly is a shortcut used with CreateCTTopologies to keep
 only topologies containing five-point counter-terms."
-
 HexagonsOnly::usage =
 "HexagonsOnly is a short-cut used with CreateTopologies to keep only
 topologies containing hexagons."
-
 HexagonCTsOnly::usage =
 "HexagonCTsOnly is a shortcut used with CreateCTTopologies to keep
 only topologies containing six-point counter-terms."
-
 ToTree::usage =
 "ToTree[top] returns top with the loops shrunk to points named
 Centre[adj][n] where adj is the adjacency of loop n."
-
 Centre::usage =
 "Centre[adj][n] represents the remains of loop n with adjacency adj
 after being shrunk to a point by ToTree."
-
 FreeWFQ::usage =
 "FreeWFQ[top, patt1, patt2] determines if the topology top is free of
 one-point vertices specified by patt1 and two-point vertices specified
 by patt2 on external legs.  For example, the WFCorrections filter uses
 FreeWFQ[ToTree[top], Centre[1], Centre[2]]&."
-
-LoopFields::usage =
-"LoopFields[top] returns a list of the fields that are part of any
-loop in the topology top.  LoopFields[rul, top] first substitutes
+HighEnergyPhysics`FeynCalc`Loop`LoopFields::usage =
+"HighEnergyPhysics`FeynCalc`Loop`LoopFields[top] returns a list of the fields that are part of any
+loop in the topology top.  HighEnergyPhysics`FeynCalc`Loop`LoopFields[rul, top] first substitutes
 the insertion rules rul into the bare topology top before proceeding. 
 This function is typically used as a filter for DiagramSelect or
 DiagramGrouping, as in
-DiagramSelect[diags, FreeQ[LoopFields[##], V[1]]&]."
-
+DiagramSelect[diags, FreeQ[HighEnergyPhysics`FeynCalc`Loop`LoopFields[##], V[1]]&]."
 WFCorrectionFields::usage =
 "WFCorrectionFields[top] extracts the fields external to any
 wave-function correction from topology top.
@@ -357,7 +277,6 @@ WFCorrectionFields[rul, top] first substitutes the insertion rules rul
 into the bare topology top before proceeding.  This function is 
 typically used as a filter for DiagramSelect, as in  
 DiagramSelect[diags, UnsameQ@@ WFCorrectionFields[##] &]."
-
 WFCorrectionCTFields::usage =
 "WFCorrectionCTFields[top] extracts the fields external to any
 wave-function-correction counter-term from topology top.
@@ -365,38 +284,30 @@ WFCorrectionFields[rul, top] first substitutes the insertion rules rul
 into the bare topology top before proceeding.  This function is 
 typically used as a filter for DiagramSelect, as in  
 DiagramSelect[diags, UnsameQ@@ WFCorrectionCTFields[##] &]."
-
 StartingTopologies::usage =
 "StartingTopologies is an option of CreateTopologies.  It specifies a
 pattern for selecting the starting topologies.  The latter are defined
 in Topology.m, e.g. at two-loop level there are three starting
 topologies: Theta, Eight, and Bicycle."
-
 StartTop::usage =
 "StartTop[l, cto] is the list of starting topologies for topologies with
 l loops and counter-term order cto.  The starting topologies are defined
 in Topology.m."
-
 Theta::usage =
 "Theta is the name of the two-loop starting topology that looks like the
 greek letter theta."
-
 Eight::usage =
 "Eight is the name of the two-loop starting topology that looks like the
 number 8."
-
 Bicycle::usage =
 "Bicycle is the name of the two-loop starting topology that looks (sort
 of) like a bicycle."
-
 Three::usage =
 "Three[n] is the name for the irreducible three-loop starting
 topologies, where n = 1...8."
-
 ThreeRed::usage =
 "ThreeRed[n] is the name for the reducible three-loop starting
 topologies, where n = 1...7."
-
 Adjacencies::usage =
 "Adjacencies is an option of CreateTopologies.  Its setting is a list
 {e1, e2, ...} of integers (ei > 2) of allowed adjacencies of vertices. 
@@ -404,22 +315,17 @@ The adjacency of a vertex is the number of propagators ending at that
 vertex.  The two special cases ei = 1 and 2 are for external particles
 and counter terms, respectively, and are taken care of by
 CreateTopologies."
-
 CTOrder::usage =
 "CTOrder is an option of CreateTopologies that specifies for which order
 counter terms shall be generated."
-
 CreateCTTopologies::usage =
 "CreateCTTopologies[l, i -> o] generates all counter-term topologies
 needed for the l-loop diagrams generated by CreateTopologies[l, i -> o]."
-
 CreateVFTopologies::usage =
 "CreateVFTopologies[l, i -> o] generates all topologies with 1PI vertex
 functions whose total loop order is l."
-
 TopologySort::usage = "TopologySort[top] sorts the topology top into a
 (more or less) canonical order."
-
 TopologyOrdering::usage =
 "TopologyOrdering[top] returns the topology top sorted into a (more or
 less) canonical order, together with the permutation that brings it into
@@ -427,70 +333,53 @@ this order, i.e. a list of the positions at which the propagators in the
 sorted version appeared in the unsorted version.  A negative integer in
 the permutation indicates that also the vertices in the respective
 propagator were exchanged with respect to the original."
-
 SymmetryFactor::usage =
 "SymmetryFactor[top] returns the symmetry factor for the topology top. 
 This value is needed if you want to enter new starting topologies."
-
-
 (* definitions for Insert.m *)
-
 Insertions::usage =
 "Insertions is the head of an insertion list.  Insertions[lev] specifies
 insertions at level lev.  Insertion lists are returned by InsertFields
 as a rule of the form \"topology -> insertionlist\"."
-
 FeynmanGraph::usage =
 "FeynmanGraph is the head of a list of field replacement rules.  The
 elements of an insertion list are FeynmanGraphs."
-
 Field::usage =
 "Field[n] denotes the nth field in a topology."
-
 InsertFields::usage =
 "InsertFields[top, {inc1, inc2, ...} -> {out1, out2, ...}] constructs
 all Feynman diagrams for the Topology or TopologyList top with incoming
 fields inc1, inc2, ... and outgoing fields out1, out2, ..."
-
 Restrictions::usage =
 "Restrictions is an option of InsertFields.  It contains shorthands to
 exclude vertices or particles defined in the corresponding model file."
-
 LastSelections::usage =
 "LastSelections is an option of InsertFields.  It is given as a list of
 symbols which must (or must not, if preceded by \"!\") appear in the
 Insertions."
-
 InsertionLevel::usage =
 "InsertionLevel is an option of InsertFields and CreateFeynAmp. 
 Possible values are Generic, Classes, or Particles.  Just as with the
 usual Mathematica level specification, e.g. {Particles} means \"only
 Particles level\" whereas Particles means \"down to Particles level\". 
 By default, CreateFeynAmp uses the same level as InsertFields."
-
 Generic::usage =
 "Generic denotes the generic (general field types) level of insertion."
-
 Classes::usage =
 "Classes denotes the classes (multiplets) level of insertion."
-
 Particles::usage =
 "Particles denotes the particles (members of classes) level of
 insertion."
-
 Model::usage =
 "Model -> \"MOD\" is an option of InsertFields to select the classes
 model MOD.  The model information is taken from the file MOD.mod."
-
 GenericModel::usage =
 "GenericModel -> \"GEN\" is an option of InsertFields and
 InitializeModel to select the generic model GEN.  The model information
 is taken from the file GEN.gen."
-
 Process::usage =
 "Process is returned by InsertFields as an option of TopologyList.  
 It specifies the process as a rule \"inparticles -> outparticles\"."
-
 FieldPoints::usage =
 "FieldPoints[top] returns a list of the field points contained in
 the topology top.  FieldPoints[rul, top] first substitutes the
@@ -498,67 +387,52 @@ insertion rules rul into the bare topology top before proceeding.
 This function is typically used as a filter for DiagramSelect or
 DiagramGrouping, as in
 DiagramSelect[diags, MemberQ[FieldPoints[##], (some field point)]&]."
-
 TakeInc::usage =
 "TakeInc[v][p] returns the incoming particle from vertex v in
 propagator p."
-
 IndexDelta::usage =
 "IndexDelta[i1, i2] is a symbol in the definition of a classes coupling
 indicating that the coupling is diagonal in the indices i1 and i2."
-
 IndexEps::usage =
 "IndexEps[i1, i2, i3] is the totally antisymmetric symbol in the indices
 i1, i2, i3."
-
-
 (* definitions for Initialize.m *)
-
 LoadGenericModel::usage =
 "LoadGenericModel[genname] loads the generic model file(s) genname.gen. 
 LoadGenericModel[genname, ext] specifies an explicit extension, i.e.
 loads genname.ext."
-
 LoadModel::usage =
 "LoadModel[modname] loads the classes model file(s) modname.mod. 
 LoadModel[modname, ext] specifies an explicit extension, i.e. loads
 modname.ext."
-
 DumpGenericModel::usage =
 "DumpGenericModel[genfile] saves the generic model file presently in
 memory in genfile.  DumpGenericModel[genfile, syms] includes the symbols
 syms in the variables to be saved in genfile."
-
 DumpModel::usage =
 "DumpModel[modfile] saves the classes model file presently in memory in
 modfile.  DumpModel[modfile, syms] includes the symbols syms in the
 variables to be saved in modfile."
-
 InitializeModel::usage =
 "InitializeModel[modname] initializes the classes model for the model
 modname and the generic model given by the GenericModel option.  The
 model information is taken from the file modname.mod.  InitializeModel[]
 initializes only the generic model."
-
 Reinitialize::usage =
 "Reinitialize is an option of InitializeModel.  InitializeModel will
 reinitialize the current model only if Reinitialize is set to True."
-
 GenericModelEdit::usage =
 "GenericModelEdit is an option of InitializeModel.  It specifies code
 that will be executed directly after loading the generic model, i.e.
 before the actual initialization."
-
 ModelEdit::usage =
 "ModelEdit is an option of InitializeModel.  It specifies code that will
 be executed directly after loading the classes model, i.e. before the
 actual initialization."
-
 RestrictCurrentModel::usage =
 "RestrictCurrentModel[args] applies a number of ExcludeFieldPoints and
 ExcludeParticles restrictions to the current model. 
 RestrictCurrentModel[] removes all currently active restrictions."
-
 ExcludeParticles::usage =
 "ExcludeParticles is an option of RestrictCurrentModel.  It specifies a
 list of fields to exclude from the current model.  Excluding a field at
@@ -566,7 +440,6 @@ a particular level automatically excludes all derived fields at lower
 levels.  For example, excluding F[3] also excludes all F[3, {...}]. 
 Further, the exclusion of a particle always implies exclusion of its
 antiparticle."
-
 ExcludeFieldPoints::usage =
 "ExcludeFieldPoints is an option of RestrictCurrentModel.  It specified
 a list of field points to exclude from the current model.  Excluding a
@@ -575,282 +448,212 @@ points on lower levels.  For example, excluding FieldPoint[F[3], -F[3],
 V[1]] also excludes FieldPoint[F[3, {1}], -F[3, {1}], V[1]] etc. 
 Further, the exclusion of a field point always implies exclusion of its
 charge-conjugate field point."
-
 FieldMatchQ::usage =
 "FieldMatchQ[f, fpatt] returns True if the field f matches the pattern
 fpatt and False otherwise.  The matching takes into account field levels,
 e.g. F[1] matches F."
-
 FieldMemberQ::usage =
 "FieldMemberQ[flist, fpatt] returns True if an element of flist matches
 fpatt in the sense that FieldMatchQ returns True."
-
 FieldPointMatchQ::usage =
 "FieldPointMatchQ[fp, fppatt] returns True if the field point fp matches
 the pattern fppatt and False otherwise.  The matching takes into account
 field levels, e.g. F[1] matches F."
-
 FieldPointMemberQ::usage =
 "FieldPointMemberQ[fplist, fppatt] returns True if an element of fplist
 matches fppatt in the sense that FieldPointMatchQ returns True."
-
 ExcludedQ::usage =
 "ExcludedQ[vertlist] gives True if vertlist contains any vertices
 currently excluded at Particles level."
-
 PossibleFields::usage =
 "PossibleFields[cto][t, fp] returns all possible fields of type t that
 fit fp at counter-term order cto.  t may be 0 (allowing all fields) or a
 generic field."
-
 CheckFieldPoint::usage =
 "CheckFieldPoint[fp] yields True if fp is a valid field point in the
 current model and False otherwise."
-
 AntiParticle::usage =
 "AntiParticle[f] returns the antiparticle of f."
-
 TheMass::usage =
 "TheMass[p] gives the value of the mass of particle p (if specified in
 the model file).  TheMass[p, t] gives the mass for particle p running
-on a propagator of type t (External, Internal, Loop)."
-
+on a propagator of type t (External, Internal, HighEnergyPhysics`FeynCalc`Loop`Loop)."
 Indices::usage =
 "Indices[c] gives a list of index names of class c."
-
 IndexRange::usage =
 "IndexRange[i] gives a list of possible values of index i."
-
 NoUnfold::usage =
 "NoUnfold, when wrapped around the right hand side of an IndexRange
 assignment, prevents InsertFields from \"unfolding\" that index at
 particles level, i.e. InsertFields then does not generate an extra
 diagram for every value the index can take on."
-
 IndexSum::usage =
 "IndexSum[expr, {i, range}] represents the unevaluated sum of expr in
 the index i over range.  To execute the sum, replace IndexSum by Sum."
-
 AddHC::usage =
 "AddHC[mat] extends mat by its Hermitian conjugate part, e.g.
 AddHC[A[1, i, j]] returns (A[1, i, j] + Conjugate[A[1, j, i]])/2.  
 AddHC[mat, w] forms the weighted sum with weight function w, e.g.
 AddHC[A[1, i, j], w] returns (w[i, j] A[1, i, j] + Conjugate[w[j, i]]
 Conjugate[A[1, j, i]])/2."
-
 RenConst::usage =
 "RenConst[rc] := ... defines the renormalization constant rc."
-
 ReferenceOrder::usage =
 "ReferenceOrder[x] gives a list of all field points of the current model
 in (unsorted) list form.  x can be Generic or Classes."
-
 FieldPoint::usage =
 "FieldPoint[cto][f1, f2, ...] is the representation of a field point of
 counter-term order cto with incoming fields f1, f2, ..."
-
 FieldPointList::usage =
 "FieldPointList[cto] returns a list of field points of counter-term order
 cto in the current model, FieldPointList[Classes] returns a list of field
 points of all orders in the current classes model, and
 FieldPointList[Generic] returns a list of all generic field points."
-
 KinematicVector::usage =
 "KinematicVector[fi] returns the kinematic vector of the coupling of the
 fields fi."
-
 CouplingDeltas::usage =
 "CouplingDeltas[v] returns a list of the IndexDeltas in which the entire
 vertex v is diagonal."
-
 F$Generic::usage =
 "F$Generic gives the list of generic fields of the current model.  
 Its contents may change with every call to RestrictCurrentModel."
-
 F$Classes::usage =
 "F$Classes gives the list of classes fields of the current model.  
 Its contents may change with every call to RestrictCurrentModel."
-
 F$Particles::usage =
 "F$Particles gives the list of particles fields of the current model. 
 Its contents may change with every call to RestrictCurrentModel."
-
 F$AllGeneric::usage =
 "F$AllGeneric gives the list of generic fields of the current model."
-
 F$AllClasses::usage =
 "F$AllClasses gives the list of classes fields of the current model."
-
 F$AllParticles::usage =
 "F$AllParticles gives the list of particles fields of the current
 model."
-
 F$AllowedFields::usage =
 "F$AllowedFields is the list of all fields at all three levels that are
 in the current model.  Its contents may change with every call to
 RestrictCurrentModel."
-
 L$CTOrders::usage =
 "L$CTOrders is the list of counter-term orders of the current model."
-
 Mom::usage =
 "Mom[n] is the momentum of the nth field in the kinematic vector."
-
 KI1::usage = KI2::usage = KI3::usage = KI4::usage =
 "KIi[n] is the ith kinematic index of the nth field in the kinematic
 vector."
-
 KIs = {KI1, KI2, KI3, KI4}
-
 SI::usage = "SI[n] is the nth summation index in a component of the
 kinematic vector."
-
 SIs = {SI1_, SI2_, SI3_, SI4}
-
 CI::usage = "CI[n] is the classes index of the nth field in the
 kinematic vector."
-
 PV::usage =
 "PV is the head of a general analytical expression in FeynArts.  
 The letters stand for Propagator/Vertex."
-
 F::usage =
 "F is a fermion field."
-
 S::usage =
 "S is a scalar field."
-
 SV::usage =
 "SV is a scalar-vector mixing field."
-
 VS::usage =
 "VS is a vector-scalar mixing field.  This field is for internal
 purposes only.  Do not use it in a model file."
-
 U::usage =
 "U is a ghost field (Grassmann-valued scalar field)."
-
 V::usage =
 "V is a vector boson field."
-
 T::usage =
 "T is a tensor field."
-
 $SVMixing::usage =
 "$SVMixing determines whether mixing of scalar and vector fields is
 allowed or not."
-
 $CounterTerms::usage =
 "$CounterTerms determines whether or not counter-term couplings are
 initialized during InitializeModel.  Note that once a model is
 initialized, if you change the value of $CounterTerms you have to
 re-initialize the model for this to take effect."
-
 $ModelPath::usage =
 "$ModelPath is a list of directory names which is searched for model
 files."
-
 $Model::usage =
 "$Model is the currently initialized classes model."
-
 $GenericModel::usage =
 "$GenericModel is the currently initialized generic model."
-
 ModelDebug::usage =
 "ModelDebug can be wrapped around a model name to enable debugging for
 that model."
-
 $ModelDebug::usage =
 "$ModelDebug determines whether changes introduced by add-on model files
 will be reported as a model is initialized.  It can be set to True, in
 which case debugging output will be generated for all add-on model
 files, or to the name (or list of names) of the add-on model file(s) to
 be debugged."
-
 $ModelDebugForm::usage =
 "$ModelDebugForm specifies the output form for debugging output when
 $ModelDebug = True is set."
-
 $ModelAdded::usage =
 "$ModelAdded contains the couplings added by the most recently
 initialized add-on model file if $ModelDebug = True."
-
 $ModelChanged::usage =
 "$ModelAdded contains the couplings changed by the most recently
 initialized add-on model file if $ModelDebug = True."
-
 $ModelRemoved::usage =
 "$ModelRemoved contains the couplings removed by the most recently
 initialized add-on model file if $ModelDebug = True."
-
 $ExcludedFPs::usage =
 "$ExcludedFPs is the list of currently excluded Generic- and
 Classes-level field points."
-
 $ExcludedParticleFPs::usage =
 "$ExcludedParticleFPs is the list of currently excluded Particles-level
 field points."
-
-
 (* definitions for the model files *)
-
 M$GenericPropagators::usage =
 "M$GenericPropagators is the list of propagators and their analytical
 expressions in the generic model file."
-
 M$GenericCouplings::usage =
 "M$GenericCouplings is the list of couplings and their analytical
 expressions in the generic model file."
-
 M$ClassesDescription::usage =
 "M$ClassesDescription is the list of classes properties in the classes
 model file."
-
 M$CouplingMatrices::usage =
 "M$CouplingMatrices is the list of explicit coupling matrices of the
 current model."
-
 M$TruncationRules::usage =
 "M$TruncationRules is a set of rules that is applied by CreateFeynAmp if
 Truncated -> True.  It is defined in the generic model file.  Typically,
 it removes external wavefunctions."
-
 M$FlippingRules::usage =
 "M$FlippingRules is a set of rules defined in the generic model file
 that specify how noncommutative structures in a coupling change when the
 order of the corresponding fields changes.  For example, it specifies
 how to derive the coupling C[F, -F, ...] from C[-F, F, ...]."
-
 M$LastModelRules::usage =
 "M$LastModelRules is a set of rules that is applied by CreateFeynAmp at
 the very end.  It is defined in the model file and can e.g. contain
 mappings of symbols to certain Contexts or to special symbols of other
 packages."
-
 M$LastGenericRules::usage =
 "M$LastGenericRules is a set of rules that is applied by CreateFeynAmp
 after creation of the generic amplitudes.  It is defined in the generic
 model file and can contain e.g. mappings of symbols to certain Contexts
 or to special symbols of other packages."
-
 AnalyticalCoupling::usage =
 "AnalyticalCoupling[vertex] == G[_][__] . {__} is the form a vertex is
 specified in a generic model file."
-
 AnalyticalPropagator::usage =
 "AnalyticalPropagator[type][field] == expr is the form a propagator is
 specified in a generic model file."
-
 KinematicIndices::usage =
 "KinematicIndices[fi] is a list of the kinematic indices the generic
 field fi carries.  For example, KinematicIndices[V] = {Lorentz} in
 Lorentz.gen."
-
 FieldNumber::usage =
 "FieldNumber[f] can be used in the AnalyticalPropagator and
 AnalyticalCoupling definitions of the Generic model file to find out
 the ordinal number of a field in the diagram being inserted."
-
 MatrixTraceFactor::usage =
 "MatrixTraceFactor -> n is an optional entry for fermions in the 
 M$ClassesDescription list.  A MatrixTrace (a closed loop of fermions) is 
@@ -858,18 +661,15 @@ multiplied by the MatrixTraceFactor of its consituents.  Typical usage
 is MatrixTraceFactor -> 3 for quarks.  The factor may contain objects of 
 the form Index[type], which are substituted by the actual indices 
 carried by the fields in the loop."
-
 SelfConjugate::usage =
 "SelfConjugate -> True | False is an entry in the M$ClassesDescription
 list.\n
 SelfConjugate[p] is True if field p is self-conjugate and False
 otherwise."
-
 Mixture::usage =
 "Mixture -> lc is an optional entry in the M$ClassesDescription list
 which specifies that the field is the linear combination lc of other
 fields."
-
 InsertOnly::usage =
 "InsertOnly is an entry in the M$ClassesDescription list.  It specifies
 the types of progators the particle may be inserted into.  If not
@@ -877,19 +677,16 @@ explicitly specified, the particle may be inserted into all types of
 propagators.\n
 InsertOnly[p] returns the types of propagators in which field p may be
 inserted into."
-
 Mass::usage =
 "Mass[p] denotes the mass of particle p.  Mass[p, t] denotes the mass of
-particle p running on a propagator of type t (External, Internal, Loop). 
+particle p running on a propagator of type t (External, Internal, HighEnergyPhysics`FeynCalc`Loop`Loop). 
 It is just a symbol carrying no further information.  FeynArts defines
 the function TheMass that returns the explicit symbol of the mass (if
 specified by the model file)."
-
 MixingPartners::usage =
 "MixingPartners -> {...} is an entry in the M$ClassesDescription list
 for mixing fields and specifies their mixing partners.\n
 MixingPartners[p] returns the partners of mixing field p."
-
 QuantumNumbers::usage =
 "QuantumNumbers -> {...} is an entry in the M$ClassesDescription list. 
 It lists the quantum numbers a particle possesses.  Identifiers for the
@@ -898,7 +695,6 @@ are needed only when 1PI vertex-function insertions are generated (i.e.
 for topologies created with CreateVFTopologies) to weed out such vertex
 function that violate the conservation of a quantum number, as
 determined by ViolatesQ."
-
 ViolatesQ::usage =
 "ViolatesQ is a function defined in the model file that determines
 whether a vertex function violates quantum-number conservation.  It is
@@ -907,75 +703,56 @@ when inserting topologies created with CreateVFTopologies).  It receives
 as arguments the quantum numbers of the involved fields (times -1 for
 antiparticles) and must return True if the vertex violates the
 conservation of those quantum numbers."
-
 Compatibles::usage =
 "Compatibles[p] is a list of particles that are compatible with p."
-
 SVCompatibles::usage =
 "SVCompatibles[p] is a list of SV particles that are compatible with p."
-
 Index::usage =
 "Index is the head of an index name (i.e. Index[Generation])."
-
 PropagatorType::usage =
 "PropagatorType is an option used in the M$ClassesDescription list of a
 model file and specifies the type of propagator for a particle. 
 Possible values are Straight, Sine, Cycles, ScalarDash, and GhostDash. 
 For a mixing propagtor, a list with two propagator types may be
 specified."
-
 Straight::usage =
 "Straight selects a straight line in the PropagtorType option."
-
 Sine::usage =
 "Sine selects a wavy line in the PropagatorType option."
-
 Cycles::usage =
 "Cycles selects a cycloid in the PropagatorType option."
-
 ScalarDash::usage =
 "ScalarDash selects a dashed line in the PropagatorType option."
-
 GhostDash::usage =
 "GhostDash selects a dotted line in the PropagatorType option."
-
 PropagatorArrow::usage =
 "PropagatorArrow -> Forward, Backward, None is an option used in the
 M$ClassesDescription list in the model file."
-
 Forward::usage =
 "Forward selects a forward arrow in the PropagatorArrow option."
-
 Backward::usage =
 "Backward selects a backward arrow in the PropagatorArrow option."
-
 PropagatorLabel::usage =
 "PropagatorLabel is an option used in the M$ClassesDescription list in
 the model file.  It is translated into TheLabel statements during model
 initialization."
-
 TheLabel::usage =
 "TheLabel[p] returns the PropagatorLabel of particle p."
-
 IndexStyle::usage =
 "IndexStyle[i] gives the rendering information for the index i.  For
 example, IndexStyle[Index[Lorentz, i_]] := Greek[i + 11] makes Lorentz
 indices appear as \"\\mu\", \"\\nu\", etc."
-
 TheCoeff::usage =
 "TheCoeff[f] gives the list of component fields of which f is a
 linear combination together with the respective coefficients.  
 For a non-composite field, TheCoeff returns the field itself."
-
 TheC::usage =
 "TheC is an internal symbol for storing the coupling matrices."
-
 C::usage =
 "C[cto][fields][kinpart] is the symbolic form of a coupling that is
 returned when CreateFeynAmp fails to resolve a classes coupling.\n
 C[fi] == coupl used as an entry in the M$CouplingMatrices list in the
 classes model file defines the coupling of the fields fi."
-
 CC::usage =
 "CC[fields] == coupl may be used in the M$CouplingMatrices list in the
 classes model file to define the coupling of the fields fi, together
@@ -983,120 +760,95 @@ with the conjugate coupling in one line.  The conjugation is performed
 with the function ConjugateCoupling which must be defined accordingly. 
 If no definition is made, the final amplitudes will simply contain the
 symbol ConjugateCoupling."
-
 ConjugateCoupling::usage =
 "ConjugateCoupling[coupl] defines how the charge-conjugated coupling is
 derived from coupl.  Typically, one I multiplying the coupling constant
 must not be conjugated because it derives from the exponent of the path
 integral.  If no definition is made for ConjugateCoupling, the final
 amplitudes will contain this symbol."
-
 GetCouplings::usage =
 "GetCouplings[C[fi], ...] returns all couplings of the form C[fi] == _
 in M$CouplingMatrices."
-
 ReplaceCouplings::usage =
 "ReplaceCouplings[C[fi] == coup] replaces all couplings matching C[fi]
 in M$CouplingMatrices.  All couplings in M$CouplingMatrices, including
 the former versions of the ones being replaced, may be used on the
 r.h.s. in the form C[fields]."
-
 G::usage =
 "G[sym][cto][fields][kinpart] is a generic coupling matrix of
 counter-term order cto for fields corresponding to the kinematical
 object kinpart.  G is symmetric for sym = 1 and antisymmetric for sym =
 -1."
-
-
 (* definitions for Analytic.m *)
-
 CreateFeynAmp::usage =
 "CreateFeynAmp[tops] creates a list of Feynman amplitudes (Head:
-FeynAmpList) of all insertions of Topology or TopologyList tops."
-
+HighEnergyPhysics`FeynCalc`FeynAmpList`FeynAmpList) of all insertions of Topology or TopologyList tops."
 AmplitudeLevel::usage =
 "AmplitudeLevel is an option of CreateFeynAmp and specifies for which
 levels amplitudes are to be created."
-
 GaugeRules::usage =
 "GaugeRules is an option of CreateFeynAmp.  It is given as a list of
 rules to select a particular gauge.  For example, Feynman gauge is
-obtained by GaugeRules -> {_GaugeXi -> 1}."
-
+obtained by GaugeRules -> {_HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi -> 1}."
 PreFactor::usage =
 "PreFactor is an option of CreateFeynAmp and specifies the prefactor for
-each diagram.  In the expression for the prefactor the symbol LoopNumber
+each diagram.  In the expression for the prefactor the symbol HighEnergyPhysics`FeynCalc`Loop`LoopNumber
 can be used which will subsequently be replaced by the actual loop
 number."
-
-LoopNumber::usage =
-"LoopNumber is used with the option PreFactor of CreateFeynAmp and is
+HighEnergyPhysics`FeynCalc`Loop`LoopNumber::usage =
+"HighEnergyPhysics`FeynCalc`Loop`LoopNumber is used with the option PreFactor of CreateFeynAmp and is
 replaced by the loop number of the topology."
-
 Truncated::usage =
 "Truncated is an option of CreateFeynAmp that determines whether to
 apply the M$TruncationRules of the current generic model."
-
 MomentumConservation::usage =
 "MomentumConservation is an option of CreateFeynAmp.  It specifies
 whether momentum conservation at each vertex is enforced.  If set to
 False, every propagator will carry its own momentum."
-
 GraphInfoFunction::usage =
 "GraphInfoFunction is an option of CreateFeynAmp.  It specifies a
 function with which every diagram is multiplied.  The function receives
 two arguments, f[rul, top], where rul are the insertion rules and top
 the corresponding topology of the diagram.  This function can be used
 to add graph information to the amplitude."
-
 VertexDebug::usage =
 "VertexDebug[debuginfo] is a function invoked whenever a vertex cannot
 be resolved.  It is used for debugging FeynArts."
-
 VertexFunction::usage =
 "VertexFunction[o][f1, f2, ...] represents the 1PI vertex function of
 loop-order o with external fields f1, f2, ..."
-
 FindVertex::usage =
 "FindVertex[vert, lev] looks up vertex vert in the currently initialized
 model where lev = Generic or Classes.  If a match is found, the
 permutation is returned which brings the vertex vert into the reference
 order."
-
 PickLevel::usage =
 "PickLevel[lev][amp] constructs the concrete amplitudes at level lev
 from the CreateFeynAmp result amp.  PickLevel[lev][tops] picks out the
 diagrams at level lev from TopologyList tops.  Note that in topology
 lists you can never delete the Generic level."
-
 DiagramExtract::usage =
 "DiagramExtract[expr, n] extracts diagrams by number from the topology
 or amplitude list expr.  n may be of the form 3, 42, 17...28 which
 selects diagrams 3, 42, and 17 through 28."
-
 DiagramDelete::usage =
 "DiagramDelete[expr, n] discards diagrams by number from the topology
 or amplitude list expr.  n may be of the form 3, 42, 17...28 which
 selects diagrams 3, 42, and 17 through 28."
-
 Discard[args__] := (
   Message[Discard::obsalt, Discard, DiagramDelete];
   DiagramDelete[args] )
-
 DiagramMap::usage =
 "DiagramMap[foo, diags] maps foo over all Feynman diagrams in diags."
-
 DiagramSelect::usage =
 "DiagramSelect[diags, crit] selects the diagrams from diags for which
 crit is true.  For example, for selecting diagrams where field #5 is not
 a S[1], one could use DiagramSelect[diags, FreeQ[#, Field[5] -> S[1]]&]."
-
 DiagramGrouping::usage =
 "DiagramGrouping[tops, foo] returns a list of parts of the inserted
 topologies tops, grouped according to the output of foo.  For example,
 DiagramGrouping[tops, FermionRouting] returns a list of
 fermion-flow-ordered diagrams."
-
 FermionRouting::usage =
 "FermionRouting[top] finds out which external lines are connected
 through fermion lines for the inserted topology top. 
@@ -1106,33 +858,28 @@ of integers of which every successive two denote the end-points of
 a fermion line in the diagram.  This function is typically used as
 a filter for DiagramSelect or DiagramGrouping, as in
 DiagramSelect[diags, FermionRouting[##] == {1, 4, 2, 3} &]."
-
-FeynAmpCases::usage =
-"FeynAmpCases[patt, lev][amp] finds the instances of pattern patt in the
-amplitude amp.  FeynAmpCases[patt, lev][rul, top, h] does the same for
+HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpCases::usage =
+"HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpCases[patt, lev][amp] finds the instances of pattern patt in the
+amplitude amp.  HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpCases[patt, lev][rul, top, h] does the same for
 the amplitude resulting from topology top inserted with insertion rules
 rul using topology-list header h.  The level specification lev is
 optional and defaults to Infinity.  This function is typically used as
 a filter for DiagramSelect or DiagramGrouping, as in
-DiagramGrouping[diags, FeynAmpCases[_[Index[Colour | Gluon, _], ___]]]."
-
-FeynAmpExpr::usage =
-"FeynAmpExpr[rul, top, h] returns the amplitude resulting from topology
+DiagramGrouping[diags, HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpCases[_[Index[Colour | Gluon, _], ___]]]."
+HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpExpr::usage =
+"HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpExpr[rul, top, h] returns the amplitude resulting from topology
 top inserted with insertion rules rul using topology-list header h. 
 This function is typically used as a filter for DiagramSelect or
 DiagramGrouping."
-
 DiagramComplement::usage =
 "DiagramComplement[diagall, diag1, diag2, ...] gives all diagrams in
 diagall which are not in any of the diagi."
-
 ToFA1Conventions::usage =
 "ToFA1Conventions[expr] converts expr back to FeynArts 1 conventions. 
 Note that this conversion only renames some symbols.  The output may
 thus not be 100% FeynArts 1 compatible since certain kinds of
 expressions (e.g. Generic insertions) could not be generated with
 FeynArts 1 at all."
-
 $FermionLines::usage =
 "$FermionLines is a FeynArts system constant that can be True or False
 indicating whether CreateFeynAmp should collect Grassmann-valued fields
@@ -1146,7 +893,6 @@ Note that if $FermionLines = False, the M$ClassesDescription option
 MatrixTraceFactor has no effect on fermionic classes and also no
 additional minus signs are inserted for odd permutations of external
 fermions."
-
 $SparseCouplings::usage =
 "$SparseCouplings is a FeynArts system constant.  If set to True, a
 model is initialized such that all zero-components of the coupling
@@ -1154,223 +900,161 @@ vector are handled by a single default rule, which speeds up lookup of
 Feynman rules in the presence of large but sparse coupling vectors.
 Use with care, as individual checks of the kinematical components are
 not possible anymore then."
-
-FeynAmp::usage =
-"FeynAmp is the head of a data structure that represents the analytical
+HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmp::usage =
+"HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmp is the head of a data structure that represents the analytical
 expression of a single Feynman graph.  Its members are: graph name, list
 of integration momenta, analytical expression of the amplitude."
-
-FeynAmpList::usage =
-"FeynAmpList is the head of a list of FeynAmps."
-
+HighEnergyPhysics`FeynCalc`FeynAmpList`FeynAmpList::usage =
+"HighEnergyPhysics`FeynCalc`FeynAmpList`FeynAmpList is the head of a list of HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmps."
 GraphID::usage =
-"GraphID is the head of a data structure identifying a single FeynAmp in
-a FeynAmpList."
-
+"GraphID is the head of a data structure identifying a single HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmp in
+a HighEnergyPhysics`FeynCalc`FeynAmpList`FeynAmpList."
 Integral::usage =
-"Integral[q] is a member of a FeynAmp data structure and contains the
+"Integral[q] is a member of a HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmp data structure and contains the
 integration momenta of the amplitude (empty for tree graphs)."
-
 RelativeCF::usage =
 "RelativeCF is the relative combinatorial factor of a graph with respect
 to the generic graph it was created from.  This symbol appears in
 generic amplitudes and its value is defined for every Classes or
 Particles insertion."
-
 SumOver::usage =
 "SumOver[i, r] indicates that the amplitude it is multiplied with is to
 be summed in the index i over the range r.  If r is an integer, it
 represents the range {1, 2, ..., r}.  For an index belonging to an
 external particle there is a third argument, External."
-
-PropagatorDenominator::usage =
-"PropagatorDenominator[p, m] stands for the expression 1/(p^2 - m^2)
+HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator::usage =
+"HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[p, m] stands for the expression 1/(p^2 - m^2)
 that is contained in internal propagators of a Feynman graph. 
-PropagatorDenominator[p, m, d] is the denominator raised to the
+HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[p, m, d] is the denominator raised to the
 power d."
-
-FeynAmpDenominator::usage =
-"FeynAmpDenominator[d1, d2, ...] contains the PropagatorDenominators 
+HighEnergyPhysics`FeynCalc`FeynAmpDenominator`FeynAmpDenominator::usage =
+"HighEnergyPhysics`FeynCalc`FeynAmpDenominator`FeynAmpDenominator[d1, d2, ...] contains the HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominators 
 d1, d2, ... that belong to a loop."
-
-GaugeXi::usage =
-"GaugeXi[s] is a gauge parameter with index s."
-
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi::usage =
+"HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[s] is a gauge parameter with index s."
 FourMomentum::usage =
 "FourMomentum[s, n] is the nth momentum of type s.  Allowed types are
 Incoming, Outgoing, External, and Internal."
-
-NonCommutative::usage =
-"NonCommutative is the head of noncommuting objects in a Feynman rule."
-
+HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative::usage =
+"HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative is the head of noncommuting objects in a Feynman rule."
 MatrixTrace::usage =
 "MatrixTrace is the head of a trace of noncommuting objects (i.e. of
-symbols with head NonCommutative in the Feynman rules) in closed fermion
+symbols with head HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative in the Feynman rules) in closed fermion
 loops."
-
 FermionChain::usage =
 "FermionChain is the head of a trace of noncommuting objects (i.e. of
-symbols with head NonCommutative in the Feynman rules) in open fermion
+symbols with head HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative in the Feynman rules) in open fermion
 chains."
-
-
 (* definitions for Graphics.m *)
-
 Paint::usage =
 "Paint[tops] draws a list of inserted or bare topologies."
-
 AutoEdit::usage =
 "AutoEdit is an option of Paint.  If True, the topology editor is called
 when an unshaped topology is found."
-
 ColumnsXRows::usage =
 "ColumnsXRows is an option of Paint.  It specifies how many diagrams are
 arranged on a page.  For example, ColumnsXRows -> 3 draws 3 rows of 3
 diagrams each, or ColumnsXRows -> {5, 8} draws 8 rows of 5 diagrams
 each."
-
 PaintLevel::usage =
 "PaintLevel is an option of Paint and specifies for which levels
 diagrams are drawn."
-
 SheetHeader::usage =
 "SheetHeader is an option of Paint.  Automatic or True selects the
 default header (the process for inserted or #in -> #out for bare
 topologies), False disables headers, everything else is taken literally
 as a header (e.g. SheetHeader -> \"Self-energy diagrams\")."
-
 Numbering::usage =
 "Numbering is an option of Paint.  It can take the values Full, Simple,
 or None.  Full generates numbering of the form T1 C8 N15 (= topology 1,
 classes insertion 8, running number 15), Simple generates just a running
 number, and None omits the numbering altogether."
-
 Full::usage =
 "Full is a possible choice for the Numbering option of Paint.  It
 specifies that the numbering of the diagrams be of the form T1 C8 N15
 (= topology 1, classes insertion 8, running number 15)."
-
 Simple::usage =
 "Simple is a possible choice for the Numbering option of Paint.  It
 specifies that the numbering of the diagrams be just a running number."
-
 FieldNumbers::usage =
 "FieldNumbers is an option of Paint.  It it meaningful only for bare
 topologies where it specifies whether the field numbers (the n in
 Field[n]) are used for labelling the propagators.  This can be helpful
 for selecting diagrams."
-
 PropagatorGraphics::usage =
 "PropagatorGraphics[type, arrow, label][from, to, height, labelpos] is 
 a graphics object representing a propagator."
-
 VertexGraphics::usage =
 "VertexGraphics[cto][xy] is a graphics object representing a vertex."
-
 DiagramGraphics::usage =
 "DiagramGraphics[title][graphics] is a graphics object representing a
 Feynman diagram."
-
 FeynArtsGraphics::usage =
 "FeynArtsGraphics[title][sheet1, sheet2, ...] is a graphics object
 representing Feynman diagrams.  The individual sheets are matrices of
 DiagramGraphics objects with the rows and columns of the matrix
 representing the graphical arrangement of the diagrams into rows and
 columns on the output page."
-
 Render::usage =
 "Render[g, format] renders the FeynArtsGraphics object g.  The output
 is a string for the \"PS\", \"EPS\", and \"TeX\" formats and a regular
 Graphics object for all other formats."
-
 ComposedChar::usage =
 "ComposedChar[t, sub, sup, bar] represents a label t with subscript sub,
 superscript sup, and accent bar.  Typically, bar is something like
 \"\\\\bar\", \"\\\\tilde\", etc.  The arguments sub, sup, and bar are
 optional but their position is significant.  For example,
 ComposedChar[t, Null, sup] is a label with a superscript only."
-
 Shape::usage =
 "Shape[tops] edits the shapes of the topologies tops."
-
 ShapeData::usage =
 "ShapeData[topcode] is the database of shapes currently in memory.  
 It is indexed by the three strings given by TopologyCode."
-
 TopologyCode::usage =
 "TopologyCode[top] returns a list of three strings identifying the
 topology.  This code is unique as far painting the topology is
 concerned."
-
 {TopBottom, LeftRight}	(* visible for printing *)
-
-
 (* FeynArts system constants *)
-
 $FeynArts::usage =
 "$FeynArts contains the version of FeynArts."
-
 $Verbose::usage =
 "$Verbose is an integer that determines the extent of run-time messages
 in FeynArts.  It ranges from 0 (no messages) to 2 (normal)."
-
 $FADebug::usage =
 "$FADebug = True causes various functions to print internal information
 for debugging purposes."
-
 $FeynArtsDir::usage =
 "$FeynArtsDir points to the directory from which FeynArts was loaded."
-
 $FeynArtsProgramDir::usage =
 "$FeynArtsProgramDir points to the directory which contains the FeynArts
 program files."
-
 $ShapeDataDir::usage =
 "$ShapeDataDir points to the directory which contains the data for
 drawing Feynman diagrams."
-
 P$Options::usage =
 "P$Options is a pattern for options."
-
 P$Topology::usage =
 "P$Topology is the pattern for a topology."
-
 P$Generic::usage =
 "P$Generic is the pattern for generic fields."
-
 P$NonCommuting::usage =
 "P$NonCommuting is the pattern for the non-commuting generic fields."
-
 P$InsertionObjects::usage =
 "P$InsertionObjects matches the objects in the generic amplitude that
 will be taken for insertions."
-
-
 P$Topology = Topology[__] | Topology[_][__]
-
 P$Generic = F | S | V | T | U | SV
-
 P$NonCommuting = F | U
-
-P$InsertionObjects = G[_][_][__][__] | _Mass | _GaugeXi |
+P$InsertionObjects = G[_][_][__][__] | _Mass | _HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi |
   VertexFunction[_][__]
-
 P$Options = (_Rule | _RuleDelayed)...
-
-
 $FeynArts = 3.7
-
 $FeynArtsDir = DirectoryName[ File /.
   FileInformation[System`Private`FindFile[$Input]] ]
-
 $FeynArtsProgramDir = ToFileName[{$FeynArtsDir, "FeynArts"}]
-
-
 Get[ ToFileName[$FeynArtsDir, "Setup.m"] ]
-
 If[ FileType["Setup.m"] === File, Get["Setup.m"] ]
-
-
 Block[ {$Path = {$FeynArtsProgramDir}},
 << Utilities`;
 << Topology`;
@@ -1379,9 +1063,5 @@ Block[ {$Path = {$FeynArtsProgramDir}},
 << Analytic`;
 << Graphics`
 ]
-
 EndPackage[]
-
-
 Null
-
diff --git FeynArts-3.7/FeynArts/Analytic.m FeynArts-3.7/FeynArts/Analytic.m
index fcbccef..7bf6297 100644
--- FeynArts-3.7/FeynArts/Analytic.m
+++ FeynArts-3.7/FeynArts/Analytic.m
@@ -4,71 +4,53 @@
 		analytic expressions
 		last modified 27 Mar 12 th
 *)
-
 Begin["`Analytic`"]
-
 Options[ CreateFeynAmp ] = {
   AmplitudeLevel -> InsertionLevel,	(* i.e. taken from InsertFields *)
-  GaugeRules -> {_GaugeXi -> 1},
-  PreFactor -> -I (2 Pi)^(-4 LoopNumber),
+  GaugeRules -> {_HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi -> 1},
+  PreFactor -> -I (2 Pi)^(-4 HighEnergyPhysics`FeynCalc`Loop`LoopNumber),
   Truncated -> False,
   MomentumConservation -> True,
   GraphInfoFunction -> (1 &)
 }
-
 (* for D dimensions use
-   PreFactor -> -I (Global`Mu^(4 - $D)/(2 Pi)^$D)^LoopNumber *)
-
+   PreFactor -> -I (Global`Mu^(4 - $D)/(2 Pi)^$D)^HighEnergyPhysics`FeynCalc`Loop`LoopNumber *)
 CreateFeynAmp::nolevel =
 "Warning: Level `1` is not contained in this insertion."
-
 CreateFeynAmp::mtrace =
 "Different MatrixTraceFactors inside one loop.  \
 Involved fields are `1`.  \
 Please check the classes model and try again."
-
 CreateFeynAmp::noprop =
 "Cannot resolve propagator of field `1`."
-
 CreateFeynAmp::ambig =
 "Warning: `1` contains more than two noncommuting fields, hence the \
 application of the flipping rules is not unambiguous and may give \
 wrong results."
-
 CreateFeynAmp::nocoupl =
 "Cannot resolve coupling `1` for kinematical object `2`."
-
 CreateFeynAmp::counter =
 "Counter-term order `2` is not defined in coupling of `1`."
-
-
 (* CreateFeynAmp invokes a hierarchy of functions:
      CreateFeynAmp[TopologyList]	select levels, init model
        CreateAmpTop[Topology]		add momenta, make fermion chains
          CreateAmpGraph[FeynmanGraph]	add indices, make generic expr
            CreateAmpIns[FeynmanGraph -> Ins] add GM replacement rules *)
-
 CreateFeynAmp[ top:(P$Topology -> _), opt___Rule ] :=
   CreateFeynAmp[ TopologyList[][top], opt ]
-
 CreateFeynAmp[ TopologyList[tops__], opt___Rule ] :=
   CreateFeynAmp[ TopologyList[][tops], opt ]
-
 CreateFeynAmp[ tops:TopologyList[info___][___], options___Rule ] :=
 Block[ {alevel, pref, next, gaugeru, truncru, momcons, graphinfo, toplist,
 amps, head, topnr = 1, opt = ActualOptions[CreateFeynAmp, options]},
-
   If[ (alevel = ResolveLevel[AmplitudeLevel /. opt /. {info} /.
         Options[InsertFields]]) === $Failed,
     Return[$Failed] ];
-
   If[ InitializeModel[ Model /. {info} /. Options[InsertFields],
     GenericModel -> (GenericModel /. {info} /. Options[InsertFields]),
     Reinitialize -> False ] === $Failed, Return[$Failed] ];
-
   FAPrint[2, ""];
   FAPrint[2, "creating amplitudes at level(s) ", alevel];
-
   next = Plus@@ Length/@ (Process /. {info});
   pref = PreFactor /. opt;
   gaugeru = GaugeRules /. opt;
@@ -76,37 +58,25 @@ amps, head, topnr = 1, opt = ActualOptions[CreateFeynAmp, options]},
   momcons = TrueQ[MomentumConservation /. opt];
   graphinfo = GraphInfoFunction /. opt;
   toplist = TopologyList[info];
-
   amps = PickLevel[alevel][tops];
   Scan[ If[FreeQ[amps, #], Message[CreateFeynAmp::nolevel, #]]&, alevel ];
-
   amps = CreateAmpTop/@ ( amps //.
     (_ -> Insertions[_][]) :> Seq[] /.
     (Field[i_] -> fi_?AtomQ) -> (Field[i] -> fi[Index[Generic, i]]) );
   FAPrint[1, "in total: ",
     Statistics[{Insertions[Generic]@@ amps}, alevel, " amplitude"]];
-
-  head = FeynAmpList[info] /.
+  head = HighEnergyPhysics`FeynCalc`FeynAmpList`FeynAmpList[info] /.
     (Process -> iorule_) :> (Process ->
       MapIndexed[{#1, iomom@@ #2, TheMass[#1, External]}&, iorule, {2}]) /.
     (InsertionLevel -> _) :> (AmplitudeLevel -> alevel);
-
   amps = head@@ amps /. _MTF -> 1 /. gaugeru //. M$LastModelRules;
-
   If[ Length[alevel] === 1, PickLevel[ alevel[[1]] ][amps], amps ]
 ]
-
-
 iomom[ 1, n_ ] = FourMomentum[Incoming, n]
-
 iomom[ 2, n_ ] = FourMomentum[Outgoing, n]
-
-
 CreateAmpTop[ P$Topology ] = Sequence[]
-
 CreateAmpTop[ top:P$Topology -> ins_ ] :=
 Block[ {momtop, imom, oldmom, amp, c, toppref, mtf, mc = 0, gennr = 0},
-
 	(* append momenta and enforce momentum conservation for
 	   every vertex.  For economical reasons, external momentum
 	   conservation (i.e. elimination of one momentum) is not
@@ -129,72 +99,50 @@ Block[ {momtop, imom, oldmom, amp, c, toppref, mtf, mc = 0, gennr = 0},
   oldmom = Union[ Cases[momtop, FourMomentum[_ZZZ, _], Infinity] ];
   imom = RenumberMom@@@ oldmom;
   momtop = momtop /. Thread[oldmom -> imom];
-
-  toppref = pref /. LoopNumber :> Genus[top];
-
+  toppref = pref /. HighEnergyPhysics`FeynCalc`Loop`LoopNumber :> Genus[top];
   amp = Sequence@@ (CreateAmpGraph[momtop, #]&)/@ ins;
   FAPrint[2, "> Top. ", topnr++, ": ",
     Statistics[{Insertions[Generic][amp]}, alevel, " amplitude"]];
   amp
 ]
-
-
 RemoveDups[ li_ ] :=
 Block[ {f},
   f[x_] := (f[x] = Sequence[]; x);
   f/@ li
 ]
-
-
 (* loop number using Euler's relation: *)
-
 Genus[ top_ ] := 
 Block[ {c, vn = {}},
   c[n_] := (AppendTo[vn, n]; 0);
   ++c[ #[[0, 1]] ]&/@ Union[Cases[top, Vertex[__][_], {2}]];
   (Plus@@ ((# - 2) c[#] &)/@ vn)/2 + 1
 ]
-
-
 FourMomentum[ type_, n_Integer mom_ ] :=
   -FourMomentum[type, -n mom] /; n < 0
-
-
 	(* ZZZ[priority] gives a ranking for eliminating momenta:
 	   of the sorted list of momenta at a vertex the last is
 	   eliminated, hence ZZZ[4] is eliminated before ZZZ[3] etc.
 	   Since momenta on tree propagators (Propagator[Internal])
 	   can always be expressed by the external momenta, they
 	   have the highest priority. *)
-
 	(* in case a momentum is given from outside: *)
 AppendMomentum[ Propagator[type_][from_, to_, fi_, mom_] ] :=
   Propagator[type][ from, to, fi,
-    FourMomentum[type /. {Loop[_] -> ZZZ[1], Internal -> ZZZ[3]},
+    FourMomentum[type /. {HighEnergyPhysics`FeynCalc`Loop`Loop[_] -> ZZZ[1], Internal -> ZZZ[3]},
       mom /. FourMomentum[_, t_] -> t] ]
-
 AppendMomentum[ pr:Propagator[Outgoing][from_, __] ] :=
   Append[ pr,
     If[from[[0, 1]] === 1, -1, 1] FourMomentum[Outgoing, ++c[Outgoing]] ]
-
 AppendMomentum[ pr:Propagator[Incoming | External][from_, __] ] :=
   Append[ pr,
     If[from[[0, 1]] === 1, 1, -1] FourMomentum[Incoming, ++c[Incoming]] ]
-
-AppendMomentum[ pr:Propagator[Loop[_]][__] ] :=
+AppendMomentum[ pr:Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[_]][__] ] :=
   Append[ pr, FourMomentum[ZZZ[2], ++c[Internal]] ]
-
 AppendMomentum[ pr:Propagator[Internal][__] ] :=
   Append[ pr, FourMomentum[ZZZ[4], ++c[Internal]] ]
-
-
 RenumberMom[ _, _Integer ] := FourMomentum[Internal, ++mc]
-
 RenumberMom[ _, id_ ] = FourMomentum[Internal, id]
-
-
 MomConservation[ top_, vert_ ] := Throw[top] /; FreeQ[top, ZZZ]
-
 MomConservation[ top_, vert_ ] :=
 Block[ {eq},
   eq = Plus@@ (IncomingMomentum[vert, #]&)/@ top;
@@ -204,19 +152,11 @@ Block[ {eq},
         Sort[Cases[{eq}, _FourMomentum, Infinity]][[-1]] ][[1]] ]
   ]
 ]
-
 IncomingMomentum[ v_, _[v_, v_, ___] ] = 0
-
 IncomingMomentum[ v_, _[v_, _, ___, m_] ] = -m
-
 IncomingMomentum[ v_, _[_, v_, ___, m_] ] = m
-
 IncomingMomentum[ __ ] = 0
-
-
 app[ fi_ ] = fi
-
-
 CreateAmpGraph[ top_, gr:FeynmanGraph[s_, ___][__] -> ins_ ] :=
 Block[ {amp, gm, rawgm, orig, anti},
 	(* must save Field[n] information to be able to subsequently
@@ -232,48 +172,36 @@ Block[ {amp, gm, rawgm, orig, anti},
   Append[amp, gm -> (CreateAmpIns[top, rawgm, s mtf, #]&)/@ ins] /.
     orig[__] :> Seq[]
 ]
-
 FieldNumber[ fi_ ] := Sequence@@ Cases[fi, Field[n_] -> n, Infinity, 1] /;
   !FreeQ[fi, orig]
-
-
 (* Create the basic amplitude *)
-
 CreateAmpGraph[ top_, FeynmanGraph[s_, ___][ru__] ] :=
 Block[ {c, res, props, vert, faden, prden = {},
 scalars = {RelativeCF, toppref, 1/s}},
-
   c[_] = 0;
   res = AddKinematicIndices/@ (List@@ top /. {ru});
   mtf = 1;
   If[ $FermionLines, res = MakeFermionChains[res] ];
-
 	(* props contains the propagators not involved in gmcs *)
   props = Cases[res, Propagator[_][__]];
   vert = Vertices[props];
-
 	(* insert the vertices in fermion chains first.  Note that
 	   MidVertex and ToChain modify vert *)
   res = res /. ch:_dot | _tr :> ResolveChain[ch];
-
 	(* now the remaining vertices *)
   vert = ResolveGeneric/@ vert;
-
 	(* TakeNC does the multiplication business.  It also updates
 	   scalars and prden *)
   res = Join[vert, res /. Propagator -> ResolvePropagator /. gaugeru] /.
     PV -> TakeNC;
-
-  FeynAmp[
+  HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmp[
     GraphID[Topology == topnr, Generic == ++gennr],
     Integral@@ imom,
     Times@@ DeleteCases[Flatten[scalars], 1] *
-      LoopPD[Expand[Times@@ Flatten[prden], PropagatorDenominator]] *
+      LoopPD[Expand[Times@@ Flatten[prden], HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator]] *
       Times@@ res /.
       truncru /. Mass -> TheMass ] //. M$LastGenericRules
 ]
-
-
 AddKinematicIndices[
   Propagator[type_][vert__, s_. fi_[ind___], mom_] ] :=
 Block[ {ki = KinematicIndices[fi], kin},
@@ -285,8 +213,6 @@ Block[ {ki = KinematicIndices[fi], kin},
     ] ];
   Propagator[type][vert, s fi[ind, mom, kin]]
 ]
-
-
 (* Building fermion chains.
    Fermionic (noncommuting) objects need to be organized into chains
    if they don't carry explicit spinor indices (which is the default).
@@ -298,30 +224,20 @@ Block[ {ki = KinematicIndices[fi], kin},
    case one must set $FermionLines = False and give the fermion fields an
    explicit spinor index with which it is possible (outside of FeynArts)
    to find the correct ordering of the fermionic objects. *)
-
 ReverseProp[ pr_[from_, to_, part_] ] :=
   pr[to, from, AntiParticle[part]]
-
 Attributes[ BuildChain ] = {Flat, Orderless}
-
 BuildChain[ c1:_[___, _[_, v_, _]], c2:_[_[v_, __], ___] ] :=
   Join[c1, c2]
-
 BuildChain[ c1:_[___, _[_, v_, _]], c2:_[___, _[_, v_, _]] ] :=
   Join[c1, Reverse[ReverseProp/@ c2]]
-
 BuildChain[ c1:_[_[v_, __], ___], c2:_[_[v_, __], ___] ] :=
   Join[Reverse[ReverseProp/@ c1], c2]
-
-
 Fixgmc[ c__ ] := tr[c] /; FreeQ[{c}, Vertex[1]]
-
 	(* a Dirac fermion, and it's in the right place *)
 Fixgmc[ c:_[__, -_], r___ ] := dot[c, r]
-
 	(* assuming that the front end must be a Majorana fermion, then *)
 Fixgmc[ r___, c:_[__, -_] ] := dot[r, c]
-
 	(* in principle there is no convention how to order Majorana 
 	   lines; whenever Truncated -> True is used, however, the 
 	   ordering, i.e. the type of spinor, does become important,
@@ -329,12 +245,8 @@ Fixgmc[ r___, c:_[__, -_] ] := dot[r, c]
 Fixgmc[ c1:_[__, _?SelfConjugate], r___, c2:_[__, _?SelfConjugate] ] :=
   dot[c1, r, c2] /;
   OrderedQ[{c2[[0, 1]][ c2[[2, 1]] ], c1[[0, 1]][ c1[[1, 1]] ]}]
-
 Fixgmc[ c__ ] := Reverse[ ReverseProp/@ dot[c] ]
-
-
 MakeFermionChains[ top_ ] := top /; FreeQ[top, P$NonCommuting]
-
 MakeFermionChains[ top_ ] :=
 Block[ {res, ext},
   res = Append[
@@ -342,7 +254,6 @@ Block[ {res, ext},
     BuildChain@@ gmc/@ Select[top, !FreeQ[#[[3]], P$NonCommuting]&] /.
       gmc -> Fixgmc
   ] /. BuildChain -> Sequence;
-
 	(* Since fermion chains are always traversed opposite to the
 	   fermion flow, we need the sign of the permutation that gets
 	   the list of external fermions into _descending_ order.
@@ -354,20 +265,12 @@ Block[ {res, ext},
   ext = Flatten[ Cases[res, d_dot :> Extract[d, {{1, 1}, {-1, 2}}, Leg]] ];
   AppendTo[ scalars,
     Signature[ext] (-1)^(Count[res, _tr] + Length[ext]/2) ];
-
   mtf = Times@@ Cases[res, t_tr :> MTF[ Union[Cases[t, Field[_], {-2}]] ]];
-
   res
 ]
-
-
 Leg[ Vertex[1][n_] ] = n
-
 Leg[ _ ] = {}
-
-
 MTF[ {} ] = 1
-
 MTF[ fi_List ] :=
 Block[ {res},
   res = Union[MatrixTraceFactor/@ fi];
@@ -376,25 +279,14 @@ Block[ {res},
   (* else *)
     Message[CreateFeynAmp::mtrace, fi]; 1 ]
 ] /; FreeQ[fi, Field]
-
-
 Attributes[ MTFIndex ] = {Listable}
-
 MTFIndex[ i_, _. fi_[n_, ind_] ] :=
   i /. Thread[Indices[fi[n]] -> ind]
-
-
 	(* useful for Truncated -> True *)
-NonCommutative[ 1 ] = Sequence[]
-
-
+HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ 1 ] = Sequence[]
 SignedMixers[ fi_ ] := MixingPartners[fi][[-1]] /; FreeQ[fi, Generic]
-
 SignedMixers[ -fi_[x__] ] := -MixingPartners[AntiParticle[fi]][[-1]][x]
-
 SignedMixers[ fi_[x__] ] := MixingPartners[fi][[-1]][x]
-
-
 ResolveGeneric[ vert:Vertex[_, cto_:0][_], chainprops___ ] :=
 Block[ {v, perm},
   v = SignedMixers/@ TakeInc[vert]/@ Flatten[{chainprops, props}];
@@ -402,65 +294,46 @@ Block[ {v, perm},
   If[ perm === $Failed, Return[{}] ];
   v = v[[perm]];
   If[ cto < 0,
-    I PV[ If[FreeQ[v, P$NonCommuting], Identity, NonCommutative][
+    I PV[ If[FreeQ[v, P$NonCommuting], Identity, HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative][
             VertexFunction[-cto]@@ v ] ],
   (* else *)
     AnalyticalCoupling[cto]@@ v ]
 ]
-
-
 ResolveChain[ c_[props__] ] := ToChain[c]@@ MidVertex[props]
-
-
 Attributes[ MidVertex ] = {Flat}
-
 MidVertex[ p1:Propagator[_][__], p2:Propagator[_][v_, __] ] := (
   vert = DeleteCases[vert, v];
   MidVertex[p1, ResolveGeneric[v, p1, p2], p2]
 )
-
-
 LeftVertex[ p1:_[Vertex[1][_], __] ] = p1
-
 LeftVertex[ p1:_[v_, __] ] := (
   vert = DeleteCases[vert, v];
   Seq[ResolveGeneric[v, p1], p1]
 )
-
-
 RightVertex[ p2:_[_, Vertex[1][_], ___] ] = p2
-
 RightVertex[ p2:_[_, v_, ___] ] := (
   vert = DeleteCases[vert, v];
   Seq[p2, ResolveGeneric[v, p2]]
 )
-
-
 ToChain[dot][ p1_, pr___, p2_ ] :=
   FermionChain[LeftVertex[p1], pr, RightVertex[p2]]
-
 ToChain[tr][ p1:_[v_, __], pr___, p2_ ] := (
   vert = DeleteCases[vert, v];
   MatrixTrace[p1, pr, p2, ResolveGeneric[v, p2, p1]]
 )
-
 	(* the single-propagator version applies to tadpoles: *)
 ToChain[tr][ p1:_[v_, __] ] := (
   vert = DeleteCases[vert, v];
   MatrixTrace[p1, ResolveGeneric[v, p1]]
 )
-
-
 FermionChain[] = MatrixTrace[] = 1	(* e.g. for ghosts *)
-
-
 	(* if AnalyticalPropagator with the exact type is not defined
 	   use a more generic type.  The replacement must be limited to
 	   the head or else the kinematical information is altered. *)
 ResolvePropagator[type_][ _, _, part_ ] :=
 Block[ {res},
   res = MapAt[
-    # /. {_Loop -> Internal, Incoming | Outgoing -> External} &,
+    # /. {_HighEnergyPhysics`FeynCalc`Loop`Loop -> Internal, Incoming | Outgoing -> External} &,
     AnalyticalPropagator[type][part],
     0 ];
   If[ Head[res] === PV,
@@ -468,59 +341,37 @@ Block[ {res},
   (* else *)
     Message[CreateFeynAmp::noprop, part]; Propagator[part] ]
 ]
-
-
 TakeNC[ f_List ] :=
 Block[ {s},
-  s = Select[f, FreeQ[#, NonCommutative]&];
-  AppendTo[scalars, Select[s, FreeQ[#, PropagatorDenominator]&]];
-  AppendTo[prden, Select[s, !FreeQ[#, PropagatorDenominator]&]];
-  Sequence@@ Select[f, !FreeQ[#, NonCommutative]&]
+  s = Select[f, FreeQ[#, HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative]&];
+  AppendTo[scalars, Select[s, FreeQ[#, HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator]&]];
+  AppendTo[prden, Select[s, !FreeQ[#, HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator]&]];
+  Sequence@@ Select[f, !FreeQ[#, HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative]&]
 ]
-
 TakeNC[ f_Times ] := TakeNC[List@@ f]
-
 TakeNC[ f_ ] := TakeNC[{f}]
-
-
 LoopPD[ p_ ] := p /; FreeQ[p, Internal]
-
 LoopPD[ p_Plus ] := LoopPD/@ p
-
 LoopPD[ p_Times ] :=
-  Select[p, FreeQ[#, PropagatorDenominator]&] *
-    LoopPD@@ Cases[p, _PropagatorDenominator]
-
-LoopPD[ p__PropagatorDenominator ] :=
+  Select[p, FreeQ[#, HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator]&] *
+    LoopPD@@ Cases[p, _HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator]
+LoopPD[ p__HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator ] :=
   Times@@ Select[{p}, FreeQ[#, FourMomentum[Internal, _]]&] *
-    FeynAmpDenominator@@ SortPD/@
+    HighEnergyPhysics`FeynCalc`FeynAmpDenominator`FeynAmpDenominator@@ SortPD/@
       Select[{p}, !FreeQ[#, FourMomentum[Internal, _]]&]
-
-
-SortPD[ PropagatorDenominator[mom_, mass__] ] :=
-  PropagatorDenominator[ Expand[-mom], mass ] /;
+SortPD[ HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom_, mass__] ] :=
+  HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[ Expand[-mom], mass ] /;
   !FreeQ[mom, -FourMomentum[Internal, _]]
-
 SortPD[ p_ ] = p
-
-
-Attributes[ FeynAmpDenominator ] = {Orderless}
-
-FeynAmpDenominator[ ] = 1
-
-
+Attributes[ HighEnergyPhysics`FeynCalc`FeynAmpDenominator`FeynAmpDenominator ] = {Orderless}
+HighEnergyPhysics`FeynCalc`FeynAmpDenominator`FeynAmpDenominator[ ] = 1
 SumOver[ i_, {}, ext___ ] := SumOver[i, 0, ext]
-
 SumOver[ i_, NoUnfold[l_], ext___ ] := SumOver[i, l, ext]
-
 SumOver[ i_, r:{___, l_Integer}, ext___ ] :=
   SumOver[i, l, ext] /; r === Range[l]
-
-
 CreateAmpIns[ top_, gm_, sgen_, gr_ -> ins_ ] :=
   CreateAmpIns[top, gm, sgen, gr] ->
     (CreateAmpIns[top, gm, sgen, #]&)/@ ins
-
 CreateAmpIns[ top_, gm_, sgen_, gr:FeynmanGraph[s_, ___][ru__] ] :=
 Block[ {ext, int, ins, deltas},
   ins = ReplacePart[gm, sgen/s, -1] /. {ru} /.
@@ -540,66 +391,47 @@ Block[ {ext, int, ins, deltas},
     Times@@ (SumOver[#, IndexRange[Take[#, 1]]]&)/@ int;
   ins
 ]
-
-
 (* about G -> C replacement: 
    GtoC tries to replace the head "G" by "TheC" (the classes permutation
    is first resolved by applying the appropriate mapping of kinematical
    indices to all G-expressions).  Failing that, it will try the negative
    kinematical expression (for a G[-]).  If neither method resolves TheC,
    it will issue a warning and return C[cto][fields][kinpart]. *) 
-
 GtoC[ sym_ ][ cto_ ][ fi__ ][ k_ ] :=
 Block[ {vert, perm, ferm, kin, cv, cvr},
   vert = Last/@ MixingPartners/@ {fi};
-
   perm = FindVertex[ToClasses[vert], Classes];
   If[ perm === $Failed, Return[C[cto][fi][k]] ];
-
-  ferm = Cases[vert, _. _F];
+  ferm = Cases[vert, _. _F|HighEnergyPhysics`Phi`Objects`$FermionHeads];
   vert = vert[[perm]];
   kin = k /. MapIndexed[KinRule, perm];
-  If[ Length[M$FlippingRules] > 0 && ferm =!= Cases[vert, _. _F],
+  If[ Length[M$FlippingRules] > 0 && ferm =!= Cases[vert, _. _F|HighEnergyPhysics`Phi`Objects`$FermionHeads],
     If[ Length[ferm] > 2, Message[CreateFeynAmp::ambig, vert] ];
     kin = kin /. M$FlippingRules ];
-
   cv = SignResolve[sym, cvr = TheC[kin]@@ vert];
-
   If[ !FreeQ[cv, TheC],
     Message[CreateFeynAmp::nocoupl, vert, kin];
     VertexDebug[{"vert" -> vert, "kin" -> kin, "cv" -> cvr,
       "fi" -> {fi}, "cto" -> cto}];
     Return[C[cto][fi][k]] ];
-
 	(* check requested counter-term order *)
   If[ Length[cv] <= cto,
     Message[CreateFeynAmp::counter, vert, cto];
     Return[C[cto][fi][k]] ];
-
   cv[[cto + 1]]
 ]
-
-
 SignResolve[ -1, TheC[kin_][cv__] ] := -TheC[-kin][cv]
-
 SignResolve[ _, c_ ] = c
-
-
 KinRule[i_, {i_}] = Sequence[]
-
 KinRule[i_, {j_}] = (obj:Alternatives@@ Prepend[KIs, Mom])[i] -> obj[j]
-
-
 FindVertex::novert =
 "Cannot find vertex `1`."
-
 	(* at classes level there may be several definitions for
 	   fermionic vertices, e.g. C[F, -F, ...] and C[-F, F, ...].
 	   Thus, an exact match is attempted first and only then the
 	   sorted form is used. *)
 FindVertex[ v_, Classes ] := Range[Length[v]] /;
   MemberQ[ReferenceOrder[Classes], v]
-
 FindVertex[ v_, lev_ ] :=
 Block[ {pos, fp},
   pos = Position[FieldPointList[lev], FieldPoint@@ v, 1, 1];
@@ -610,37 +442,23 @@ Block[ {pos, fp},
   fp[[ Ordering[fp] ]] = Ordering[v];
   fp
 ]
-
-
-Format[ G[sym_][cto_][fi__] ] :=
+format1[ G[sym_][cto_][fi__] ] :=
   DisplayForm[
     SubsuperscriptBox[ "G",
       StringJoin@@ ToString/@ ToGeneric[{fi}],
       "(" <> ToString[cto] <> ")" ] ]
-
-Format[ NonCommutative[nc__] ] := Dot[nc]
-
-Format[ MatrixTrace ] = "tr"
-
-Format[ FermionChain[a__] ] := Dot[a]
-
-Format[ PropagatorDenominator[p_, m_, d___] ] :=
+format1[ HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[nc__] ] := Dot[nc]
+format1[ MatrixTrace ] = "tr"
+format1[ FermionChain[a__] ] := Dot[a]
+format1[ HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[p_, m_, d___] ] :=
   Block[ {x = p^2 - m^2}, 1/x^d /; x =!= 0 ]
-
-Format[ FourMomentum[Incoming, i_Integer] ] := SequenceForm["p", i]
-
-Format[ FourMomentum[Outgoing, i_Integer] ] := SequenceForm["k", i]
-
-Format[ FourMomentum[Internal, i_Integer] ] := SequenceForm["q", i]
-
-Format[ FourMomentum[_, s_Symbol] ] = s
-
-Format[ Index[type_, i_] ] :=
-  SequenceForm[StringTake[ToString[type], 3], i]
-
-
+format1[ FourMomentum[Incoming, i_Integer] ] := SequenceForm["p", i]
+format1[ FourMomentum[Outgoing, i_Integer] ] := SequenceForm["k", i]
+format1[ FourMomentum[Internal, i_Integer] ] := SequenceForm["q", i]
+format1[ FourMomentum[_, s_Symbol] ] = s
+format1[ Index[type_, i_] ] :=
+  SequenceForm[StringTake[ToString[type],Min[3,StringLength[ToString[type]]]], i]
 PickLevel[ _ ][ tops_TopologyList ] = tops
-
 PickLevel[ lev_ ][ tops:TopologyList[___][___] ] :=
 Block[ {Rule, levels, res},
   _ -> Insertions[_][] = Sequence[];
@@ -661,24 +479,19 @@ Block[ {Rule, levels, res},
       Array[{#, 2}&, Length[res]] ] ];
   res
 ]
-
 PickLevel::nolevel =
-"Warning: FeynAmps have already been picked at a different level, \
+"Warning: HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmps have already been picked at a different level, \
 `1` level cannot be extracted."
-
-PickLevel[ lev_ ][ amps:FeynAmpList[___][___] ] :=
+PickLevel[ lev_ ][ amps:HighEnergyPhysics`FeynCalc`FeynAmpList`FeynAmpList[___][___] ] :=
 Block[ {n = 0, c = 0, warn = True},
   LevelPick[lev]/@ (amps /. Number == _ :> Seq[]) /.
     (AmplitudeLevel -> _) -> (AmplitudeLevel -> {lev})
 ]
-
-PickLevel[ lev_ ][ amp_FeynAmp ] :=
+PickLevel[ lev_ ][ amp_HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmp ] :=
 Block[ {n = 0, c = 0, warn = True},
-  FeynAmpList[AmplitudeLevel -> {lev}][
+  HighEnergyPhysics`FeynCalc`FeynAmpList`FeynAmpList[AmplitudeLevel -> {lev}][
     LevelPick[lev][amp /. Number == _ :> Seq[]] ]
 ]
-
-
 LevelPick[ Generic ][ amp_ ] :=
 Block[ {RelativeCF = 1},
   If[ Length[amp] =!= 3 || MatchQ[amp[[1]], GraphID[__, Generic == _]],
@@ -687,7 +500,6 @@ Block[ {RelativeCF = 1},
     If[warn, Message[PickLevel::nolevel, Generic]; warn = False];
       Seq[] ]
 ]
-
 LevelPick[ lev:Classes | Particles ][ amp_ ] := (
   Sequence@@ (Insert[#, Number == ++n, {1, -1}]&)/@
     If[ Length[amp] === 3,
@@ -696,14 +508,11 @@ LevelPick[ lev:Classes | Particles ][ amp_ ] := (
     (* else *)
       ApplyGMRules[Take[amp, 3], amp[[-1]], lev] ]
 )
-
-
 ApplyGMRules[ amp_, gm_ -> Insertions[lev_][ru__], lev_ ] :=
 Block[ {n = 0},
   Insert[#, lev == ++n, {1, -1}]&/@
     (amp /. (Thread[gm -> TakeGraph[#]]&)/@ {ru})
 ]
-
 ApplyGMRules[ amp_, gm_ -> Insertions[Classes][ru__], Particles ] :=
 Block[ {partru},
   partru = Flatten[TakeIns/@ Insertions[Particles][ru]];
@@ -711,15 +520,10 @@ Block[ {partru},
     ApplyGMRules[ Insert[amp, Classes == ++c, {1, -1}],
       gm -> partru, Particles ] ]
 ]
-
-
 ExpandRanges[n__] := List/@ Union[Flatten[ {n} /.
   a_Integer (Repeated | RepeatedNull)[b_] :>
     Range@@ Sort[Floor[{b, a}]] ]]
-
-
 AndLower[this:{r__, _, _}, o___] := AndLower[{r, 1}, this, o]
-
 DiagramExtract[ tops:TopologyList[info__][__], n__ ] :=
 Block[ {lev, p, Rule},
   lev = Alternatives@@ ResolveLevel[InsertionLevel /. {info}];
@@ -733,10 +537,7 @@ Block[ {lev, p, Rule},
     (FeynmanGraph[__][__] -> _[]) :> Seq[] /.
     (Topology[__][__] -> _[]) :> Seq[]
 ]
-
 DiagramExtract[ other_, n__ ] := Extract[other, ExpandRanges[n]]
-
-
 DiagramDelete[ tops:TopologyList[info__][__], n__ ] :=
 Block[ {lev, p, Rule},
   lev = Alternatives@@ ResolveLevel[InsertionLevel /. {info}];
@@ -747,10 +548,7 @@ Block[ {lev, p, Rule},
     (FeynmanGraph[__][__] -> _[]) :> Seq[] /.
     (Topology[__][__] -> _[]) :> Seq[]
 ]
-
 DiagramDelete[ other_, n__ ] := Delete[other, ExpandRanges[n]]
-
-
 DiagramMap[ foo_, tops:(h_TopologyList)[__] ] :=
 Block[ {lev, Rule},
   lev = ResolveLevel[InsertionLevel /. List@@ h][[-1]];
@@ -760,20 +558,14 @@ Block[ {lev, Rule},
     (FeynmanGraph[__][__] -> _[]) :> Seq[] /.
     (Topology[__][__] -> _[]) :> Seq[]
 ]
-
 DiagramMap[ foo_, other_ ] := foo/@ other
-
-
 DiagramSelect[ tops:TopologyList[___][__], crit_ ] :=
 Block[ {sel},
   sel[g_, r__] := g /; crit[g, r];
   _sel = Sequence[];
   DiagramMap[sel, tops]
 ]
-
 DiagramSelect[ other_, crit_ ] := Select[other, crit]
-
-
 DiagramGrouping[ tops:TopologyList[___][___], foo_ ] :=
 Block[ {Rule, tag, group, res, c = 0},
   Rule[_] := Sequence[];
@@ -784,60 +576,39 @@ Block[ {Rule, tag, group, res, c = 0},
     (FeynmanGraph[__][__] -> _[]) :> Seq[] /.
     (Topology[__][__] -> _[]) :> Seq[]
 ]
-
-
 Attributes[ prop ] = {Orderless}
-
 Attributes[ merge ] = {Flat, Orderless}
-
 merge[ prop[i_, j_], prop[j_, k_] ] := prop[i, k]
-
 FermionRouting[ gr_:{}, top:P$Topology, ___ ] := Level[
   merge@@ Apply[ prop[ #1[[1]], #2[[1]] ]&,
     Select[AddFieldNo[top] /. List@@ gr, !FreeQ[#, P$NonCommuting]&],
     1 ],
   {-1} ]
-
-
 toins[ Generic, gr_ ] := Insertions[Generic][gr]
-
 toins[ lev_, gr_ ] := Insertions[Generic][gr -> Insertions[lev][gr]]
-
-_FeynAmpCases[ _[], ___ ] = {}
-
-(fac_FeynAmpCases)[ gr:FeynmanGraph[__, lev_ == _][__],
+_HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpCases[ _[], ___ ] = {}
+(fac_HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpCases)[ gr:FeynmanGraph[__, lev_ == _][__],
     top:P$Topology, h_ ] :=
-  fac @ FeynAmpExpr[gr, top, h]
-
-FeynAmpCases[ patt_, lev_:Infinity ][ amp_ ] := Cases[amp, patt, lev]
-
-
-FeynAmpExpr[ gr:FeynmanGraph[__, lev_ == _][__], top:P$Topology, h_ ] :=
+  fac @ HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpExpr[gr, top, h]
+HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpCases[ patt_, lev_:Infinity ][ amp_ ] := Cases[amp, patt, lev]
+HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmpExpr[ gr:FeynmanGraph[__, lev_ == _][__], top:P$Topology, h_ ] :=
 Block[ {$Verbose = 0},
   CreateFeynAmp[ h[top -> toins[lev, gr]],
     AmplitudeLevel -> {lev} ]
 ]
-
-
 Unprotect[Exponent]
-
-Exponent[ FeynAmp[_, _, amp_], sym_ ] :=
+Exponent[ HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmp[_, _, amp_], sym_ ] :=
   Exponent[amp /. FermionChain | MatrixTrace -> Times, sym]
-
-Exponent[ FeynAmp[_, _, amp_, gm_ -> ins_], sym_ ] :=
+Exponent[ HighEnergyPhysics`FeynCalc`FeynAmp`FeynAmp[_, _, amp_, gm_ -> ins_], sym_ ] :=
 Block[ {tamp = amp /. FermionChain | MatrixTrace -> Times},
   Exponent[tamp /. gm -> #, sym]&/@ ins
 ]
-
 Protect[Exponent]
-
-
 DiagramComplement[ tops:TopologyList[info__][___],
   more:TopologyList[__][___].. ] :=
 Block[ {lev = ResolveLevel[InsertionLevel /. {info}][[-1]]},
   Fold[DiagramRemove[#2]/@ #1 &, tops, Level[{more}, {2}]]
 ]
-
 DiagramRemove[ top_ -> rem_ ][ top_ -> ins_ ] := top -> (
 Block[ {Rule, FeynmanGraph},
   Rule[_] := Sequence[];
@@ -848,24 +619,16 @@ Block[ {Rule, FeynmanGraph},
   ins
 ] /. (FeynmanGraph[__][__] -> _[]) :> Seq[] ) /.
   (Topology[__][__] -> _[]) :> Seq[]
-
 DiagramRemove[ _ ][ t_ ] = t
-
-
 ToJoin[ h:Topology == _, r__ ] := {h, ToJoin[r]}
-
 ToJoin[ r__, h:Number == _ ] := {ToJoin[r], h}
-
-
 ToFA1Conventions[ expr_ ] :=
-Block[ {GraphID, FourMomentum, Conjugate, Global`PolarizationVector,
-Global`DiracSpinor, Index, Integral = Sequence, FermionChain = Dot,
-NonCommutative = Dot, MatrixTrace = Global`DiracTrace},
-
+Block[ {GraphID, FourMomentum, Conjugate, Global`HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector,
+HighEnergyPhysics`FeynCalc`Spinor`Spinor, Index, Integral = Sequence, FermionChain = Dot,
+HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative = Dot, MatrixTrace = HighEnergyPhysics`fctools`DiracTrace`DiracTrace},
   GraphID[ id__ ] := Global`GraphName@@
     Apply[StringJoin, Flatten[{"", ToJoin[id]}] /.
       lev_ == n_ :> {StringTake[ToString[lev], 1], ToString[n]}, 1];
-
   FourMomentum[ Incoming | External, n_Integer ] :=
     FourMomentum[ Incoming | External, n ] =
       ToExpression["p" <> ToString[n]];
@@ -875,19 +638,13 @@ NonCommutative = Dot, MatrixTrace = Global`DiracTrace},
   FourMomentum[ Internal, n_Integer ] :=
     FourMomentum[ Internal, n ] =
       ToExpression["q" <> ToString[n]];
-
-  Conjugate[Global`PolarizationVector][ args__ ] :=
-    Conjugate[ Global`PolarizationVector[args] ];
-  Global`PolarizationVector[ _, mom_, li_ ] =
-    Global`PolarizationVector[mom, li];
-
-  (* Global`DiracSpinor[ mom_, mass_, ___ ] := FeynArts`Spinor[mom, mass]; *)
-
+  Conjugate[Global`HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector][ args__ ] :=
+    Conjugate[ Global`HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[args] ];
+  Global`HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[ _, mom_, li_ ] =
+    Global`HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[mom, li];
+  (*  *)
   Index[ Global`Lorentz, n_ ] := Index[Global`Lorentz, n] =
     ToExpression["li" <> ToString[n]];
-
   expr
 ]
-
 End[]
-
diff --git FeynArts-3.7/FeynArts/Graphics.m FeynArts-3.7/FeynArts/Graphics.m
index 7a389f7..2b919fc 100644
--- FeynArts-3.7/FeynArts/Graphics.m
+++ FeynArts-3.7/FeynArts/Graphics.m
@@ -3,69 +3,42 @@
 		Graphics routines for FeynArts
 		last modified 22 May 12 th
 *)
-
 Begin["`Graphics`"]
-
 NPi = N[Pi]
-
 	(* for "PS" format: paper size in bp for finding margins *)
 PaperSize = {595, 842}	(* A4, use 72 {8.5, 11} for Letter *)
-
 DefaultImageSize = 72 {6, 7}
-
 	(* Dimensions of a single diagram *)
 DiagramBorder = 1
-
 DiagramCanvas = 20
-
 DiagramSize = DiagramCanvas + 2 DiagramBorder
-
 LabelFontSize = 2 (* units of the diagram coordinate system *)
-
-LabelFont = "Helvetica"
-
+LabelFont="Times"
 	(* for ordinary vertices and counter terms: *)
 PropagatorThickness = Thickness[.11/DiagramSize]
-
 VertexThickness = PointSize[8 .11/DiagramSize]
-
 CounterThickness = Thickness[3 .11/DiagramSize]
-
 	(* for counter terms: *)
 CrossWidth = 1
-
 ArrowLength = 1.2
-
 	(* height of an arrow's thick end over the baseline *)
 ArrowHeight = .4
-
 DampingConst = (.65 ArrowLength)^4
-
 ScalarDashing = Dashing[{.66, .66}/DiagramSize]
-
 GhostDashing = Dashing[{.11, .66}/DiagramSize]
-
 	(* # of points per unit arc length used in drawing Sine and
 	   Cycles lines *)
 NPoints = 10
-
 	(* # of Sine or Cycles wave crests per unit arc length *)
 NCrestsSine = .5
-
 NCrestsCycles = .65
-
 SineAmp = .25
-
 CyclesAmp = .6
-
 	(* the breadth of the "spikes" of the cycloid *)
 CyclesBreadth = .16
-
 	(* default radius for label positioning, must be the
 	   same as DEFAULT_RADIUS in TopologyEditor.java *)
 DefaultRadius = 1.3
-
-
 Options[ Paint ] = {
   PaintLevel -> InsertionLevel,
   ColumnsXRows -> 3,
@@ -77,19 +50,14 @@ Options[ Paint ] = {
     DisplayFunction :> (Print/@ Render[#] &),
     DisplayFunction :> $DisplayFunction ]
 }
-
 Paint::nolevel =
 "Warning: Level `1` is not contained in this insertion."
-
 Paint::colrows =
 "ColumnsXRows is not an integer or a pair of integers."
-
 Paint[ top:P$Topology, opt:P$Options ] :=
   Paint[ TopologyList[top], opt ]
-
 Paint[ top:(P$Topology -> _), opt:P$Options ] :=
   Paint[ TopologyList[][top], opt ]
-
 Paint[ tops_TopologyList, options:P$Options ] :=
 Block[ {fnum, ghead, opt = ActualOptions[Paint, options]},
   fnum = FieldNumbers /. opt;
@@ -103,10 +71,8 @@ Block[ {fnum, ghead, opt = ActualOptions[Paint, options]},
     _,
       FeynArtsGraphics[ghead]
   ];
-
   PaintSheet[tops]
 ]
-
 Paint[ tops:TopologyList[info___][___], options:P$Options ] :=
 Block[ {plevel, ins, ghead,
 fnum = False, opt = ActualOptions[Paint, options]},
@@ -121,11 +87,9 @@ fnum = False, opt = ActualOptions[Paint, options]},
   Scan[
     If[FreeQ[ins, Insertions[#]], Message[Paint::nolevel, #]]&,
     plevel ];
-
   If[ InitializeModel[ Model /. {info} /. Options[InsertFields],
     GenericModel -> (GenericModel /. {info} /. Options[InsertFields]),
     Reinitialize -> False ] === $Failed, Return[$Failed] ];
-
   ghead = Switch[ ghead = SheetHeader /. opt,
     None | False,
       FeynArtsGraphics[],
@@ -139,12 +103,9 @@ fnum = False, opt = ActualOptions[Paint, options]},
     _,
       FeynArtsGraphics[ghead]
   ];
-
   PaintSheet[ ins //.
     (x:FeynmanGraph[___][__] -> Insertions[_][gr___]) :> Seq[x, gr] ]
 ]
-
-
 PaintSheet[ tops_ ] :=
 Block[ {auto, disp, cols, rows, dhead, g, topnr = 0, runnr = 0},
   auto = AutoEdit /. opt /. {False -> 2, _ -> 1};
@@ -172,15 +133,12 @@ Block[ {auto, disp, cols, rows, dhead, g, topnr = 0, runnr = 0},
     _,
       dhead[_] = DiagramGraphics[]
   ];
-
   g = Flatten[TopologyGraphics/@ List@@ tops] /. _Index -> Null;
   g = Flatten[{g, Table[Null, {Mod[rows cols - Length[g], rows cols]}]}];
   g = ghead@@ Partition[Partition[g, cols], rows];
   (DisplayFunction /. opt)[g];
   g
 ]
-
-
 TopologyGraphics[ top_ -> gr_ ] :=
 Block[ {shapedata, gtop, vertexplot},
   shapedata = Shape[gtop = top /. Vertex[e_, _] -> Vertex[e], auto];
@@ -195,39 +153,25 @@ Block[ {shapedata, gtop, vertexplot},
     PGraphics@@@ (gtop /. List@@ # /. Field[_] -> 0),
     vertexplot }]&/@ List@@ gr
 ]
-
 TopologyGraphics[ top_ ] :=
   TopologyGraphics[
     MapIndexed[Append[ Take[#1, 2], #2[[1]] ]&, top] -> {{}} ] /; fnum
-
 TopologyGraphics[ top_ ] :=
   TopologyGraphics[ Append[Take[#, 2], 0]&/@ top -> {{}} ]
-
-
 VGraphics[ _[e_, c_:0][n_] ] := VertexGraphics[c][ Vertex[e][n] ]
-
 PGraphics[ _[from_, to_, 0, ___], height_, labelpos_ ] :=
   PropagatorGraphics[Straight][from, to, height, labelpos]
-
 PGraphics[ _[type_][from_, to_, particle_, ___], height_, labelpos_ ] :=
   PropagatorGraphics[
     PropagatorType[particle],
     TheLabel[particle, ResolveType[type]],
     PropagatorArrow[particle] ][from, to, height, labelpos]
-
-
-Format[ DiagramGraphics[h___][__] ] := SequenceForm["[", h, "]"]
-
-Format[ FeynArtsGraphics[h___][l__List] ] :=
+format1[ DiagramGraphics[h___][__] ] := SequenceForm["[", h, "]"]
+format1[ FeynArtsGraphics[h___][l__List] ] :=
   FeynArtsGraphics[h]@@ MatrixForm/@ {l}
-
-
 SetOptions[OpenWrite, CharacterEncoding -> {}]
-
 Unprotect[Show, Display, Export]
-
 Show[ g:FeynArtsGraphics[___][___] ] := Show/@ Render[g]
-
 Display[ chan_, g:FeynArtsGraphics[___][___], format___String,
   opt:P$Options ] :=
 Block[ {rg},
@@ -237,9 +181,7 @@ Block[ {rg},
   MapThread[Display[##, format, opt]&,
     {FilePerSheet[chan, Length[rg]], rg}]
 ]
-
 Display[ chan_, s_String, ___ ] := (WriteString[chan, s]; Close[chan])
-
 Export[ chan_, g:FeynArtsGraphics[___][___], format___String,
   opt:P$Options ] :=
 Block[ {rg},
@@ -249,45 +191,29 @@ Block[ {rg},
   MapThread[Export[##, format, opt]&,
     {FilePerSheet[chan, Length[rg]], rg}]
 ]
-
 Export[ chan_, s_String, ___ ] := (WriteString[chan, s]; Close[chan])
-
 	(* we have to play some tricks to get our definitions
 	   for Export before Mma's ones *)
 DownValues[Export] =
   Sort[DownValues[Export], !FreeQ[#1, chan] && FreeQ[#2, chan] &]
-
 Protect[Show, Display, Export]
-
-
 InferFormat[ _, format_ ] = format
-
 InferFormat[ file_String ] := "PS" /; StringMatchQ[file, "*.ps"]
-
 InferFormat[ file_String ] := "EPS" /; StringMatchQ[file, "*.eps"]
-
 InferFormat[ file_String ] := "TeX" /; StringMatchQ[file, "*.tex"]
-
 InferFormat[ _ ] = Sequence[]
-
-
 Options[Render] = {ImageSize -> Automatic}
-
 getsize[ opt___, def_ ] :=
   If[NumberQ[#], {#, #}, #]& @
     Round[ImageSize /. ActualOptions[Render, opt] /. Automatic -> def]
-
 prologue := prologue =
   ReadList[ToFileName[$FeynArtsProgramDir, "FeynArts.pro"],
     Record, RecordSeparators -> ""][[1]]
-
 epsf = ""
-
 Render[ g:FeynArtsGraphics[___][___], "EPS", opt___Rule ] :=
 Block[ {PaperSize = imgsize, epsf = " EPSF-3.0"},
   Flatten[ Render[Head[g][#], "PS", opt]&/@ List@@ g ]
 ]
-
 Render[ g:FeynArtsGraphics[___][___], "PS", opt___Rule ] :=
 Block[ {imgsize = getsize[opt, DefaultImageSize], bbox,
 None = 0, Forward = 1, Backward = -1},
@@ -306,24 +232,18 @@ None = 0, Forward = 1, Backward = -1},
 end\n\
 %%EOF\n" ] }
 ]
-
 Render[ g:FeynArtsGraphics[___][___], "TeX", opt___Rule ] :=
 Block[ {imgsize = getsize[opt, DefaultImageSize],
 None = 0, Forward = 1, Backward = -1},
   { "\\unitlength=1bp%\n\n" <> TeXRender[Head[g]/@ List@@ g] }
 ]
-
 Render[ g:FeynArtsGraphics[___][___], ___String, opt___Rule ] :=
 Block[ {imgsize = getsize[opt, {288, 288}],
 None = 0, Forward = 1, Backward = -1},
   MmaRender[Head[g]/@ List@@ g]
 ]
-
-
 FilePerSheet[ file_, 1 ] := {file}
-
 FilePerSheet[ file:{__}, n_ ] := Thread[FilePerSheet[#, n]&/@ file]
-
 FilePerSheet[ file_String, n_ ] :=
 Block[ {p, pre, post},
   p = StringPosition[file, "."];
@@ -333,61 +253,38 @@ Block[ {p, pre, post},
     post = StringDrop[file, p] ];
   Array[pre <> ToString[#] <> post &, n]
 ] /; file =!= "stdout"
-
 FilePerSheet[ file_, n_ ] := Table[file, {n}]
-
-
 PSString[ s_String ] = s
-
 PSString[ RGBColor[r_, g_, b_, ___] ] :=
   ToString[r] <> " " <> ToString[g] <> " " <> ToString[b] <>
   " setrgbcolor "
-
 PSString[ CMYKColor[c_, m_, y_, k_, ___] ] :=
   ToString[c] <> " " <> ToString[m] <> " " <> ToString[y] <>
   " " <> ToString[k] <> " setcmykcolor "
-
 PSString[ Hue[h_, s_:1, b_:1, ___] ] :=
   ToString[h] <> " " <> ToString[s] <> " " <> ToString[b] <>
   " sethsbcolor "
-
 PSString[ GrayLevel[g_, ___] ] := ToString[g] <> " setgray "
-
 PSString[ Thickness[t_] ] := ToString[t DiagramSize] <> " setlinewidth "
-
 PSString[ s_ ] := ToString[s] <> " " /; Head[s] =!= List
-
 PSString[ s__ ] := StringJoin[PSString/@ Flatten[{s}]]
-
-
 TeXString[ {x_, y_} ] := "(" <> ToString[x] <> "," <> ToString[y] <> ")"
-
 TeXString[ s_ ] := ToString[s]
-
 TeXString[ s__ ] := StringJoin[TeXString/@ {s}]
-
-
 Attributes[ PSRender ] = Attributes[ TeXRender ] =
   Attributes[ MmaRender ] = {Listable}
-
-
 PSRender[ FeynArtsGraphics[h___][sheet_] ] :=
 Block[ {rows, cols, g},
   {rows, cols} = Dimensions[sheet];
   g = PSRender[{Title[h], sheet}];
   PSString[cols, rows, "Layout\n" <> g]
 ]
-
 Attributes[ TeXJoin ] = {Flat, OneIdentity}
-
 TeXJoin[ n_Integer ] := ToString[n]
-
 TeXJoin[ s1_String, s2_String ] := s1 <> "\\quad " <> s2
-
 TeXRender[ FeynArtsGraphics[in_ -> out_][sheet_] ] :=
   TeXRender[
     FeynArtsGraphics[TeXJoin@@ Flatten[{in, "\\to", out}]][sheet] ]
-
 TeXRender[ FeynArtsGraphics[h___][sheet_] ] :=
 Block[ {rows, cols, g},
   {rows, cols} = Dimensions[sheet];
@@ -395,7 +292,6 @@ Block[ {rows, cols, g},
   TeXString["\\begin{feynartspicture}", imgsize, {cols, rows}, "\n" <>
     g <> "\\end{feynartspicture}\n\n"]
 ]
-
 MmaRender[ FeynArtsGraphics[h___][sheet_] ] :=
 Block[ {rows, cols, fsize, g, title,
 (* magnify the labels a bit for screen viewing: *)
@@ -408,35 +304,22 @@ LabelFontSize = 1.26 LabelFontSize},
     PlotRange -> {{0, cols}, {0, rows}} DiagramSize,
     AspectRatio -> rows/cols]
 ]
-
-
 DiagramBox[ Null, _ ] = {}
-
 DiagramBox[ g_, {yoff_, xoff_} ] := Inset[ MmaRender[g],
   {xoff - 1, rows - yoff} DiagramSize, {0, 0}, {1, 1} DiagramSize ]
-
 If[ $VersionNumber < 6,
   Inset[obj_, pos_, _, size_] := Rectangle[pos, pos + size, obj]
 ]
-
-
 Title[ ] = {}
-
 Title[ t_ ] := (
   rows += .3;
   LabelText[t, {.5 cols, rows - .12} DiagramSize, {0, 0}, 1.2, 0] )
-
-
 PSRender[ DiagramGraphics[h___][pv__] ] :=
   "\n(" <> h <> ") Diagram\n" <> Transpose[PSRender[{pv}]]
-
 PSRender[ Null ] = "\n() Diagram\n"
-
 TeXRender[ DiagramGraphics[h___][pv__] ] :=
   "\n\\FADiagram{" <> h <> "}\n" <> Transpose[TeXRender[{pv}]]
-
 TeXRender[ Null ] = "\n\\FADiagram{}\n"
-
 MmaRender[ DiagramGraphics[h___][pv__] ] :=
 Block[ {g = Transpose[MmaRender[{pv}]]},
   Graphics[
@@ -448,58 +331,42 @@ Block[ {g = Transpose[MmaRender[{pv}]]},
     PlotRange -> {{0, DiagramSize}, {0, DiagramSize}} - DiagramBorder,
     AspectRatio -> 1 ]
 ]
-
 DiagLabel[ ] = {}
-
 DiagLabel[ t_ ] :=
   MmaRender[ LabelText[t, {.5 DiagramCanvas, -.5}, {0, -1}, .8] ]
-
-
 PSRender[ VertexGraphics[cto_][xy_] ] :=
   {{}, PSString[xy, cto, "Vert\n"]}
-
 TeXRender[ VertexGraphics[cto_][xy_] ] :=
   {{}, TeXString["\\FAVert", xy, "{", cto, "}\n"]}
-
 MmaRender[ VertexGraphics[0][xy_] ] := {{}, Point[xy]}
-
 MmaRender[ VertexGraphics[c_?Negative][xy_] ] := {{},
   { scope[ GrayLevel[Max[0, 1.1 + .3 c]], Disk[xy, CrossWidth] ],
     Circle[xy, CrossWidth] }}
-
 MmaRender[ VertexGraphics[c_][xy_] ] := {{},
   { scope[ CounterThickness,
       Line[{xy - .5 CrossWidth, xy + .5 CrossWidth}],
       Line[{xy - {.5, -.5} CrossWidth, xy + {.5, -.5} CrossWidth}] ],
     Array[Circle[xy, (.25 # + .8) CrossWidth]&, c - 1] }}
-
-
 PSRender[ PropagatorGraphics[type_, label_:0, arrow_:0][
   from_, to_, height_, labelpos_:0 ] ] :=
 Block[ {dir, ommc, cs, ctr, rad, mid, dphi, line},
   line = PSString["{ ", type, "} ", arrow, height, from, to, "Prop\n"];
-
   If[ label =!= 0,
     CalcPropData[from, to, height];
     line = line <> PSRender[PropLabel[label, labelpos, arrow, type]] ];
-
   {line, {}}
 ]
-
 TeXRender[ PropagatorGraphics[type_, label_:0, arrow_:0][
   from_, to_, height_, labelpos_:0 ] ] :=
 Block[ {dir, ommc, cs, ctr, rad, mid, dphi, line},
   line = TeXString["\\FAProp", from, to,
     If[ NumberQ[height], {height, ""}, height],
     "{" <> StringDrop[PSString[type], -1] <> "}{", arrow, "}\n"];
-
   If[ label =!= 0,
     CalcPropData[from, to, height];
     line = line <> TeXRender[PropLabel[label, labelpos, arrow, type]] ];
-
   {line, {}}
 ]
-
 MmaRender[ PropagatorGraphics[type_, label_:0, arrow_:0][
   from_, to_, height_, labelpos_:0 ] ] :=
 Block[ {dir, ommc, cs, ctr, rad, mid, dphi, line, phi, damping, t, h, v},
@@ -513,19 +380,14 @@ Block[ {dir, ommc, cs, ctr, rad, mid, dphi, line, phi, damping, t, h, v},
   h = Position[t, Straight | ScalarDash | GhostDash | Sine | Cycles, 1];
   dphi *= 2./Length[h];
   line = scope[MapAt[HalfLine[#, phi += dphi, dphi]&, t, h]];
-
   If[ arrow =!= 0,
     h = .5 arrow ArrowLength {Cos[dir], Sin[dir]};
     v = ArrowHeight cs;
     line = {line, Polygon[{mid + h, mid - h + v, mid - h - v}]} ];
-
   If[ label =!= 0,
     line = {line, MmaRender[PropLabel[label, labelpos, arrow, type]]} ];
-
   {line, {}}
 ]
-
-
 (* CalcPropData computes the data necessary for actual drawing:
    dir  -- the direction along the propagator
    ommc -- the direction of the perpendicular bisector
@@ -534,7 +396,6 @@ Block[ {dir, ommc, cs, ctr, rad, mid, dphi, line, phi, damping, t, h, v},
    mid  -- the position on the middle of the prop
            (the blue square in the topology editor)
    dphi -- half the opening angle *)
-
 CalcPropData[ from_, _, xy_List ] := (
   mid = xy;
   ctr = .5 (from + mid);
@@ -544,7 +405,6 @@ CalcPropData[ from_, _, xy_List ] := (
   cs = {Cos[ommc], Sin[ommc]};
   dphi = NPi
 )
-
 CalcPropData[ from_, to_, height_ ] :=
 Block[ {lab, h},
   lab = .5 Distance[from, to];
@@ -565,8 +425,6 @@ Block[ {lab, h},
   ];
   ctr -= h Sqrt[rad^2 - lab^2] cs
 ]
-
-
 HalfLine[ Sine, phi_, dphi_ ] :=
 Block[ {arc, w, n},
   arc = rad Abs[dphi];
@@ -576,13 +434,9 @@ Block[ {arc, w, n},
       ctr + (rad - damping[arc] SineAmp Sin[n w]) {Cos[arc], Sin[arc]},
       {n, 0, 1, 1./Floor[NPoints arc]} ] ]
 ]
-
 rshift = CyclesAmp - SineAmp
-
 phadj = ArcCos[rshift/CyclesAmp]
-
 sphadj = Sin[phadj]
-
 HalfLine[ Cycles, phi_, dphi_ ] :=
 Block[ {arc, w, n, phamp},
   arc = rad Abs[dphi];
@@ -595,20 +449,15 @@ Block[ {arc, w, n, phamp},
           phi - n dphi - phamp (Sin[arc] - (2 n - 1) sphadj)]],
       {n, 0, 1, 1./Floor[2 NPoints arc]} ] ]
 ]
-
 HalfLine[ Straight, phi_, dphi_ ] :=
   If[ rad < 20000,
     Circle[ctr, rad, Sort[{phi - dphi, phi}]],
     Line[{ ctr + rad {Cos[phi - dphi], Sin[phi - dphi]},
            ctr + rad {Cos[phi], Sin[phi]} }] ]
-
 HalfLine[ ScalarDash, phi_, dphi_ ] :=
   scope[ ScalarDashing, HalfLine[Straight, phi, dphi] ]
-
 HalfLine[ GhostDash, phi_, dphi_ ] :=
   scope[ GhostDashing, HalfLine[Straight, phi, dphi] ]
-
-
 PropLabel[ label_, labelpos_, arrow_, type_ ] :=
 Block[ {rad, phi, s},
   {rad, phi} =
@@ -626,33 +475,23 @@ Block[ {rad, phi, s},
     mid + rad {Cos[phi], Sin[phi]} + .24 LabelFontSize cs,
     cs, 1, dir ]
 ]
-
-
 LabelText[ in_ -> out_, pos_, align_, size_, dir_ ] :=
 Block[ {t, l, cs = {Cos[dir], Sin[dir]}},
   t = Flatten[{in, "\\to", out}];
   l = .5 (Length[t] + 1);
   MapIndexed[LabelText[#1, pos + 4.5 (#2[[1]] - l) cs, align, size]&, t]
 ]
-
 LabelText[ t_List, pos_, align_, size_, dir_ ] :=
 Block[ {l = .5 (Length[t] + 1), cs = {Cos[dir], Sin[dir]}},
   MapIndexed[LabelText[#1, pos + 2 (#2[[1]] - l) cs, align, size]&, t]
 ]
-
 PSRender[ LabelText[t_, pos_, align_, size_, ___] ] :=
   PSString["{ ", MapIndexed[PSChar, Flatten[{ToPS[t]}]], "} ",
     pos, align, size, "Label\n"]
-
 PSChar[ _[], _ ] = {}
-
 PSChar[ _[c_], {n_} ] := {"$(", c, psops[[n]]}
-
 PSChar[ c_, {n_} ] := {"(", c, psops[[n]]}
-
 psops = {")# ", ")_ ", ")^ ", ")~ "}
-
-
 TeXRender[ LabelText[t_, pos_, align_, size_, ___] ] :=
 Block[ {ComposedChar = TeXComposedChar},
   TeXString[
@@ -660,11 +499,9 @@ Block[ {ComposedChar = TeXComposedChar},
     Which[size > 1, "\\large ", size < 1, "\\small ", True, ""] <>
     "$", t, "$}\n" ]
 ]
-
 texalign = {{"bl", "l", "tl"},
             {"b",  "",  "t"},
             {"br", "r", "tr"}}
-
 TeXComposedChar[ t_, sub_:Null, super_:Null, over_:Null ] :=
 Block[ {tex = t},
   If[ sub =!= Null, tex = tex <> "_" <> ToString[sub] ];
@@ -672,12 +509,9 @@ Block[ {tex = t},
   If[ over =!= Null, tex = ToString[over] <> " " <> tex ];
   tex
 ]
-
 If[ $Notebooks,
-
 MmaRender[ LabelText[t_, r__] ] :=
   NotebookChar[Flatten[{ToUnicode[t]}], r];
-
 NotebookChar[ {t_, sub_:" ", super_:" ", over_:" "},
   pos_, align_, size_, ___ ] :=
 Block[ {label = t},
@@ -691,46 +525,32 @@ Block[ {label = t},
       label = SuperscriptBox[label, super]
   ];
   Text[
-    StyleForm[DisplayForm[label], FontFamily -> LabelFont,
+    StyleForm[If[res=True;label//.a_String:>(res=res&&SyntaxQ[a]);res, TraditionalForm[ToExpression[label]/.Null->""],DisplayForm[label]], FontFamily->LabelFont,
       FontSize -> size fsize],
     pos, align ]
 ],
-
 (* else $Notebooks *)
-
 MmaRender[ LabelText[t_, r__] ] :=
   MapIndexed[ KernelChar[##, r]&, Flatten[{ToPS[t]}] ];
-
 KernelChar[ _[], __ ] = {};
-
 KernelChar[ t_, {n_}, pos_, align_, size_, ___ ] :=
 Block[ {newpos, newalign, fscale = sizes[[n]] size},
   {newpos, newalign} = If[ size < 1, {pos, align},
     {pos + .24 size LabelFontSize (palign[[n]] - align), talign[[n]]} ];
   Text[ MmaChar[t], newpos, newalign ]
 ];
-
-MmaChar[ _[c_] ] := FontForm[c, {"Symbol", fscale fsize}];
-
+(*MmaChar[_[c_]]:=FontForm[c,{"Symbol",fscale fsize}];*)
 MmaChar[ c_ ] := FontForm[c, {LabelFont, fscale fsize}];
-
 sizes = {1, .667, .667, 1};
-
 palign = {{0, 0}, {1.2, -.9}, {1.2, .7}, {0, 1.2}};
-
 talign = {{0, 0}, {-1, 0}, {-1, 0}, {0, -1}};
-
 ] (* endif $Notebooks *)
-
-
 FindFlip[ h_, top_, rulz_ ] :=
 Block[ {ntop = top /. rulz, ord, shapedata},
   ord = TopologyOrdering[ntop];
   FlipShape[h, ntop, ord,
     GetShape[TopologyCode[ ord[[1]] ]] /. Reverse/@ rulz]
 ]
-
-
 FlipShape[ h_, top_, _[ntop_, map_], {vert_, prop_, labels_} ] :=
 Block[ {ord = Ordering[Abs[map]], vord, vmap},
   vord = Flatten[(4 Abs[#] - 1 + Sign[#] {-1, 1})/2&/@ map];
@@ -741,64 +561,38 @@ Block[ {ord = Ordering[Abs[map]], vord, vmap},
       Sequence@@ Transpose[MapThread[h[23],
         {prop[[ord]], labels[[ord]], map}]] } ]
 ]
-
-
 TopBottom[1][ v_ -> {x_, y_} ] := v -> {x, DiagramCanvas - y}
-
 TopBottom[23][ {x_, y_}, {r_, fi_}, _ ] := {{x, DiagramCanvas - y}, {r, -fi}}
-
 TopBottom[23][ {x_, y_}, l_, _ ] := {{x, DiagramCanvas - y}, l}
-
 TopBottom[23][ h_, {r_, fi_}, s_ ] := {-Sign[s] h, {r, -Sign[s] fi}} /; h != 0
-
 TopBottom[23][ h_, l_, s_ ] := {-Sign[s] h, l} /; h != 0
-
 TopBottom[23][ _, {r_, fi_}, s_ ] := {0, {r, If[s > 0, Pi - fi, -fi]}}
-
 TopBottom[23][ _, l_, s_ ] := {0, -Sign[s] l}
-
-
 LeftRight[1][ v_ -> {x_, y_} ] := v -> {DiagramCanvas - x, y}
-
 LeftRight[23][ {x_, y_}, {r_, fi_}, _ ] := {{DiagramCanvas - x, y}, {r, -fi}}
-
 LeftRight[23][ {x_, y_}, l_, _ ] := {{DiagramCanvas - x, y}, l}
-
 LeftRight[23][ h_, {r_, fi_}, s_ ] := {-Sign[s] h, {r, -fi}} /; h != 0
-
 LeftRight[23][ h_, l_, s_ ] := {-Sign[s] h, l} /; h != 0
-
 LeftRight[23][ _, {r_, fi_}, s_ ] := {0, {r, If[s > 0, Pi - fi, -fi]}}
-
 LeftRight[23][ _, l_, s_ ] := {0, -Sign[s] l}
-
-
 AutoShape[ top_ ] :=
 Block[ {in, out, vert, shapedata, props, ext, l, tree, mesh, mesh2,
 vars, tadbr, tad, min, ok, c, ct, pt, shrink = {}, rev = {}, loops = {}},
-
 	(* before embarking on any serious autoshaping, check if we know
 	   how to paint the vertical or horizontal mirror image of top *)
   in = Sort[Cases[top, _[Incoming][v_, _] :> v]];
   out = Sort[Cases[top, _[Outgoing][v_, _] :> v]];
   vert = Join[out, in];
-
   FAPrint[1, "shaping topology ", TopologyCode[top]];
-
   FindFlip[ TopBottom, top, Thread[vert -> Reverse[Join[in, out]]] ];
-
   FindFlip[ LeftRight, top, Flatten[{Thread[vert -> Sort[vert]],
     Incoming -> Outgoing, Outgoing -> Incoming}] ];
-
   FAPrint[2, "  autoshaping"];
-
   props[_] = {};
   top /. Propagator -> pr;
   loops = Union[loops];
-
   Off[FindMinimum::fmmp, FindMinimum::fmcv, FindMinimum::precw,
     FindMinimum::fmgz, FindMinimum::sdprec, FindMinimum::lstol];
-
 	(* a) fix the incoming and outgoing propagators on the left and
 	      right side, respectively *)
   shapedata = Join[
@@ -810,7 +604,6 @@ vars, tadbr, tad, min, ok, c, ct, pt, shrink = {}, rev = {}, loops = {}},
     MapIndexed[
       #1[[1]] -> {20, 20 - Round[(#2[[1]] - .5)/l]}&,
       props[Outgoing] ] ];
-
 	(* b) shrink loops to 1 point which is the center of an imaginary
 	      circle on which the external points of the loop lie *)
   vert = Flatten[props[Tree]];
@@ -822,7 +615,6 @@ vars, tadbr, tad, min, ok, c, ct, pt, shrink = {}, rev = {}, loops = {}},
       #1 /. c )&,
     props[Tree], loops ];
   shrink = Flatten[shrink];
-
 	(* c) cut tadpole-like parts and minimize the length of the
 	      remaining mesh of propagators *)
   mesh2 = Leaves@@ twig@@@ (tree /. shapedata) /. twig -> List;
@@ -858,7 +650,6 @@ vars, tadbr, tad, min, ok, c, ct, pt, shrink = {}, rev = {}, loops = {}},
     (l = (#[[-1]] - (c = #[[1]]))/(Length[#] - 1);
      MapIndexed[#1 -> c + l #2[[1]] &, Take[#, {2, -2}]])&/@
       (Select[mesh, Length[#] > 2 &] /. shapedata)} ];
-
 	(* d) minimizing the straight distance of a tadpole to its
 	      nearest vertex v would make the tadpole stick to v.
 	      Therefore, the tadpole is given polar coordinates with
@@ -868,7 +659,6 @@ vars, tadbr, tad, min, ok, c, ct, pt, shrink = {}, rev = {}, loops = {}},
     leaf[br__] :> Sequence@@ Cases[{br}, branch[__]] /. shapedata;
   While[ Length[ tad = Cases[mesh2, branch[{_, _}, __]] ] =!= 0,
     mesh2 = Fold[FixTad, mesh2, tad] ];
-
 	(* e) for each loop, distribute the external points of the loop
 	      at the middle of the line from the center to the external
 	      vertex and distribute the remaining points of the loop
@@ -881,15 +671,13 @@ vars, tadbr, tad, min, ok, c, ct, pt, shrink = {}, rev = {}, loops = {}},
         SetMiddle[#, rul]&/@ vert; c = rul[[2]] ];
       SetLoop[props[ rul[[1, 1]] ] /. shapedata, c] ],
     Select[shapedata, !FreeQ[#, center]&] ];
-
 	(* f) last resort: randomize any remaining vertex *)
   shapedata = Join[ MapAt[Inside, #, 2]&/@ shapedata,
     (# -> {RandInt, RandInt})&/@
       Union[Cases[top /. shapedata, Vertex[__][_], Infinity]] ];
-
 	(* g) give tadpoles and identical propagators curvature so that
 	      they do not fall on top of each other *)
-  pt[ _[Loop[n_]][v_, v_], _ ] :=
+  pt[ _[HighEnergyPhysics`FeynCalc`Loop`Loop[n_]][v_, v_], _ ] :=
     center[ Length[ext[n]] ][n] /. shapedata /. center[_][_] :>
       Inside[ (v /. shapedata) + 4 Through[{Cos, Sin}[2. NPi Random[]]] ];
   pt[ _, 0 ] = 0;
@@ -897,62 +685,38 @@ vars, tadbr, tad, min, ok, c, ct, pt, shrink = {}, rev = {}, loops = {}},
     pt[ p, n_ ] = .8 n/c;
     ct[ p ] = c
   ];
-
   On[FindMinimum::fmmp, FindMinimum::fmcv, FindMinimum::precw,
     FindMinimum::fmgz, FindMinimum::sdprec, FindMinimum::lstol];
-
   { Select[shapedata, FreeQ[#, center]&],
     pt[#, ct[#]--]&/@ List@@ top,
     Table[1, {Length[top]}] }
 ]
-
-
-pr[ Loop[l_] ][ from_, to_, ___ ] := (
+pr[ HighEnergyPhysics`FeynCalc`Loop`Loop[l_] ][ from_, to_, ___ ] := (
   AppendTo[loops, l];
   AppendTo[props[l], {from, to}] )
-
 pr[ type_ ][ from_, to_, ___ ] := (
   AppendTo[props[Tree], {from, to}];
   AppendTo[props[type], {from, to}] )
-
-
 Attributes[ twig ] = {Orderless}
-
 twig[ a:_[1, ___][_], b_ ] := branch[b, a]
-
 Attributes[ Leaves ] = {Orderless, Flat}
-
 Leaves[ branch[a_, b__], twig[a:_[2, ___][_], c_] ] :=
   Leaves[branch[c, a, b]]
-
 Leaves[ br:branch[a_, __].., tw:twig[a_, _].. ] :=
   Switch[ Length[{tw}],
     1, Leaves[branch[ Sequence@@ DeleteCases[tw, a], a, br ]],
     2, Leaves[leaf[br, a], tw],
     _, Leaves[leaf[br], tw]
   ]
-
 cutbranch[ vert__, br___branch ] :=
   Sequence[ br, Drop[{vert}, {2, -2}] ]
-
-
 Inside[ xy_ ] := Max[Min[#, 20], 0]&/@ N[xy]
-
 RandInt := Plus@@ Table[Random[Integer, 9], {2}] + 1
-
-
 Distance[ p1_, p2_ ] := Block[ {d = p2 - p1}, Sqrt[d . d] ]
-
 Distance2[ p1_, ___, p2_ ] := Block[ {d = p2 - p1}, d . d ]
-
-Orientation[ p1_, p2_ ] := N[ArcTan@@ (p2 - p1)] /; p1 != p2
-
+Orientation[ p1_, p2_ ] := N[(If[{##}=={0,0},0,ArcTan[##]]&)@@ (p2 - p1)] /; p1 != p2
 Orientation[ __ ] = 0
-
-
 CartesianVar[ n_ ] := CartesianVar[n] = {Unique["X"], Unique["Y"]}
-
-
 FixTad[ mesh_, br_ ] :=
 Block[ {stem, root, c, phi, dphi, vert, min, dist},
   stem = DeleteCases[List@@ br, branch[__]];
@@ -976,8 +740,6 @@ Block[ {stem, root, c, phi, dphi, vert, min, dist},
   shapedata = Join[shapedata, vert];
   mesh /. br -> cutbranch@@ br /. vert
 ]
-
-
 SetLoop[ loop_, ctr_ ] :=
 Block[ {vert, vars, rad, angle, off, min, c = 0},
   vert = Union[ Cases[loop, _[__][_], {2}] ];
@@ -1002,8 +764,6 @@ Block[ {vert, vars, rad, angle, off, min, c = 0},
     ]
   ];
 ]
-
-
 SetMiddle[ vert_, ctr_ -> xy_ ] :=
 Block[ {ex, mid},
   ex = DeleteCases[ Flatten[Select[props[Tree], !FreeQ[#, vert]&]], vert ];
@@ -1016,8 +776,6 @@ Block[ {ex, mid},
     AppendTo[shapedata, vert -> .6 xy + .4 mid]
   ]
 ]
-
-
 SetTadpole[ vert_, ctr_ -> xy_ ] :=
 Block[ {adj, max, new, a1, a2},
   adj = Select[tree, !FreeQ[#, ctr]&] /. ok;
@@ -1036,81 +794,52 @@ Block[ {adj, max, new, a1, a2},
   AppendTo[shapedata, ctr -> max];
   max
 ]
-
-
 vcode = Characters["\
 abcdefghijklmnopqrstuvwxyz\
 ABCDEFGHIJKLMNOPQRSTUVWXYZ\
 0987654321"]
-
 pcode[ _[Incoming | External][c__] ] := {{c}, {}, {}}
-
 pcode[ _[Outgoing][c__] ] := {{}, {c}, {}}
-
 pcode[ _[c__] ] := {{}, {}, {c}}
-
 TopologyCode[ top:P$Topology ] :=
   StringJoin/@ Transpose[pcode/@ Apply[vcode[[#]]&, List@@ top, {2}]] /.
     "" -> "0"
-
-
 MkDir[ dir_String ] := dir /; FileType[dir] === Directory
-
 MkDir[ dir_String ] := Check[CreateDirectory[dir], Abort[]]
-
 MkDir[ dirs__String ] := Fold[MkDir[ToFileName[##]]&, {}, {dirs}]
-
-
 Attributes[ GetShape ] = {HoldRest}
-
 GetShape[ {topcode__}, ___ ] :=
 Block[ {shapedata = ShapeData[topcode]},
   shapedata /; Head[shapedata] === List
 ]
-
 GetShape[ {ext__, int_}, ___ ] :=
 Block[ {file = ToFileName[{$ShapeDataDir, ext}, int <> ".m"]},
   (ShapeData[ext, int] = Get[file]) /; FileType[file] === File
 ]
-
 GetShape[ {topcode__}, alt_ ] := ShapeData[topcode] = alt
-
-
 PutShape[ shapedata_, {ext__, int_} ] :=
   Put[ShapeData[ext, int] = shapedata,
     ToFileName[MkDir[$ShapeDataDir, ext], int <> ".m"]]
-
-
 ToJava[ p__, n_?NumberQ ] := ToJava[p, {n DefaultRadius, 0.}]
-
 ToJava[ _[from_, from_], {xc_, yc_}, {xl_, yl_} ] :=
   {-from, xc, yc, xl, yl}
-
 ToJava[ _[from_, to_], height_, {xl_, yl_} ] :=
   {from, to, height, xl, yl}
-
-
 (* call the topology editor *)
-
 Shape::wait =
 "Starting Java and the topology editor.  This may take a moment."
-
 Shape::notopedit =
 "Could not load the topology editor.  Make sure you have J/Link and Java
 installed."
-
 Shape::javaerror =
 "Could not open a topology-editor window."
-
 Shape[ tops:TopologyList[___][___] | TopologyList[___] ] :=
 Block[ {remaining = Length[tops]},
   MapIndexed[
     (--remaining; FAPrint[ 2, "> Top. ", #2[[1]] ]; Shape[#1])&,
     List@@ tops ]
 ]
-
 Shape[ top:P$Topology -> _ ] := Shape[top]
-
 Shape[ top:P$Topology, auto_:0 ] :=
 Block[ {edittop, topcode, shapedata, arg1, arg2, exitcode},
   edittop = Take[#, 2]&/@ Topology@@ top /.
@@ -1119,7 +848,6 @@ Block[ {edittop, topcode, shapedata, arg1, arg2, exitcode},
   res = auto;
   shapedata = GetShape[topcode, --res; Catch[AutoShape[edittop]]];
   If[ res > 0, Return[shapedata] ];
-
   If[ editorclass === False,
     Message[Shape::wait];
     Needs["JLink`"];
@@ -1130,21 +858,18 @@ Block[ {edittop, topcode, shapedata, arg1, arg2, exitcode},
     If[ Head[editorclass] =!= JLink`JavaClass, Message[Shape::notopedit] ]
   ];
   If[ Head[editorclass] =!= JLink`JavaClass, Return[shapedata] ];
-
   If[ !JLink`JavaObjectQ[editor],
     editor = JLink`JavaNew[editorclass];
     If[ !JLink`JavaObjectQ[editor],
       Message[Shape::javaerror];
       Return[shapedata] ];
   ];
-
   arg1 = Last/@ shapedata[[1]];
   arg2 = MapThread[ ToJava,
     { List@@ edittop /. MapIndexed[ First/@ Rule[##]&, shapedata[[1]] ],
       shapedata[[2]],
       shapedata[[3]] } ];
   editor@putShapeData[ N[Flatten[arg1]], N[Flatten[arg2]] ];
-
   exitcode = JLink`DoModal[];
   If[ exitcode === 0,
     shapedata = MapAt[
@@ -1152,23 +877,16 @@ Block[ {edittop, topcode, shapedata, arg1, arg2, exitcode},
       editor@getShapeData[], 1 ];
     PutShape[shapedata, topcode]
   ];
-
   If[ remaining === 0 || exitcode === 2,
     editor@closeWindow[];
     JLink`ReleaseObject[editor];
     editor = False;
     If[ exitcode === 2, Abort[] ];
   ];
-
   shapedata
 ]
-
-
 editorclass = editor = False
-
 remaining = 0
-
-
 ToPS[ "\\alpha" ] = SymbolChar["a"];
 ToPS[ "\\beta" ] = SymbolChar["b"];
 ToPS[ "\\gamma" ] = SymbolChar["g"];
@@ -1259,7 +977,6 @@ ToPS[ "-" ] = SymbolChar["-"];
 ToPS[ Null ] = SymbolChar[];
 ToPS[ ComposedChar[t__] ] := ToPS/@ {t};
 ToPS[ c_ ] := ToString[c]
-
 ToUnicode[ "\\alpha" ] = "\[Alpha]";
 ToUnicode[ "\\beta" ] = "\[Beta]";
 ToUnicode[ "\\gamma" ] = "\[Gamma]";
@@ -1351,6 +1068,9 @@ ToUnicode[ "\\_" ] = "_";
 ToUnicode[ Null ] = " ";
 ToUnicode[ ComposedChar[t__] ] := ToUnicode/@ {t};
 ToUnicode[ c_ ] := ToString[c]
-
+(*Below are the codes for arrows used by Mathematica*)
+TeXToPS["\\leftrightarrow"]:=SymbolChar["\[LeftRightArrow]"];
+TeXToPS["\\leftarrow"]:=SymbolChar["\[LeftArrow]"];
+TeXToPS["\\rightarrow"]:=SmbolChar["\[RightArrow]"];
+TeXToPS["\\to"]:=SymbolChar["\[RightArrow]"];
 End[]
-
diff --git FeynArts-3.7/FeynArts/Initialize.m FeynArts-3.7/FeynArts/Initialize.m
index b2eb701..1f3b803 100644
--- FeynArts-3.7/FeynArts/Initialize.m
+++ FeynArts-3.7/FeynArts/Initialize.m
@@ -3,9 +3,7 @@
 		Functions for the initialization of models
 		last modified 2 Apr 12 th
 *)
-
 Begin["`Initialize`"]
-
 (* The functions defined for a certain model are:
 	F$AllGeneric:		all generic fields
 	F$AllClasses:		all classes of the model
@@ -28,105 +26,69 @@ Begin["`Initialize`"]
    InitializeModel also sets the functions that return certain
    properties of the fields like
 	AntiParticle, Indices, SelfConjugate, TheMass, TheLabel, etc.
-
    There is one restriction on entering the model file:
    the coupling definitions in the classes model file have to be made
    with classes couplings of the same ordering as in the generic
    coupling definition.
 *)
-
-
 Attributes[ FieldPoint ] = Attributes[ PermutationSymmetry ] = {Orderless}
-
-
 ToModelName[mod_] := str/@ Flatten[{mod}]
-
 str[ mod:_[___] ] := str/@ mod
-
 str[ mod_ ] := ToString[mod]
-
-
 indent = ""
-
 Attributes[ ReadModelFile ] = {HoldFirst}
-
 ReadModelFile[ args__ ][ ModelDebug[name_] ] :=
   ReadModelFile[args][name, True]
-
 ReadModelFile[ args__ ][ name_ ] :=
   ReadModelFile[args][name, $ModelDebug]
-
 ReadModelFile[ newitems_, type_, ext_ ][ name_, deb_ ] :=
 Block[ {$Path = $ModelPath, file},
   file = System`Private`FindFile[name <> ext];
   FAPrint[2, indent, "loading ", type, " model file ", file];
-
   (*Off[Syntax::newl, Syntax::com];*)
   Check[ Block[{indent = indent <> "  "}, Get[file]], Abort[] ];
   (*On[Syntax::newl, Syntax::com];*)
-
   DebugModel[newitems, name, deb];
   olditems = newitems;
-
   name
 ]
-
-
 Attributes[ DebugModel ] = {HoldFirst}
-
 DebugModel[ __, False ] = 0
-
 DebugModel[ newitems_, name_, True ] :=
   MapThread[ ReportChanges[name],
     {Block[newitems, ToString/@ newitems], newitems, olditems} ] /;
   olditems =!= 0
-
 DebugModel[ newitems_, name_, other_ ] :=
   DebugModel[newitems, name, MemberQ[ToString/@ Flatten[{other}], name]]
-
-
 ReportChanges[ _ ][ _, new_, new_ ] = True
-
 ReportChanges[ name_ ][ item_, new_, old_ ] := (
   {$ModelRemoved, $ModelChanged, $ModelAdded} =
     FindDiff[new, old, {}, {}];
-
   Print[];
-
   If[ Length[$ModelAdded] > 0,
     Print[name, " added the following ", Length[$ModelAdded],
       " items to ", item, ":"];
     Print[$ModelAdded //$ModelDebugForm] ];
-
   If[ Length[$ModelRemoved] > 0,
     Print[name, " removed the following ", Length[$ModelRemoved],
       " items from ", item, ":"];
     Print[$ModelRemoved //$ModelDebugForm] ];
-
   If[ Length[$ModelChanged] > 0,
     Print[name, " changed the following ", Length[$ModelChanged],
       " items in ", item, ":"];
     Print[$ModelChanged //$ModelDebugForm] ];
-
   False
 )
-
-
 FindDiff[ {c_, d___}, {a___, c_, b___}, diff_, add_ ] :=
   FindDiff[{d}, {a, b}, diff, add]
  
 FindDiff[ {c_ == x_, d___}, {a___, k_ == y_, b___}, diff_, add_ ] :=
   FindDiff[{d}, {a, b}, {diff, c}, add] /; ToClasses[c] === ToClasses[k]
-
 FindDiff[ {c_, d___}, old_, diff_, add_ ] :=
   FindDiff[{d}, old, diff, {add, c}]
-
 FindDiff[ {}, r__ ] := Replace[Flatten/@ {r}, x_ == _ -> x, {2}]
-
-
 General::genmiss =
 "Definition missing in generic model file."
-
 LoadGenericModel[ genmod_, ext_String:".gen" ] :=
 Block[ {olditems = 0},
   M$GenericPropagators := (
@@ -136,17 +98,13 @@ Block[ {olditems = 0},
     Message[M$GenericCouplings::genmiss];
     Abort[]; );
   M$FlippingRules = M$TruncationRules = M$LastGenericRules = {};
-
   ReadModelFile[
     {M$GenericPropagators, M$GenericCouplings,
       M$FlippingRules, M$TruncationRules, M$LastGenericRules},
     "generic", ext ]/@ ToModelName[genmod]
 ]
-
-
 General::modmiss =
 "Definition missing in classes model file."
-
 LoadModel[ mod_, ext_String:".mod" ] :=
 Block[ {olditems = 0},
   M$ClassesDescription := (
@@ -156,18 +114,13 @@ Block[ {olditems = 0},
     Message[M$CouplingMatrices::modmiss];
     Abort[]; );
   M$LastModelRules = {};
-
   ReadModelFile[
     {M$ClassesDescription, M$CouplingMatrices, M$LastModelRules},
     "classes", ext ]/@ ToModelName[mod]
 ]
-
-
 (* this is a workaround for a Mathematica bug in Put, known
    to Wolfram Support since Version 4 but still not fixed *)
-
 Attributes[ WriteDef ] = {Listable, HoldRest}
-
 WriteDef[ hh_, sym_, foo_ ] :=
 Block[ {list = foo[sym], sym},
   Scan[
@@ -176,9 +129,7 @@ Block[ {list = foo[sym], sym},
       WriteString[hh, "\n"] )&,
     Partition[list, 16, 16, 1, {}] ]
 ]
-
 Attributes[ WriteDefinitions ] = {HoldRest}
-
 WriteDefinitions[ file_, syms__ ] :=
 Block[ {hh},
   hh = OpenWrite[file];
@@ -186,121 +137,86 @@ Block[ {hh},
   WriteDef[hh, {syms}, OwnValues];
   Close[hh]
 ]
-
-
 Attributes[ DumpGenericModel ] = {HoldRest}
-
 DumpGenericModel[ genfile_String, other___ ] :=
   WriteDefinitions[ genfile,
     M$GenericPropagators, M$GenericCouplings,
     M$FlippingRules, M$TruncationRules, M$LastGenericRules,
     KinematicIndices, other ]
-
-
 Attributes[ DumpModel ] = {HoldRest}
-
 DumpModel[ modfile_String, other___ ] :=
   WriteDefinitions[ modfile,
     M$ClassesDescription, M$CouplingMatrices, 
     M$LastModelRules, IndexRange, ViolatesQ, RenConst, other ]
-
-
 Options[ InitializeModel ] = {
   GenericModel -> "Lorentz",
   Reinitialize -> True,
   GenericModelEdit :> Null,
   ModelEdit :> Null
 }
-
 InitializeModel::nonlin =
 "Non-linear term `` in ``."
-
 InitializeModel::unknown =
 "Unknown field ``."
-
 InitializeModel::norange =
 "Index `` has no IndexRange specification."
-
 InitializeModel::incomp1 =
 "Coupling definition in model file for `` is incompatible to generic \
 coupling structure.  Coupling is not a vector of length ``."
-
 InitializeModel::incomp2 =
 "Incompatible index structure in classes coupling ``.  \
 Field `` needs `` indices, not ``."
-
 InitializeModel::kinind =
 "Warning: Wrong number of kinematic indices in field ``."
-
 InitializeModel::nogeneric =
 "Warning: Classes coupling `` matches no generic coupling."
-
 InitializeModel::rhs1 =
 "R.h.s. of generic coupling `` has G-expressions inside the \
 kinematic vector."
-
 InitializeModel::rhs2 =
 "Generic coupling `` is not of the form \
 AnalyticalCoupling[__] == G[_][__] . {__}."
-
 InitializeModel::dup =
 "Duplicate components in ``."
-
 InitializeModel::badrestr =
 "Warning: `` is not a valid model restriction."
-
 InitializeModel::nosymb =
 "Cannot properly analyze the field specification ``.  Either the \
 overall format is wrong, or it contains symbols that were already \
 assigned values somewhere in your model file (most often \"i\" or \"j\").  \
 Please check your generic model file and try again."
-
 InitializeModel[ opt:P$Options ] := InitializeModel[{}, opt]
-
 InitializeModel[ model_, options:P$Options ] :=
 Block[ {reini, genmod, mod,
 opt = ActualOptions[InitializeModel, options]},
   reini = TrueQ[Reinitialize /. opt];
-
   genmod = ToModelName[GenericModel /. opt];
   If[ reini || genmod =!= $GenericModel,
     (InitGenericModel[GenericModelEdit] /. opt)[genmod] ];
-
   mod = ToModelName[model];
   If[ Length[mod] > 0 && (reini || mod =!= $Model),
     (InitModel[ModelEdit] /. opt)[mod] ];
-
   True
 ]
-
-
 $GenericModel = $Model = ""
-
-
 (* initializing a generic model: *)
-
 Attributes[ InitGenericModel ] = {HoldAll}
-
 InitGenericModel[ edit_ ][ genmod_ ] :=
 Block[ {savecp = $ContextPath},
 	(* no Global symbols allowed for these operations *)
   $ContextPath = DeleteCases[$ContextPath, "Global`"];
   $GenericModel = $Model = "";
-
   Clear[AnalyticalPropagator, AnalyticalCoupling, KinematicVector,
     PermutationSymmetry, PossibleFields, CheckFieldPoint, Combinations,
     Compatibles, MixingPartners, $FermionLines, $SparseCouplings];
   $ExcludedFPs = $ExcludedParticleFPs = {};
-
   FAPrint[2, ""];
   $GenericModel = LoadGenericModel[genmod];
   edit;
-
   ReferenceOrder[Generic] =
     Union[ ToGeneric[(List@@ #[[1]])&/@ M$GenericCouplings] ];
   FieldPointList[Generic] = FieldPoint@@@ ReferenceOrder[Generic];
   Scan[ BuildCombinations, Union[Length/@ ReferenceOrder[Generic]] ];
-
   F$Generic = Union[ ToGeneric[#[[1, 1]]&/@ M$GenericPropagators] ];
   If[ $SVMixing && !FreeQ[F$Generic, SV],
     FAPrint[2, "> $SVMixing is ON"];
@@ -315,7 +231,6 @@ Block[ {savecp = $ContextPath},
   F$AllGeneric = F$Generic;
   MixingPartners[ p_ ] = {p};
   Compatibles[ p_ ] = {p};
-
   (CheckFieldPoint[ FieldPoint[_][##] ] = True)&@@@
     FieldPointList[Generic];
 	(* CheckFieldPoint must yield True in cases where some part
@@ -323,24 +238,17 @@ Block[ {savecp = $ContextPath},
   CheckFieldPoint[ fp_ ] :=
     MemberQ[fp, 0] || !FreeQ[fp, Field] ||
       Length[Union[AtomQ/@ fp]] =!= 1;
-
   PossibleFields[_][ __ ] = {};
   SetPossibleFields[_, Table[0, {Length[#]}]&, FieldPointList[Generic]];
-
   SubValues[AnalyticalPropagator] =
     InitGenericPropagator@@@ M$GenericPropagators;
   SubValues[AnalyticalCoupling] =
     InitGenericCoupling@@@ M$GenericCouplings;
-
   $ContextPath = savecp;
   FAPrint[1, "generic model ", $GenericModel, " initialized"];
 ]
-
-
 InitGenericPropagator[ lhs_, rhs_ ] :=
   HoldPattern[Evaluate[PropFieldPattern/@ lhs]] :> PV[rhs]
-
-
 (* BuildCombinations generates all combinations of valence 
    configurations of a vertex with n legs, e.g.
 	Combinations[{f1_, f2_}, {h1_, h2_}] :=
@@ -351,7 +259,6 @@ InitGenericPropagator[ lhs_, rhs_ ] :=
    The first line is interpreted as: for the vertex FieldPoint[h1, f2] 
    where h1 is a `wildcard' (0 or a Generic field), f1 is a possible 
    field to insert. *)
-
 BuildCombinations[ n_ ] := 
 Block[ {f, h, i, v},
   f = Array[ToExpression["f" <> ToString[#]]&, n];
@@ -363,22 +270,15 @@ Block[ {f, h, i, v},
           { {h[[#]], FieldPoint@@ v}, f[[#]] }&/@ #)&/@ TupleList[n, i],
         {i, n} ], 2 ] }
 ]
-
-
 (* TupleList[n, m] returns all possible m-tuples that can be constructed 
    from an n-tuple *)
-
 TupleList[ n_, 1 ] := Array[List, n]
-
 TupleList[ n_, m_ ] := TupleList[n, m] =
   Flatten[
     Function[z, Flatten[{z, #}]&/@ Range[Last[z] + 1, n]]/@
       TupleList[n, m - 1],
     1 ]
-
-
 (* construct PossibleFields from the vertex lists: *) 
-
 SetPossibleFields[ cto_, func_, fp_ ] :=
 Block[ {id = Sequence[], pl = {}},
   Scan[
@@ -391,31 +291,24 @@ Block[ {id = Sequence[], pl = {}},
     Append[ Union[Flatten[
       Combinations[List@@ #, func[List@@ #]]&/@ fp, 1 ]], {0, 0} ] ]
 ]
-
-
 (* Transformation of Equal in the generic couplings to SetDelayed:
    lhs has to be changed to patterns, rhs is changed from
    G . {g1, g2, ...} to {G[g1], G[g2], ...} * {g1, g2, ...}.
    Both lhs and rhs get an additional argument, the counter-term order.
    Also, the function KinematicVector is defined which gives only the
    kinematic part of the coupling *)
-
 InitGenericCoupling[ lhs_, s_. g:G[_][__] ] :=
   InitGenericCoupling[ lhs, g . {s} ]
-
 InitGenericCoupling[ AnalyticalCoupling[f__],
     G[_][__] . kinvec_List ] :=
   (Message[InitializeModel::rhs1, ToGeneric[{f}]]; Seq[]) /;
   !FreeQ[kinvec, G]
-
 InitGenericCoupling[ AnalyticalCoupling[f__],
     G[n_][g__] . kinvec_List ] :=
 Block[ {lhs, cpl, kin, sic, kv, x, Global`cto},
   lhs = CoupFieldPattern/@ {f};
   Evaluate[cpl@@ lhs] = kinvec;
-
   (PermutationSymmetry[##] = n)&@@ ToGeneric[lhs];
-
 	(* put Mom and KI dummies in the fields on the rhs.  These dummies 
 	   will appear as part of the Lorentz term indexing of the G's. *)
   x = (sic = 0; # /. IndexSum :> (#1 /. (SumDummies/@ {##2})&))&/@
@@ -424,106 +317,63 @@ Block[ {lhs, cpl, kin, sic, kv, x, Global`cto},
   If[ Length[x] > Length[Union[x]],
     Message[InitializeModel::dup, kv] ];
   (# = x)&[kv];
-
   (HoldPattern[#1] :> #2)&[
     AnalyticalCoupling[Global`cto_]@@ lhs,
     PV[(G[n][Global`cto][g]/@ x) . kinvec] ]
 ]
-
 InitGenericCoupling[ AnalyticalCoupling[f__], _ ] :=
   (Message[InitializeModel::rhs2, ToGeneric[{f}]]; Seq[])
-
-
 SumDummies[ {i_, __} ] := i -> SI[++sic]
-
 SumDummies[ i_ ] := i -> SI[++sic]
-
-
 KinDummies[ s_. (f:P$Generic)[__, ki_List], {n_} ] :=
   s f[CI[n], Mom[n], Through[Take[KIs, Length[ki]][n]]]
-
 KinDummies[ s_. (f:P$Generic)[__], {n_} ] := s f[CI[n], Mom[n]]
-
-
 Off[RuleDelayed::rhs]
-
-
 (* Change field representation to patterns.  Coupling patterns include
    ___ so that they match also in mixing cases. *)
-
 PropFieldPattern[ fi_[i_Symbol, m_Symbol] ] := fi[i__, m_]
-
 PropFieldPattern[ fi_[i_Symbol, m_Symbol, ki:{__Symbol}] ] := 
   fi[i__, m_, patt/@ ki]
-
 PropFieldPattern[
   fi_[i_Symbol, m_Symbol, ki:({__Symbol} -> {__Symbol})] ] := 
   fi[i__, m_, Map[patt, ki, {2}]]
-
 PropFieldPattern[ s_Symbol fi:_[___] ] := s_. PropFieldPattern[fi]
-
 PropFieldPattern[ fi_ ] :=
   (Message[InitializeModel::nosymb, FullForm[fi]]; Abort[])
-
-
 CoupFieldPattern[ f:fi_[i_Symbol, m_Symbol] ] := (
   If[ Length[KinematicIndices[fi]] =!= 0,
     Message[InitializeModel::kinind, f] ];
   fi[i__, m_, ___List] )
-
 CoupFieldPattern[ f:fi_[i_Symbol, m_Symbol, ki:{__Symbol}] ] := 
   fi[i__, m_, KinIndices[f, ki]]
-
 CoupFieldPattern[
     fi_[i_Symbol, m_Symbol, ki1:{__Symbol} -> ki2:{__Symbol}] ] := 
   fi[i__, m_, KinIndices[f, ki1] -> KinIndices[f, ki2]]
-
 CoupFieldPattern[ s_Symbol fi:_[___] ] := s_. CoupFieldPattern[fi]
-
 CoupFieldPattern[ fi_ ] :=
   (Message[InitializeModel::nosymb, FullForm[fi]]; Abort[])
-
-
 KinIndices[ f_, ki_ ] := (
   If[ Length[KinematicIndices[Head[f]]] =!= Length[ki],
     Message[InitializeModel::kinind, f] ];
   Append[patt/@ ki, ___] )
-
-
 On[RuleDelayed::rhs]
-
-
 AllFields[ fi_ ] :=
   If[ Length[MixingPartners[fi]] === 1, #, {#, 2 #} ]&[
     If[SelfConjugate[fi], fi, {fi, -fi}] ]
-
-
 Attributes[ ClearDefs ] = {HoldAll}
-
 ClearDefs[ defs_ ] := defs = Select[defs, FreeQ[#, P$Generic[__]]&]
-
-
 Attributes[ Assign ] = {Listable}
-
 Assign[ fi_, a_[t___] -> b_ ] := Assign[fi, t, a -> b]
-
 Assign[ fi__, Mass -> b_ ] := TheMass[fi] = b
-
 Assign[ fi__, PropagatorLabel -> b_ ] := TheLabel[fi] = b
-
 Assign[ fi__, a_ -> b_ ] := a[fi] = b
-
-
 (* Initialization of a classes model: *)
-
 Attributes[ InitModel ] = {HoldAll}
-
 InitModel[ edit_ ][ mod_ ] :=
 Block[ {SVTheC, sv, unsortedFP, unsortedCT, savecp = $ContextPath},
 	(* no Global symbols allowed for these operations *)
   $ContextPath = DeleteCases[$ContextPath, "Global`"];
   $Model = "";
-
   Clear[SVCompatibles, CouplingDeltas, TheC, RenConst];
   ClearDefs[SubValues[PossibleFields]];
   ClearDefs[DownValues[#]]&/@ {CheckFieldPoint,
@@ -531,20 +381,16 @@ Block[ {SVTheC, sv, unsortedFP, unsortedCT, savecp = $ContextPath},
     QuantumNumbers, MatrixTraceFactor, InsertOnly,
     Mixture, TheCoeff, IndexBase,
     TheLabel, PropagatorType, PropagatorArrow};
-
   FAPrint[2, ""];
   $Model = LoadModel[mod];
   edit;
-
 	(* initialize particles:
 	   set properties of classes from their description list: *)
   Assign@@@ M$ClassesDescription;
   SetCoeff[#][Mixture[#]]&@@@ M$ClassesDescription;
-
   SVCompatibles[ _ ] = {};
   Cases[ DownValues[MixingPartners],
     (_[_[p:_[__]]] :> m_) :> AssignMixing[p, m] ];
-
   F$Classes = First/@ M$ClassesDescription;
 	(* set all possible index combinations for a class: *)
   F$AllParticles = Flatten[
@@ -553,24 +399,18 @@ Block[ {SVTheC, sv, unsortedFP, unsortedCT, savecp = $ContextPath},
         (IndexRange/@ Indices[fi] /. {} | _NoUnfold -> {_})] ] ]/@
       F$Classes ];
   F$Particles = F$AllParticles = Flatten[AllFields/@ F$AllParticles];
-
   FAPrint[2, "> ", Length[F$AllParticles],
     " particles (incl. antiparticles) in ",
     Length[F$Classes], " classes"];
-
   F$Classes = F$AllClasses = Flatten[AllFields/@ F$Classes];
   F$AllowedFields = Union[F$AllGeneric, F$AllClasses, F$AllParticles];
-
   _CouplingDeltas = Sequence[];
-
 	(* forming the explicit and half-generic vertex lists: *)
   Off[Rule::rhs];
-
   If[ $SparseCouplings,
     SVTheC[ fi___ ][ kin_, rhs:{0..} ] :=
       (svdef = HoldPattern[TheC[_][fi]] :> rhs; {}) ];
   SVTheC[ fi___ ][ kin_, rhs_ ] := HoldPattern[TheC[kin][fi]] :> rhs;
-
   {sv, unsortedFP} = Flatten/@ Transpose[
     InitCoupling@@@ Block[ {Coup},
       _Coup = 0;
@@ -581,12 +421,9 @@ Block[ {SVTheC, sv, unsortedFP, unsortedCT, savecp = $ContextPath},
       DownValues[Coup]
     ] ];
   SubValues[TheC] = sv;
-
   On[Rule::rhs];
-
   ReferenceOrder[Classes] = Union[List@@@ unsortedFP];
   FieldPointList[Classes] = FieldPoint@@@ ReferenceOrder[Classes];
-
   L$CTOrders = Union[Cases[unsortedFP, FieldPoint[n_][__] -> n]];
   Scan[
     Function[ cto,
@@ -601,51 +438,31 @@ Block[ {SVTheC, sv, unsortedFP, unsortedCT, savecp = $ContextPath},
     If[ $CounterTerms,
       FAPrint[2, "> $CounterTerms are ON"]; L$CTOrders,
       FAPrint[2, "> $CounterTerms are OFF"]; {0} ] ];
-
   FAPrint[1, "classes model ", $Model, " initialized"];
   $ContextPath = savecp;
 ]
-
-
 CC[ fi__ ] == coup_ ^:= Sequence[
   C[fi] == coup,
   AntiParticle/@ C[fi] == ConjugateCoupling[fi][coup]
 ]
-
-
 ToPatt[ c_C ] := ToPatt/@ c
-
 ToPatt[ c__C ] := Map[ToPatt, Alternatives[c], {2}]
-
 ToPatt[ p_ ] := p /; !FreeQ[p, Verbatim[_] | Verbatim[__] | Verbatim[___]]
-
 ToPatt[ s_Symbol f_ ] := Optional[patt[s]] ToPatt[f]
-
 ToPatt[ s_. f:P$Generic[__] ] :=
   s Replace[f, x_Symbol :> patt[x], {1, Infinity}]
-
 ToPatt[ other_ ] = other
-
 patt = Pattern[#, _]&
-
-
 GetCouplings[ c__C ] := Cases[M$CouplingMatrices, ToPatt[c] == _]
-
-
 Attributes[ ReplaceCouplings ] = {HoldAll}
-
 ReplaceCouplings[ a___, c_C += coup_, b___ ] :=
   ReplaceCouplings[a, c == c + coup, b]
-
 ReplaceCouplings[ a___, c_C -= coup_, b___ ] :=
   ReplaceCouplings[a, c == c - coup, b]
-
 ReplaceCouplings[ a___, c_C *= coup_, b___ ] :=
   ReplaceCouplings[a, c == c coup, b]
-
 ReplaceCouplings[ a___, c_C /= coup_, b___ ] :=
   ReplaceCouplings[a, c == c/coup, b]
-
 ReplaceCouplings[ cs__Equal ] :=
 Block[ {Cx, Cmod, done = {}},
   Cx[fi__] := CxSet[fi]@@ Cases[M$CouplingMatrices, ToPatt[C[fi]] == _];
@@ -654,37 +471,23 @@ Block[ {Cx, Cmod, done = {}},
   M$CouplingMatrices = Cmod/@ M$CouplingMatrices;
   Flatten[done]
 ]
-
-
 Attributes[ CmodSet ] = {HoldAll, Listable}
-
 CmodSet[ c_C == coup_ ] :=
   Csetmod[c, ToPatt[c], Hold[coup] /. C -> Cx]
-
 Csetmod[ c_, pc_, Hold[coup_] ] :=
   Cmod[ pc == _ ] := (done = {done, #}; #)&[ c == coup ]
-
-
 CxSet[ fi__ ][ c_ == coup_ ] := ((Cx[##] = coup)&@@ ToPatt[c]; Cx[fi])
-
 CxSet[ fi__ ][ ___ ] := C[fi]
-
-
 ConjugateCoupling[__][ ConjugateCoupling[__][coup_] ] = coup
-
 ConjugateCoupling[fi__][ coup:(_Plus | _List) ] :=
   ConjugateCoupling[fi]/@ coup
-
 ConjugateCoupling[__][ n:(_Integer | _Rational | _IndexDelta) ] := n
-
-
 (* Assigning the mixing propagators.  There are in general 4 cases which
    are distinguished by the following factors multiplying the fields:
 	-->--~~>~~	SV = {S, V}
 	--<--~~<~~	-SV = {-S, -V} 
 	~~>~~-->--	2 SV = {V, S}
 	~~<~~--<--	-2 SV = {-V, -S}  *)
-
 AssignMixing[ part_, {left_, right_} ] :=
 Block[ {comp, i, ppart, pleft, pright},
   ppart = Append[part, i___];
@@ -702,31 +505,19 @@ Block[ {comp, i, ppart, pleft, pright},
     MixingPartners[-ppart] = {-pleft, -pright};
     MixingPartners[-2 ppart] = {-pright, -pleft} ]
 ]
-
 Unionize[ n_, arg_, new_ ] := n[arg] = Union[Flatten[{n[arg], new}]]
-
-
 (* form linear combinations of couplings *)
-
 SetCoeff[ fi_ ][ fi_ ] := AppendTo[TheCoeff[fi], fi]
-
 SetCoeff[ fi_ ][ p_Plus ] := Scan[SetCoeff[fi], p]
-
 SetCoeff[ fi_ ][ c_. Field[s_. (f:P$Generic)[i_, j___]] ] :=
   AppendTo[TheCoeff[s f[i]], fi -> {c, j}]
-
 SetCoeff[ fi_ ][ c_. (f:P$Generic)[i_, j___] ] :=
   AppendTo[TheCoeff[f[i]], fi -> {c, j}]
-
 SetCoeff[ fi_ ][ other_ ] := Message[InitializeModel::nonlin, other, fi]
-
-
 SetCoupling[ c:vert_ == _ ] :=
   Catch[SetCoupling[c, Distribute[TheCoeff/@ vert, List]]]
-
 SetCoupling[ vert_ == coup_, comb_ ] :=
   (Coup[ vert ] += coup) /; FreeQ[comb, Rule]
-
 SetCoupling[ vert_ == coup_, comb_ ] :=
 Block[ {sign, vorig, vref, ord, o, new},
   sign = If[ PermutationSymmetry@@ ToGeneric[vert] === -1,
@@ -738,8 +529,6 @@ Block[ {sign, vorig, vref, ord, o, new},
   new[ fi__ ] := (new[fi] = 0 &; SplitCoeff);
   Scan[(new@@ #)[coup, #]&, comb];
 ]
-
-
 SplitCoeff[ coup_, comb_ ] :=
 Block[ {coeff, v, c, fn = 0},
   o[[ord]] = Ordering[Thread[{vref, comb /. (f_ -> _) -> f}, C]];
@@ -753,39 +542,27 @@ Block[ {coeff, v, c, fn = 0},
     (Plus@@ Times@@@ PermuteFields@@ Transpose[#2]&)@@@
     DownValues[coeff];
 ]
-
-
 StripCoeff[ f0_, -(fi_ -> {coeff_, ind___}) ] :=
   StripCoeff[f0, -fi -> {Conjugate[coeff], ind}]
-
 StripCoeff[ s0_. (f0:P$Generic)[i0_, patt___],
     s_. (f:P$Generic)[i_, ___] -> {lc_, ind___} ] := (
   c = Subst[c, patt, ind];
   AppendTo[coeff[f[i]], {s0 f0[i0] -> lc, Thread[Indices[f[i]] -> #]}];
   s f[i, #]
 )&[ IndexBase[Indices[f[i]], ++fn] ]
-
 StripCoeff[ _, s_. (fi:P$Generic)[i_, ___] ] :=
   s fi[i, IndexBase[Indices[fi], ++fn]]
-
-
 PermuteFields[ fi_, ind_ ] :=
   Transpose[MapThread[ ReplaceAll,
     {Transpose[Map[Last, Permutations[fi], {2}]], ind} ]]
-
-
 Attributes[ IndexBase ] = {Listable}
-
 IndexBase[ i_ ] := IndexBase[i] =
 Block[ {n = "", ib = Cases[DownValues[IndexBase], _[_, s_String] -> s]},
   Scan[ If[ FreeQ[ib, n = n <> #], Return[] ]&,
     Flatten[{Characters[ToLowerCase[ToString@@ i]], "j", "q", "x"}]  ];
   n
 ]
-
 IndexBase[ i_, n_ ] := ToExpression[IndexBase[i] <> ToString[n]]
-
-
 (* InitCoupling converts a single classes coupling definition
    (Equal) to a function definition (SetDelayed).  It checks for
    compatibility of the generic and the classes coupling structure and
@@ -795,18 +572,15 @@ IndexBase[ i_, n_ ] := ToExpression[IndexBase[i] <> ToString[n]]
    where a, b, etc. refer to the kinematic vector G = {Ga, Gb, ..} and
    the inner lists stand for increasing order of the vertices.  For a
    one-dimensional generic coupling we need only {c[0], c[1], ...}. *)
-
 InitCoupling[ _[_[vert_]], coup_ ] :=
 Block[ {lhs, rhs, l, cv, sv, svdef = {}, x, fps,
 genref = ToGeneric[List@@ vert]},
-
 	(* find corresponding generic coupling.
 	   Note: whereas formerly the classes coupling was allowed to be
 	         given in a different order than the generic coupling, a
 	         strict match is now required *)
   If[ !MemberQ[ReferenceOrder[Generic], genref],
     Message[InitializeModel::nogeneric, vert]; Return[{}] ];
-
 	(* in the special case of a one-dimensional coupling supply
 	   the extra List if omitted *)
   l = Length[cv = KinematicVector@@ genref];
@@ -815,18 +589,15 @@ genref = ToGeneric[List@@ vert]},
       Message[InitializeModel::incomp1, vert, l];
       Abort[] ];
     coup ];
-
 	(* check structure of field indices in coupling *)
   If[ Or@@ (If[ SameQ@@ (x = IndexCount[#]), False,
         Message[InitializeModel::incomp2, vert, #, Sequence@@ x];
         True ]&)/@ vert,
     Abort[] ];
-
 	(* change symbols in model file to patterns: *)
   lhs = vert //. {a___, j_Symbol, b___} -> {a, j_, b};
 	(* this assigns TheC for all components of the coupling vector *)
   sv = MapThread[SVTheC@@ lhs, {cv /. SI[n_] :> SIs[[n]], rhs}];
-
   lhs = VSort[lhs];
   cv = ToClasses[vert];
   fps = {};
@@ -840,240 +611,133 @@ genref = ToGeneric[List@@ vert]},
 	   order: { {a[0], b[0], ...}, {a[1], b[1], ...}, ...} *)
   {{sv, svdef}, fps}
 ]
-
-
 IndexCount[ _. fi_[n_, ndx_List:{}] ] :=
   {Length[Indices[fi[n]]], Length[ndx]}
-
 IndexCount[ _ ] = {0, 0}
-
-
 DeltaSelect[ expr_Times ] := Cases[expr, _IndexDelta]
-
 DeltaSelect[ expr_List ] :=
   Intersection@@ DeltaSelect/@ DeleteCases[expr, 0]
-
 DeltaSelect[ expr_Plus ] :=
   If[ Head[#] === Plus, {}, DeltaSelect[#] ]& @
     Collect[expr, _IndexDelta] /;
   !FreeQ[expr, IndexDelta]
-
 DeltaSelect[ expr_IndexDelta ] = expr
-
 DeltaSelect[ _ ] = {}
-
-
 (* some defaults for the classes properties: *)
-
 SelfConjugate[ _Integer fi_ ] := SelfConjugate[fi]
-
 SelfConjugate[ fi_[i_, __] ] := SelfConjugate[fi[i]]
-
 _SelfConjugate = False
-
-
 IndexRange[ error_ ] :=
   (Message[InitializeModel::norange, error]; IndexRange[error] = {})
-
 Indices[ _Integer fi_ ] := Indices[fi]
-
 Indices[ fi_[i_, __] ] := Indices[fi[i]]
-
 _Indices = {}
-
-
 IndexSum[0, _] = 0
-
 IndexSum[ IndexDelta[i_, j_] r_., {i_, _} ] := r /. (i -> j)
-
-
 AddHC[ h_[type___, i_, j_], weight_:(1&) ] :=
   weight[i, j] h[type, i, j]/2 +
   weight[j, i] Conjugate[h[type, j, i]]/2
-
 AddHC[ h_, weight_:(1&) ] :=
   weight[i, j] h/2 +
   weight[j, i] Conjugate[h]/2
-
-
 KinematicIndices[ VS ] := KinematicIndices[SV]
-
 _KinematicIndices = {}
-
-
 MatrixTraceFactor[ _Integer fi_ ] := MatrixTraceFactor[fi]
-
 MatrixTraceFactor[ fi_[i_, __] ] := MatrixTraceFactor[fi[i]]
-
 _MatrixTraceFactor = 1
-
-
 InsertOnly[ _Integer fi_ ] := InsertOnly[fi]
-
 InsertOnly[ fi_[i_, __] ] := InsertOnly[fi[i]]
-
-_InsertOnly = {External, Internal, Loop}
-
-
+_InsertOnly = {External, Internal, HighEnergyPhysics`FeynCalc`Loop`Loop}
 QuantumNumbers[ -fi_ ] := -QuantumNumbers[fi]
-
 _QuantumNumbers = {}
-
-
 Mixture[ fi_[i_, j_, ___] ] := Subst[Mixture[fi[i]], i, j]
-
 Mixture[ fi_, ___ ] = fi
-
-
 TheCoeff[ s_Integer f_ ] := s TheCoeff[f]
-
 TheCoeff[ fi_[i_, __] ] := TheCoeff[fi[i]]
-
 _TheCoeff = {}
-
-
 (* There are no direct definitions for the masses of the particles since
    we want to keep track of the field contents of a propagator and the
    mass replacement rules (e.g. Mass[particle] = Mass[antiparticle])
    destroy this information.  All those definitions are given for the
    function TheMass. *)
-
 TheMass[ _Integer fi_, t___ ] := TheMass[fi, t]
-
 TheMass[ fi_[i_, j_List, __], t___ ] := TheMass[fi[i, j], t]
-
 TheMass[ fi___ ] := DefaultMass[fi]
-
-
 DefaultMass[ fi_[i_, j_List], t___ ] :=
 Block[ {DefaultMass, m},
   IndexMass[m, j] /; Head[m = TheMass[fi[i], t]] =!= DefaultMass
 ]
-
 DefaultMass[ fi_, t_ ] :=
 Block[ {m = TheMass[fi]}, m /; Head[m] =!= Mass ]
-
 DefaultMass[ fi__ ] = Mass[fi]
-
-
 IndexMass[ n_?NumberQ, _ ] = n
-
 IndexMass[ s_, {j___} ] := s[j]
-
-
 TheLabel::undef = "No label defined for `1`."
-
 TheLabel[ SV, ___ ] = {"S", "V"}
-
 TheLabel[ VS, ___ ] = {"V", "S"}
-
 TheLabel[ i_Integer, ___ ] = i
-
 TheLabel[ fi:P$Generic, ___ ] = fi
-
 TheLabel[ (2 | -2) fi_, t___ ] := Reverse[Flatten[{TheLabel[fi, t]}]]
-
 TheLabel[ -fi_, t___ ] := TheLabel[fi, t]
-
 TheLabel[ fi___ ] := DefaultLabel[fi]
-
-
 DefaultLabel[ fi_[i_Integer, j_List], t___ ] :=
 Block[ {DefaultLabel, l},
   (Subst[l, Indices[fi[i]], IndexStyle/@ j] /. _Index -> Null) /;
     Head[l = TheLabel[fi[i], t]] =!= DefaultLabel
 ]
-
 DefaultLabel[ fi_, t_ ] := TheLabel[fi]
-
 DefaultLabel[ h_[i___] ] :=
   (Message[TheLabel::undef, h[i]]; ComposedChar[h, i])
-
-
 IndexStyle[ Index[_, i_] ] := Alph[i]
-
 IndexStyle[ other_ ] = other
-
-
 (* Note: AntiParticle[...] := AntiParticle[...] = ... is not possible
    because if another model with different SelfConjugate behaviour is
    loaded, AntiParticle must be rebuilt. *)
-
 AntiParticle[ 0 ] = 0
-
 AntiParticle[ SV ] = VS
-
 AntiParticle[ VS ] = SV
-
 AntiParticle[ AntiParticle[fi_] ] = fi
-
 AntiParticle[ (s:2 | -2) part:(fi:P$Generic)[i_, ___] ] :=
   s/2 If[SelfConjugate[fi[i]], part, -part] /.
   mom_FourMomentum -> -mom
-
 AntiParticle[ s_. part:(fi:P$Generic)[i_, ___] ] :=
   s Length[MixingPartners[fi[i]]] If[SelfConjugate[fi[i]], part, -part] /.
   mom_FourMomentum -> -mom
-
 	(* there are no antiparticles at Generic level.
 	   It is important to have _Symbol here to prevent
 	   AntiParticle[Field[i]] from being evaluated. *)
 AntiParticle[ fi_Symbol ] = fi
-
-
 	(* VS is present only at generic level and is needed to
 	   distinguish which side of a mixing propagator has the S and
 	   which has the V coupling. Logically, VS should be represented
 	   by 2 SV, but there are no factors in front of fields at
 	   generic level. *)
 VS[ i__ ] := -SV[i]
-
-
 PropagatorType[ V ] = Sine
-
 PropagatorType[ S ] = ScalarDash
-
 PropagatorType[ U ] = GhostDash
-
 PropagatorType[ SV ] = {ScalarDash, Sine}
-
 PropagatorType[ VS ] = {Sine, ScalarDash}
-
 PropagatorType[ (2 | -2) fi_ ] := Reverse[Flatten[{PropagatorType[fi]}]]
-
 PropagatorType[ -fi_ ] := PropagatorType[fi]
-
 PropagatorType[ fi_[i_, __] ] := PropagatorType[fi[i]]
-
 _PropagatorType = Straight
-
-
 PropagatorArrow[ _?Negative fi_ ] :=
   PropagatorArrow[fi] /. {Forward -> Backward, Backward -> Forward}
-
 PropagatorArrow[ 2 fi_ ] := PropagatorArrow[fi]
-
 PropagatorArrow[ fi_[i_, __] ] := PropagatorArrow[fi[i]]
-
 _PropagatorArrow = None
-
-
-GaugeXi[ _Integer fi_ ] := GaugeXi[fi]
-
-
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ _Integer fi_ ] := HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[fi]
 (* RestrictCurrentModel accepts any number of ExcludeFieldPoints or
    ExcludeParticles rules and correspondingly sets the CheckFieldPoint
    functions for the vertices to False or deletes the fields from the
    F$xxx lists
    RestrictCurrentModel[] removes all restrictions from the current
    model *)
-
 RestrictCurrentModel::badfp =
 "`1` is not a valid coupling specification of the form
 FieldPoint[cto][fields]."
-
 $ExcludedFPs = $ExcludedParticleFPs = {}
-
 RestrictCurrentModel[] :=
 Block[ {lG, lC, lP},
   lG = Length[F$AllGeneric] - Length[F$Generic];
@@ -1095,13 +759,11 @@ Block[ {lG, lC, lP},
     $ExcludedFPs = $ExcludedParticleFPs = {}
   ];
 ]
-
 RestrictCurrentModel[ args__ ] :=
 Block[ {ex, exclFP, exclP, lG, lC, lP, fps},
   ex = Select[ Flatten[{args}],
     If[ MatchQ[#, ExcludeParticles | ExcludeFieldPoints -> _], True,
       Message[InitializeModel::badrestr, #]; False ]& ];
-
   exclP = Union[Flatten[ Cases[ex, (ExcludeParticles -> p_) -> p] ]];
   If[ Length[exclP] > 0,
     exclP = Union[Flatten[
@@ -1118,7 +780,6 @@ Block[ {ex, exclFP, exclP, lG, lC, lP, fps},
       lC - Length[F$Classes], " Classes, and ",
       lP - Length[F$Particles], " Particles fields"];
   ];
-
   exclFP = Union[Flatten[ Cases[ex, (ExcludeFieldPoints -> p_) -> p] ]];
   If[ Length[exclFP] > 0,
     exclFP = Union[ VSort/@ #,
@@ -1136,37 +797,21 @@ Block[ {ex, exclFP, exclP, lG, lC, lP, fps},
     FAPrint[2, "Excluding ", Length[exclFP] + Length[ex],
       " field point(s) (incl. charge-conjugate ones)"];
   ];
-
   {ExcludeParticles -> exclP, ExcludeFieldPoints -> exclFP}
 ]
-
-
 ValidFP[ FieldPoint[f__] ] := FieldPoint[_][f]
-
 ValidFP[ f:FieldPoint[_][__] ] = f
-
 ValidFP[ f_ ] := (Message[RestrictCurrentModel::badfp, f]; Seq[])
-
-
 FieldMatchQ[ _. (fi:P$Generic)[___], _. fi_ ] = True
-
 FieldMatchQ[ _. (fi:P$Generic)[i_, ___], _. fi_[j_] ] := MatchQ[i, j]
-
 FieldMatchQ[ _. (fi:P$Generic)[i__], _. fi_[j_, {r__}] ] :=
   MatchQ[{i}, {j, {r, ___}}]
-
 FieldMatchQ[ _. fi:P$Generic, _. fi_ ] = True
-
 FieldMatchQ[ fi1_, fi2_ ] := MatchQ[fi1, fi2]
-
-
 FieldMemberQ[ li_, fi_ ] :=
   !VectorQ[List@@ li, !FieldMatchQ[#, fi]&]
-
-
 FieldPointMatchQ[ fp_, FieldPoint[f__] ] :=
   FieldPointMatchQ[fp, FieldPoint[_][f]]
-
 FieldPointMatchQ[ FieldPoint[cto1_][fi1__], FieldPoint[cto2_][fi2__] ] :=
   MatchQ[cto1, cto2] &&
     Length[{fi1}] === Length[{fi2}] &&
@@ -1174,20 +819,12 @@ FieldPointMatchQ[ FieldPoint[cto1_][fi1__], FieldPoint[cto2_][fi2__] ] :=
       If[ VectorQ[Transpose[{{fi1}, #}], (FieldMatchQ@@ #)&],
         Throw[True] ]&/@ Permutations[{fi2}];
       False ]
-
 FieldPointMatchQ[ ___ ] = False
-
-
 FieldPointMemberQ[ li_, fp_ ] :=
   !VectorQ[List@@ li, !FieldPointMatchQ[#, fp]&]
-
-
 ExcludedQ[ vertlist_ ] :=
   Catch[
     Outer[ If[FieldPointMatchQ[##], Throw[True]]&,
       VSort/@ vertlist, $ExcludedParticleFPs ];
     False ]
-
-
 End[]
-
diff --git FeynArts-3.7/FeynArts/Insert.m FeynArts-3.7/FeynArts/Insert.m
index ec7d010..74b7bac 100644
--- FeynArts-3.7/FeynArts/Insert.m
+++ FeynArts-3.7/FeynArts/Insert.m
@@ -3,20 +3,15 @@
 		Insertion of fields into topologies created by 
 		CreateTopologies.
 		last modified 9 Jan 12 th
-
 The insertion is done in 3 levels: insertion of generic fields (Generic),
 of classes of a certain model (Classes) or of the members of the classes
 (Particles).
-
 Models are described in model files which are supposed to exist somewhere
 on the $ModelPath.  At the beginning of an insertion InsertFields calls
 Initialize`InitializeModel that checks whether the model is initialized or
 not and performs the initialization if needed.
-
 *)
-
 Begin["`Insert`"]
-
 Options[ InsertFields ] = {
   Model -> "SM",
   GenericModel -> "Lorentz",
@@ -26,84 +21,64 @@ Options[ InsertFields ] = {
   Restrictions -> {},
   LastSelections -> {}
 } 
-
 InsertFields::syntax =
 "The syntax of InsertFields is InsertFields[tops, in -> out, options]."
-
 InsertFields::extnumber = 
 "You cannot fit `` -> `` external particles onto a `` -> `` leg \
 topology."
 			  
 InsertFields::badparticle = 
 "Particle `` does not live in model ``."
-
 InsertFields::badsel =
 "Element `` of LastSelections is not a proper field specification."
-
-
 InsertFields[ top:P$Topology, args__ ] :=
   InsertFields[TopologyList[top], args]
-
 InsertFields[ tops:(TopologyList | _TopologyList)[___],
   initial_ -> final_, options___Rule ] :=
 Block[ {proc, ilevel, level, excl, last, omit, need, 
 res, ninc, nout, pinc, pout, fields, topnr = 0, fieldnr = 0,
 opt = ActualOptions[InsertFields, options]},
-
   If[ (ilevel = ResolveLevel[InsertionLevel /. opt]) === $Failed,
     Return[$Failed] ];
-
   If[ InitializeModel[ Model /. opt,
     GenericModel -> (GenericModel /. opt),
     Reinitialize -> False ] =!= True, Return[$Failed] ];
-
   proc = Flatten[{initial}] -> Flatten[{final}] /.
     _Integer p_Symbol -> p;
-
   If[ Or@@ (If[ InModelQ[#], False,
     Message[InsertFields::badparticle, #, $Model]; True ]&)/@
       Join@@ proc,
     Return[$Failed] ];
-
   proc = Map[AppendIndex[Field[++fieldnr] -> #][[2]]&, proc, {2}];
-
   excl = RestrictCurrentModel[ Restrictions /. opt,
     Cases[opt, _[ExcludeFieldPoints | ExcludeParticles, _]] ];
   last = Union[Flatten[{LastSelections /. opt}, 1]] /.
     (f:P$Generic)[i_, {j__}] -> f[i, {j, ___}];
-
   If[ Length[res = tops] > 0,
     ninc = Length @ proc[[1]];
     nout = Length @ proc[[2]];
     res = res /. Propagator[External][Vertex[1][j_], v2__] :>
       Propagator[ If[j > ninc, Outgoing, Incoming] ][Vertex[1][j], v2];
-
     pinc = Count[res[[1]], Incoming, Infinity, Heads -> True];
     pout = Count[res[[1]], Outgoing, Infinity, Heads -> True];
     If[ ninc =!= pinc || nout =!= pout,
       Message[InsertFields::extnumber, ninc, nout, pinc, pout];
       Return[$Failed]
     ];
-
     omit = Union[ CheckProperField/@ Flatten[{
       Cases[last, !p_ :> {p, AntiParticle[p]}],
       Cases[ExcludeParticles /. excl, _. P$Generic[_, _]] }] ];
     need = CheckProperField/@ Complement[last /. !p_ -> p, omit];
-
     FAPrint[2, ""];
     FAPrint[2, "inserting at level(s) ", ilevel];
-
     fields = MapIndexed[ Field@@ #2 -> #1 &,
       Join[ proc[[1]], AntiParticle/@ proc[[2]] ] ];
     ninc = Length[fields];
     level = Last[ilevel];
     res = TopologyInsert/@ res
   ];
-
   RestrictCurrentModel[];
-
   FAPrint[1, "in total: ", Statistics[res, ilevel, " insertion"]];
-
   PickLevel[ilevel][ TopologyList[
     Process -> proc,
     Model -> $Model,
@@ -112,17 +87,10 @@ opt = ActualOptions[InsertFields, options]},
     Sequence@@ excl,
     LastSelections -> last ]@@ res ] /. Insertions -> NumberInsertions
 ]
-
 InsertFields[ ___ ] := (Message[InsertFields::syntax]; $Failed)
-
-
 CheckProperField[ fi_Alternatives ] := CheckProperField/@ fi
-
 CheckProperField[ fi:P$Generic | _. P$Generic[__] ] = fi
-
 CheckProperField[ fi_ ] := (Message[InsertFields::badsel, fi]; Seq[])
-
-
 InModelQ[ s_. fi_[i_Integer, j_List] ] :=
 Block[ {r, NoUnfold = Identity},
   InModelQ[s fi[i]] && Length[j] <= Length[Indices[fi[i]]] &&
@@ -134,65 +102,42 @@ Block[ {r, NoUnfold = Identity},
         Transpose[{Take[Indices[fi[i]], Length[j]], j}], 1 ];
       True ]
 ]
-
 InModelQ[ p_ ] := MemberQ[F$AllowedFields, p]
-
-
 FieldToString[ fi_[n_, ___] ] := ToString[fi] <> ToString[n]
-
 FieldToString[ -fi_[n_, ___] ] := ToLowerCase[ToString[fi]] <> ToString[n]
-
 FieldToString[ _ ] = "_"
-
-
 (* add numbers to the Heads of each FeynmanGraph, i.e.
    FeynmanGraph[sym] -> FeynmanGraph[sym, lev == num] *)
-
 AddNumbering[ FeynmanGraph[s_, ___][args__] -> ins_, n_ ] :=
   FeynmanGraph[s, n][args] -> ins
-
 AddNumbering[ FeynmanGraph[s_, ___][args__], n_ ] :=
   FeynmanGraph[s, n][args]
-
 NumberInsertions[ lev_ ][ gr___ ] :=
   Insertions[lev]@@
     MapIndexed[AddNumbering[ #1, lev == #2[[1]] ]&, {gr}]
-
-
 (* TopologyInsert: insert fields into one topology *)
-
 TopologyInsert[ Topology[pr__] -> ins_ ] :=
   TopologyInsert[Topology[1][pr] -> ins]
-
 TopologyInsert[ Topology[pr__] ] :=
   TopologyInsert[Topology[1][pr]]
-
 (* start from scratch if someone wants to re-insert Generic level *)
-
 TopologyInsert[ top_ -> Insertions[_][__] ] :=
   TopologyInsert[top] /; level === Generic
-
 (* allow insertion on top of old insertions only if external particles
    are the same: *)
-
 TopologyInsert[ top_ -> Insertions[_][ins_, ___] ] :=
   TopologyInsert[top] /; fields =!= List@@ Take[ins, ninc]
-
 (* append Insertions template: *)
-
 ReplaceFieldNo[ p_[from_, to_, ___], {n_} ] := p[from, to, Field[n]]
-
 TopologyInsert[ top:Topology[_][__] ] :=
   TopologyInsert[ MapIndexed[ReplaceFieldNo, top] ->
     { FeynmanGraph@@ Join[fields,
       Array[Field[#] -> 0 &, Length[top] - ninc, ninc + 1]] } ]
-
 TopologyInsert[ top:Topology[_][__] -> ins_ ] :=
 Block[ {vertli, fpoints, res, topol = top},
   fpoints = Map[ VertexFields[top],
     DeleteCases[Take[#, 2], Vertex[1][_]]&/@ top, {2} ];
   vertli = Union[Flatten[ Apply[List, fpoints, {0, 1}] ]];
-
 	(* if the field points exist with the external particles
 	   inserted, start insertion process *)
   res =
@@ -203,101 +148,59 @@ Block[ {vertli, fpoints, res, topol = top},
     Statistics[top -> res, ilevel, " insertion"]];
   top -> res
 ]
-
 TopologyInsert[ other_ ] = other
-
-
 (* extract field points *)
-
 VertexFields[ top_ ][ v_ ] := FieldPoint[CTO[v]]@@ TakeInc[v]/@ top
-
 CTO[ Vertex[_, c_][__] ] = c
-
 CTO[ _ ] = 0
-
-
 FieldPoints[ gr_:{}, top:P$Topology, ___ ] := Sort/@
   (VertexFields[AddFieldNo[top]]/@ Vertices[top] /. List@@ gr)
-
-
 (* get particle which is incoming in vertex v from propagator pr *)
-
 TakeInc[ v_ ][ _[v_, v_, f_, ___] ] := Sequence[IncField[f], OutField[f]]
-
 TakeInc[ v_ ][ _[v_, _, f_, ___] ] := IncField[f]
-
 TakeInc[ v_ ][ _[_, v_, f_, ___] ] := OutField[f]
-
 TakeInc[ _ ][ _ ] = Sequence[]
-
-
 IncField[ s_. fi_[ind__, fr_ -> _] ] := AntiParticle[s fi[ind, fr]]
-
 IncField[ fi_ ] := AntiParticle[fi]
-
 OutField[ s_. fi_[ind__, _ -> to_] ] := s fi[ind, to]
-
 OutField[ fi_ ] = fi
-
-
 RightPartner[ fi_ ] := MixingPartners[fi][[-1]] /; FreeQ[fi, Field]
-
-
 ParticleLookup[ fp_, SV ] :=
   Flatten[ SVCompatibles/@
     Lookup[ fp[[0, 1]] ][V, FieldPoint@@ (fp /. _Field -> V)] ]
-
 ParticleLookup[ fp_, VS ] :=
   Flatten[ SVCompatibles/@
     Lookup[ fp[[0, 1]] ][S, FieldPoint@@ (fp /. _Field -> S)] ]
-
 ParticleLookup[ fp_, p_ ] :=
   Flatten[ Compatibles/@
     Lookup[ fp[[0, 1]] ][p, FieldPoint@@ (fp /. _Field -> p)] ]
-
-
 Lookup[ cto_?NonNegative ] = PossibleFields[cto]
-
 Lookup[ cto_ ][ 0, fp_ ] := PossibleFields[-cto][0, fp]
-
 Lookup[ _ ][ p_, fp_ ] :=
 Block[ {n = Position[fp, p, {1}, 1]},
   Select[
     Select[F$Classes, !FreeQ[#, p]&],
     VFAllowed[ReplacePart[fp, #, n]]& ]
 ]
-
-
 CheckFP[ fp:FieldPoint[_?NonNegative][__] ] :=
   CheckFieldPoint[ Sort[fp] ]
-
 CheckFP[ fp_ ] :=
   !FreeQ[fp, Field] ||
   ( MemberQ[FieldPointList[Generic], FieldPoint@@ ToGeneric[fp] /. 0 -> _] &&
     VFAllowed[fp] )
-
-
 VFAllowed[ fp_ ] := True /; MemberQ[fp, 0 | P$Generic]
-
 VFAllowed[ fp_ ] :=
   ViolatesQ@@ Flatten[QuantumNumbers/@ List@@ fp] =!= True
-
-
 (* Insert compatible particles in 1 propagator for 1 set of rules: *)
-
 Ins11[ vert12_, ru_, i_ ] := 
 Block[ {vx, p = ru[[i, 2]], leftallowed, rightallowed, allowed, ckfp, prop},
-
   vx = Map[ RightPartner,
     If[ SameQ@@ vert12,		(* tadpole *)
       Take[vert12, 1],
       vert12 ] /. Delete[List@@ ru, i],
     {2} ];
-
   leftallowed = ParticleLookup[vx[[1]], AntiParticle[p]];
-
   ckfp[ n_, fi_ ] := CheckFP[ vx[[n]] /. Field[i] -> fi ];
-
   allowed = If[ Length[vx] === 1,	(* tadpole *)
     Select[ Intersection[leftallowed, F$AllowedFields], ckfp[1, #]& ],
   (* else *)
@@ -307,9 +210,7 @@ Block[ {vx, p = ru[[i, 2]], leftallowed, rightallowed, allowed, ckfp, prop},
       Intersection[leftallowed, rightallowed, F$AllowedFields],
       ckfp[1, #] && ckfp[2, #] & ]
   ];
-
   prop = ResolveType[ vert12[[0, 1]] ];
-
   If[ TrueQ[$FADebug],
     Print["Ins11: inserting field ", p];
     Print["Ins11: L-vertex   = ", vert12[[1]]];
@@ -319,66 +220,45 @@ Block[ {vx, p = ru[[i, 2]], leftallowed, rightallowed, allowed, ckfp, prop},
     Print["Ins11: allowed    = ", allowed];
     Print["Ins11: propagator = ", prop];
   ];
-
   (ru /. (Field[i] -> _) -> (Field[i] -> #))&/@
     Select[allowed, !FreeQ[InsertOnly[#], prop]&]
 ]
-
-
 (* insert the ith propagator: *)
-
 Ins1[ ru_, i_ ] :=
 Block[ {ins},
   ins = Flatten[ Ins11[fpoints[[i]], #, i]&/@ ru ];
   If[ Length[ins] === 0, Throw[ins] ];
   ins
 ]
-
-
 Need[ ] = Sequence[]
-
 Need[ fi__ ] := Select[#, ContainsQ[Drop[#, ninc], {fi}]&]&
-
 Omit[ ] = Sequence[]
-
 Omit[ fi__ ] := Select[#, FreeQ[Drop[#, ninc], Alternatives[fi]]&]&
-
-
 (* insertion at generic level: *)
-
 DoInsert[Generic][ ins_ ] :=
 Block[ {freesites, theins, filter},
   freesites = Flatten[ Position[ins[[1]], _ -> 0, 1] ];
-
   filter = Composition[
     Need@@ (Cases[need, P$Generic | _[P$Generic..]] /. SV :> Seq[SV, VS]),
     Omit@@ (Cases[omit, P$Generic | _[P$Generic..]] /. SV :> Seq[SV, VS]) ];
-
   theins = Insertions[Generic]@@
     InsertionsCompare[ topol,
       filter[ Catch[Fold[Ins1,
         ToGeneric[ins /. (2 | -2) SV[__] -> VS], freesites]] ] ] /.
 		(* restore unstripped rules *)
     Cases[ ins[[1]], ru:(fi_ -> p_ /; p =!= 0) -> ((fi -> _) -> ru) ];
-
   If[ Length[theins] === 0, Throw[theins] ];
   theins
 ]
-
-
 (* insertion at classes level: *)
-
 DoInsert[Classes][ ins_ ] :=
 Block[ {theins, rul, freesites, filter, pfilter},
   theins = ToClasses[ rul = ins /.
     (x_ -> Insertions[Classes | Particles][___]) -> x ];
-
 	(* Generic fields count as free sites at classes level *)
   freesites = Flatten[ Position[theins[[1]], _ -> _?AtomQ, 1] ];
-
   If[ Head[theins] =!= Insertions[Generic],
     theins = DoInsert[Generic][theins] ];
-
   filter = Composition[
     Need@@ Cases[need, _. P$Generic[_] | _[(_. P$Generic[_])..]],
     Omit@@ Cases[omit, _. P$Generic[_] | _[(_. P$Generic[_])..]] ];
@@ -386,7 +266,6 @@ Block[ {theins, rul, freesites, filter, pfilter},
     If[ Length[$ExcludedParticleFPs] === 0,
       Identity,
       Select[#, !ExcludedQ[vertli /. List@@ #]&]& ];
-
   theins =
     (# -> Insertions[Classes]@@ InsertionsCompare[
             Topology[ #[[0, 1]] ]@@ topol,
@@ -395,40 +274,26 @@ Block[ {theins, rul, freesites, filter, pfilter},
 		(* restore unstripped rules *)
     Cases[ rul[[1]], ru:(fi_ -> _?(!AtomQ[#]&)) -> ((fi -> _) -> ru) ] /.
     cins:Insertions[Classes][__] :> pfilter[ProvideIndices/@ cins];
-
   theins = Select[theins, Length[ #[[2]] ] =!= 0 &];
   If[ Length[theins] === 0, Throw[theins] ];
   theins
 ]
-
-
 Attributes[ IndexDelta ] = {Orderless}
-
 IndexDelta[ n_, n_ ] = 1
-
 	(* Caveat: do not discard the n on n_Integer, or else
 	   the IndexDelta[n_, n_] rule will apply! *)
 IndexDelta[ n_Integer, _Integer ] = 0
-
 Conjugate[ IndexDelta[ind__] ] ^:= IndexDelta[ind]
-
 IndexDelta[ ind__ ]^_?Positive ^:= IndexDelta[ind]
-
 ext/: IndexDelta[ ext[_], ext[_] ] = 1
-
-
 AppendIndex[ Field[n_] -> s_. fi:_[_] ] :=
   (Field[n] -> s Append[ fi, Append[#, n]&/@ Indices[fi] ]) /;
   Indices[fi] =!= {}
-
 AppendIndex[ Field[n_] -> s_. fi_[i_, j_List] ] :=
   (Field[n] -> s fi[i, Join[ j,
     Append[#, n]&/@ Drop[Indices[fi[i]], Length[j]] ]]) /;
   Length[j] < Length[Indices[fi[i]]]
-
 AppendIndex[ ru_ ] = ru
-
-
 ProvideIndices[ ru_ ] :=
 Block[ {indexru, extind, deltas},
   indexru = AppendIndex/@ ru;
@@ -442,56 +307,40 @@ Block[ {indexru, extind, deltas},
         List ]] ] ];
   EvaluateDelta[ indexru, deltas /. e:extind :> ext[e] ]
 ]
-
-
 EvaluateDelta[ expr_, {} ] :=
 Block[ {c},
   c[ _ ] = ninc;
   c[ t_, n_ ] := c[t, n] = ++c[t];
   expr /. Index[t_, n_] :> Index[t, c[t, n]] /; n > ninc
 ]
-
 	(* For unequal integers: *)
 EvaluateDelta[ _, {0, ___} ] = Sequence[]
-
 EvaluateDelta[ expr_, {IndexDelta[_ext, _Integer], rest___} ] :=
   EvaluateDelta[expr, {rest}]
-
 EvaluateDelta[ expr_, {IndexDelta[ind1_ext, ind2_], rest___} ] :=
   EvaluateDelta[expr /. ind2 -> ind1[[1]], {rest} /. ind2 -> ind1]
-
 EvaluateDelta[ expr_, {IndexDelta[ind1_Integer, ind2_], rest___} ] :=
   EvaluateDelta[expr /. ind2 -> ind1, {rest} /. ind2 -> ind1]
-
 EvaluateDelta[ expr_, {IndexDelta[ind1_, ind2_Index], rest___} ] :=
   EvaluateDelta[expr /. ind2 -> ind1, {rest} /. ind2 -> ind1]
-
 EvaluateDelta[ expr_, {IndexDelta[ind1_, ind2_], rest___} ] :=
   EvaluateDelta[expr /. ind2 -> ind1, {rest} /. ind2 -> ind1]
-
 EvaluateDelta[ expr_, {_, rest___} ] := 
   EvaluateDelta[expr, {rest}]
-
-
 (* insertion at particles level: *)
-
 DoInsert[Particles][ ins_ ] :=
 Block[ {theins, filter},
   theins = ins /. (x_ -> Insertions[Particles][__]) -> x;
   If[ FreeQ[theins, Insertions[Classes]],
     theins = DoInsert[Classes][theins] ];
-
   filter = Composition[
     If[ Length[$ExcludedParticleFPs] === 0,
       Identity,
       Select[#, !ExcludedQ[vertli /. List@@ #]&]& ],
     Need@@ Cases[need, _. P$Generic[_, _] | _[(_. P$Generic[_, _])..]],
     Omit@@ Cases[omit, _. P$Generic[_, _] | _[(_. P$Generic[_, _])..]] ];
-
   theins /. cins:Insertions[Classes][__] :> IndexVariations/@ cins
 ]
-
-
 IndexVariations[ gr:FeynmanGraph[s_, ___][ru__] ] :=
 Block[ {ins, li, NoUnfold},
   NoUnfold[__] = {};
@@ -505,16 +354,13 @@ Block[ {ins, li, NoUnfold},
   ins = InsertionsCompare[ Topology[s]@@ topol, filter[{ru} /. ins] ];
   gr -> Insertions[Particles]@@ ins
 ]
-
-
 InsertionsCompare[ _, {} ] = {}
-
 InsertionsCompare[ top_, ins_ ] :=
 Block[ {intp, loo, all, disj, fno},
 	(* only attempt to compare disjoint insertions *)
   intp = Cases[top, Propagator[Internal][_, _, fi_] -> fi];
   loo[ _ ] = 0;
-  Cases[top, Propagator[Loop[n_]][_, _, fi_] :> (loo[n] += fi)];
+  Cases[top, Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[n_]][_, _, fi_] :> (loo[n] += fi)];
   all = {intp, Times@@ Cases[DownValues[loo], (_ :> p_Plus) -> p]} /.
     (List@@@ ins /. s_?Negative -> -s);
   disj = Apply[List, ins[[ Flatten[Position[all, #, 1]] ]], {0, 1}]&/@ 
@@ -523,6 +369,4 @@ Block[ {intp, loo, all, disj, fno},
   fno = List@@ Last/@ top;
   (FeynmanGraph[ #[[0, 1]] ]@@ Thread[fno -> Last/@ List@@ #]&)/@ all
 ]
-
 End[]
-
diff --git FeynArts-3.7/FeynArts/Topology.m FeynArts-3.7/FeynArts/Topology.m
index 2c7ff6e..ce788b7 100644
--- FeynArts-3.7/FeynArts/Topology.m
+++ FeynArts-3.7/FeynArts/Topology.m
@@ -3,13 +3,10 @@
 		Creation of topologies for Feynman graphs
 		last modified 27 Mar 12 th
 *)
-
 Begin["`Topology`"]
-
 (*
    Definition of starting topologies
    =================================
-
    The sets of starting topologies are classified according to their
    loop number "l" and counter-term order "c" by definition of 
    StartTop[l, c].  Usually its setting is a list of topologies
@@ -20,11 +17,9 @@ Begin["`Topology`"]
    else live in the Global` context ("define[Global`foo] = ...").
    If there is only one starting topology, or one always wants to
    use all of the starting topologies, the define[...] can be omitted.
-
    Since entering starting topologies is not an everyday job, some
    restrictions have been imposed that enable FeynArts to work with much 
    faster algorithms:
-
    1) There is an important distinction between positive and negative
       vertex identifiers (i.e. the v in Vertex[e][v]).  Vertices with
       negative identifiers are so-called permutable vertices.  They are
@@ -37,42 +32,35 @@ Begin["`Topology`"]
       It is this ``power set'' of each topology that is actually compared.
       If you're not sure which vertices should be permutables, make them
       ALL permutables.  This will be slower, but safer.
-
    2) For the correct functioning of the ExcludeTopologies -> ... option 
       it is essential that the propagators on a irreducible conglomerate 
-      of loops have the SAME loop number (the n in Loop[n]), no matter how 
+      of loops have the SAME loop number (the n in HighEnergyPhysics`FeynCalc`Loop`Loop[n]), no matter how 
       many loops there actually are.  For example, the two-loop starting 
-      topology `Theta' has only Loop[1] propagators.
-
+      topology `Theta' has only HighEnergyPhysics`FeynCalc`Loop`Loop[1] propagators.
    3) Vertex identifiers must always be unique, e.g. having both a 
       Vertex[3][1] and a Vertex[4][1] within the same topology is 
       forbidden.
-
    4) To determine the symmetry factor, enter the topology with an
       arbitrary factor first (e.g. Topology[1][...]), then use
       SymmetryFactor to find the factor, and supplement the initial
       definition with the correct factor.
 *)
-
 StartTop[0, 0] = TopologyList[
   Topology[1][   
     Propagator[External][Vertex[1][1], Vertex[3][4]],
     Propagator[External][Vertex[1][2], Vertex[3][4]],
     Propagator[External][Vertex[1][3], Vertex[3][4]] ]
 ]
-
 StartTop[0, 1] = TopologyList[
   Topology[1][
     Propagator[External][Vertex[1][1], Vertex[1, 1][2]] ]
 ]
-
 StartTop[0, 2] = TopologyList[
   define[Global`CT[0, 2][1]] = Topology[2][
     Propagator[Internal][Vertex[1, 1][-2], Vertex[1, 1][-1]] ],
   define[Global`CT[0, 2][2]] = Topology[1][
     Propagator[External][Vertex[1][1], Vertex[1, 2][2]] ]
 ]
-
 StartTop[0, 3] = TopologyList[
   define[Global`CT[0, 3][1]] = Topology[1][
     Propagator[External][Vertex[1][1], Vertex[1, 3][2]] ],
@@ -86,327 +74,290 @@ StartTop[0, 3] = TopologyList[
     Propagator[Internal][Vertex[1, 1][-2], Vertex[3][1]],
     Propagator[Internal][Vertex[1, 1][-3], Vertex[3][1]] ]
 ]
-
 StartTop[1, 0] = TopologyList[
   Topology[2][   
     Propagator[External][Vertex[1][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][2], Vertex[3][2]] ]
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][2], Vertex[3][2]] ]
 ]
-
 StartTop[1, 1] = TopologyList[
   define[Global`CT[1, 1][1]] = Topology[2][
-    Propagator[Loop[1]][Vertex[2, 1][1], Vertex[2, 1][1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][1], Vertex[2, 1][1]] ],
   define[Global`CT[1, 1][2]] = Topology[2][
     Propagator[Internal][Vertex[1, 1][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][2], Vertex[3][2]] ]
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][2], Vertex[3][2]] ]
 ]
-
 StartTop[1, 2] = TopologyList[
   define[Global`CT[1, 2][1]] = Topology[2][
-    Propagator[Loop[1]][Vertex[2, 2][1], Vertex[2, 2][1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 2][1], Vertex[2, 2][1]] ],
   define[Global`CT[1, 2][2]] = Topology[2][
     Propagator[Internal][Vertex[1, 2][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][2], Vertex[3][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][2], Vertex[3][2]] ],
   define[Global`CT[1, 2][3]] = Topology[2][
     Propagator[Internal][Vertex[1, 1][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[2, 1][3], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[2, 1][3], Vertex[3][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][3], Vertex[3][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][3], Vertex[3][2]] ],
   define[Global`CT[1, 2][4]] = Topology[2][
     Propagator[Internal][Vertex[1, 1][1], Vertex[2, 1][2]],
     Propagator[Internal][Vertex[2, 1][2], Vertex[3][3]],
-    Propagator[Loop[1]][Vertex[3][3], Vertex[3][3]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][3], Vertex[3][3]] ],
   define[Global`CT[1, 2][5]] = Topology[4][
-    Propagator[Loop[1]][Vertex[2, 1][-2], Vertex[2, 1][-1]],
-    Propagator[Loop[1]][Vertex[2, 1][-2], Vertex[2, 1][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][-2], Vertex[2, 1][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][-2], Vertex[2, 1][-1]] ],
   define[Global`CT[1, 2][6]] = Topology[4][
     Propagator[Internal][Vertex[1, 1][-1], Vertex[3][1]],
     Propagator[Internal][Vertex[1, 1][-2], Vertex[3][1]],
     Propagator[Internal][Vertex[3][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][2], Vertex[3][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][2], Vertex[3][2]] ],
   define[Global`CT[1, 2][7]] = Topology[2][
     Propagator[Internal][Vertex[1, 1][1], Vertex[3, 1][2]],
-    Propagator[Loop[1]][Vertex[3, 1][2], Vertex[3, 1][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3, 1][2], Vertex[3, 1][2]] ],
   define[Global`CT[1, 2][8]] = Topology[4][
     Propagator[Internal][Vertex[1, 1][-1], Vertex[3][-2]],
     Propagator[Internal][Vertex[1, 1][-3], Vertex[3][-4]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-2]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-2]] ],
   define[Global`CT[1, 2][9]] = Topology[4][
     Propagator[Internal][Vertex[1, 1][-1], Vertex[4][1]],
     Propagator[Internal][Vertex[1, 1][-2], Vertex[4][1]],
-    Propagator[Loop[1]][Vertex[4][1], Vertex[4][1]] ]
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][1], Vertex[4][1]] ]
 ]
-
 StartTop[2, 0] = TopologyList[
   define[Theta] = Topology[12][
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]] ],
   define[Eight] = Topology[8][
-    Propagator[Loop[1]][Vertex[4][1], Vertex[4][1]],
-    Propagator[Loop[1]][Vertex[4][1], Vertex[4][1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][1], Vertex[4][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][1], Vertex[4][1]] ],
   define[Bicycle] = Topology[8][   
     Propagator[Internal][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-2]],
-    Propagator[Loop[2]][Vertex[3][-1], Vertex[3][-1]] ]
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][-1], Vertex[3][-1]] ]
 ]
-
 StartTop[2, 1] = TopologyList[
   define[Global`CT[2, 1][1]] = Topology[6][
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3, 1][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3, 1][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3, 1][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3, 1][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3, 1][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3, 1][-1]] ],
   define[Global`CT[2, 1][2]] = Topology[4][
-    Propagator[Loop[1]][Vertex[2, 1][1], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[2, 1][1], Vertex[3][-2]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][1], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][1], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]] ],
   define[Global`CT[2, 1][3]] = Topology[8][
     Propagator[Internal][Vertex[1, 1][1], Vertex[3][-1]],
     Propagator[Internal][Vertex[3][-2], Vertex[3][-1]],
     Propagator[Internal][Vertex[3][-3], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-3], Vertex[3][-3]],
-    Propagator[Loop[2]][Vertex[3][-2], Vertex[3][-2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-3], Vertex[3][-3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][-2], Vertex[3][-2]] ],
   define[Global`CT[2, 1][4]] = Topology[4][
-    Propagator[Loop[1]][Vertex[2, 1][1], Vertex[4][2]],
-    Propagator[Loop[1]][Vertex[2, 1][1], Vertex[4][2]],
-    Propagator[Loop[1]][Vertex[4][2], Vertex[4][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][1], Vertex[4][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][1], Vertex[4][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][2], Vertex[4][2]] ],
   define[Global`CT[2, 1][5]] = Topology[8][
-    Propagator[Loop[1]][Vertex[4, 1][1], Vertex[4, 1][1]],
-    Propagator[Loop[1]][Vertex[4, 1][1], Vertex[4, 1][1]] ], 
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4, 1][1], Vertex[4, 1][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4, 1][1], Vertex[4, 1][1]] ], 
   define[Global`CT[2, 1][6]] = Topology[6][
     Propagator[Internal][Vertex[1, 1][1], Vertex[4][2]],
-    Propagator[Loop[1]][Vertex[3][3], Vertex[4][2]],
-    Propagator[Loop[1]][Vertex[3][3], Vertex[4][2]],
-    Propagator[Loop[1]][Vertex[3][3], Vertex[4][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][3], Vertex[4][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][3], Vertex[4][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][3], Vertex[4][2]] ],
   define[Global`CT[2, 1][7]] = Topology[4][
     Propagator[Internal][Vertex[1, 1][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][-1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-1], Vertex[3][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][2]] ],
   define[Global`CT[2, 1][8]] = Topology[4][
     Propagator[Internal][Vertex[1, 1][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][2], Vertex[4][3]],
-    Propagator[Loop[1]][Vertex[3][2], Vertex[4][3]],
-    Propagator[Loop[1]][Vertex[4][3], Vertex[4][3]] ], 
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][2], Vertex[4][3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][2], Vertex[4][3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][3], Vertex[4][3]] ], 
   define[Global`CT[2, 1][9]] = Topology[4][
     Propagator[Internal][Vertex[1, 1][1], Vertex[3][2]],
     Propagator[Internal][Vertex[3][3], Vertex[3][4]],
-    Propagator[Loop[1]][Vertex[3][2], Vertex[3][4]],
-    Propagator[Loop[1]][Vertex[3][2], Vertex[3][4]],
-    Propagator[Loop[2]][Vertex[3][3], Vertex[3][3]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][2], Vertex[3][4]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][2], Vertex[3][4]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][3], Vertex[3][3]] ],
   define[Global`CT[2, 1][10]] = Topology[8][
     Propagator[Internal][Vertex[2, 1][1], Vertex[3][-1]],
     Propagator[Internal][Vertex[2, 1][1], Vertex[3][-2]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-2]],
-    Propagator[Loop[2]][Vertex[3][-1], Vertex[3][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][-1], Vertex[3][-1]] ],
   define[Global`CT[2, 1][11]] = Topology[4][
     Propagator[Internal][Vertex[3][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[2, 1][3], Vertex[3][1]],
-    Propagator[Loop[1]][Vertex[2, 1][3], Vertex[3][1]],
-    Propagator[Loop[2]][Vertex[3][2], Vertex[3][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][3], Vertex[3][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[2, 1][3], Vertex[3][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][2], Vertex[3][2]] ],
   define[Global`CT[2, 1][12]] = Topology[4][
     Propagator[Internal][Vertex[3, 1][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3, 1][1], Vertex[3, 1][1]],
-    Propagator[Loop[2]][Vertex[3][2], Vertex[3][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3, 1][1], Vertex[3, 1][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][2], Vertex[3][2]] ],
   define[Global`CT[2, 1][13]] = Topology[4][
     Propagator[Internal][Vertex[1, 1][1], Vertex[4][2]],
     Propagator[Internal][Vertex[3][3], Vertex[4][2]],
-    Propagator[Loop[1]][Vertex[3][3], Vertex[3][3]],
-    Propagator[Loop[2]][Vertex[4][2], Vertex[4][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][3], Vertex[3][3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[4][2], Vertex[4][2]] ],
   define[Global`CT[2, 1][14]] = Topology[8][
     Propagator[Internal][Vertex[1, 1][1], Vertex[5][2]],
-    Propagator[Loop[1]][Vertex[5][2], Vertex[5][2]],
-    Propagator[Loop[1]][Vertex[5][2], Vertex[5][2]] ]
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[5][2], Vertex[5][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[5][2], Vertex[5][2]] ]
 ]
-
 StartTop[3, 0] = TopologyList[ 
 	(* Mercedes star: 4 v3 *)
   define[Three[1]] = Topology[24][ 
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-3], Vertex[3][-2]],
-    Propagator[Loop[1]][Vertex[3][-3], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-3]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-2]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-3], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-3], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-1]] ],
 	(* 2 Circles: 4 v3 *)
   define[Three[2]] = Topology[16][ 
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-3], Vertex[3][-2]],
-    Propagator[Loop[1]][Vertex[3][-3], Vertex[3][-2]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-3]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-3], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-3], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-1]] ],
 	(* 2 Circles in touch: 2 v3 + 1 v4 *)
   define[Three[3]] = Topology[8][
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[4][1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[4][1]],
-    Propagator[Loop[1]][Vertex[3][-1], Vertex[4][1]],
-    Propagator[Loop[1]][Vertex[3][-1], Vertex[4][1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[4][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[4][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-1], Vertex[4][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-1], Vertex[4][1]] ],
 	(* Extended Theta (1): 2 v3 + 1 v4 *)
   define[Three[4]] = Topology[8][
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[4][1]],
-    Propagator[Loop[1]][Vertex[3][-1], Vertex[4][1]],
-    Propagator[Loop[1]][Vertex[4][1], Vertex[4][1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[4][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-1], Vertex[4][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][1], Vertex[4][1]] ],
 	(* Eye of the tiger: 2 v4 *)
   define[Three[5]] = Topology[48][
-    Propagator[Loop[1]][Vertex[4][-2], Vertex[4][-1]],
-    Propagator[Loop[1]][Vertex[4][-2], Vertex[4][-1]],
-    Propagator[Loop[1]][Vertex[4][-2], Vertex[4][-1]],
-    Propagator[Loop[1]][Vertex[4][-2], Vertex[4][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][-2], Vertex[4][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][-2], Vertex[4][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][-2], Vertex[4][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][-2], Vertex[4][-1]] ],
 	(* 3 Circles: 2 v4 *)
   define[Three[6]] = Topology[16][
-    Propagator[Loop[1]][Vertex[4][-1], Vertex[4][-1]],
-    Propagator[Loop[1]][Vertex[4][-2], Vertex[4][-1]],
-    Propagator[Loop[1]][Vertex[4][-2], Vertex[4][-2]],
-    Propagator[Loop[1]][Vertex[4][-2], Vertex[4][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][-1], Vertex[4][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][-2], Vertex[4][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][-2], Vertex[4][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][-2], Vertex[4][-1]] ],
 	(* Extended Theta (2): 1 v3 + 1 v5 *)
   define[Three[7]] = Topology[12][
-    Propagator[Loop[1]][Vertex[3][1], Vertex[5][2]],
-    Propagator[Loop[1]][Vertex[3][1], Vertex[5][2]],
-    Propagator[Loop[1]][Vertex[3][1], Vertex[5][2]],
-    Propagator[Loop[1]][Vertex[5][2], Vertex[5][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][1], Vertex[5][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][1], Vertex[5][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][1], Vertex[5][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[5][2], Vertex[5][2]] ],
 	(* 3-leaf clover: 1 v6 *)
   define[Three[8]] = Topology[48][
-    Propagator[Loop[1]][Vertex[6][1], Vertex[6][1]],
-    Propagator[Loop[1]][Vertex[6][1], Vertex[6][1]],
-    Propagator[Loop[1]][Vertex[6][1], Vertex[6][1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[6][1], Vertex[6][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[6][1], Vertex[6][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[6][1], Vertex[6][1]] ],
 	(* Theta + Tadpole on Vertex *)
   define[ThreeRed[1]] = Topology[12][
     Propagator[Internal][Vertex[3][1], Vertex[4][2]],
-    Propagator[Loop[1]][Vertex[3][1], Vertex[3][1]],
-    Propagator[Loop[2]][Vertex[3][3], Vertex[4][2]],
-    Propagator[Loop[2]][Vertex[3][3], Vertex[4][2]],
-    Propagator[Loop[2]][Vertex[3][3], Vertex[4][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][1], Vertex[3][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][3], Vertex[4][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][3], Vertex[4][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][3], Vertex[4][2]] ],
 	(* Theta + Tadpole on Propagator *)
   define[ThreeRed[2]] = Topology[8][
     Propagator[Internal][Vertex[3][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][-1], Vertex[3][1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][1]],
-    Propagator[Loop[2]][Vertex[3][2], Vertex[3][2]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-1], Vertex[3][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][2], Vertex[3][2]] ],
 	(* 3 Tadpoles *)
   define[ThreeRed[3]] = Topology[48][
     Propagator[Internal][Vertex[3][-1], Vertex[3][1]],
     Propagator[Internal][Vertex[3][-2], Vertex[3][1]],
     Propagator[Internal][Vertex[3][-3], Vertex[3][1]],
-    Propagator[Loop[1]][Vertex[3][-3], Vertex[3][-3]],
-    Propagator[Loop[2]][Vertex[3][-2], Vertex[3][-2]],
-    Propagator[Loop[3]][Vertex[3][-1], Vertex[3][-1]] ],
-	(* Bicycle + Tadpole on Loop *)
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-3], Vertex[3][-3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][-2], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[3]][Vertex[3][-1], Vertex[3][-1]] ],
+	(* Bicycle + Tadpole on HighEnergyPhysics`FeynCalc`Loop`Loop *)
   define[ThreeRed[4]] = Topology[16][
     Propagator[Internal][Vertex[3][-2], Vertex[3][-1]],
     Propagator[Internal][Vertex[3][-4], Vertex[3][-3]],
-    Propagator[Loop[1]][Vertex[3][-4], Vertex[3][-4]],
-    Propagator[Loop[2]][Vertex[3][-3], Vertex[3][-2]],
-    Propagator[Loop[2]][Vertex[3][-3], Vertex[3][-2]],
-    Propagator[Loop[3]][Vertex[3][-1], Vertex[3][-1]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-4], Vertex[3][-4]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][-3], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][-3], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[3]][Vertex[3][-1], Vertex[3][-1]] ],
 	(* Bicycle + Tadpole on Vertex *)
   define[ThreeRed[5]] = Topology[16][
     Propagator[Internal][Vertex[3][-1], Vertex[4][1]],
     Propagator[Internal][Vertex[3][-2], Vertex[4][1]],
-    Propagator[Loop[1]][Vertex[3][-2], Vertex[3][-2]],
-    Propagator[Loop[2]][Vertex[3][-1], Vertex[3][-1]],
-    Propagator[Loop[3]][Vertex[4][1], Vertex[4][1]] ],
-	(* Eight + Tadpole on Loop *)
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][-2], Vertex[3][-2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][-1], Vertex[3][-1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[3]][Vertex[4][1], Vertex[4][1]] ],
+	(* Eight + Tadpole on HighEnergyPhysics`FeynCalc`Loop`Loop *)
   define[ThreeRed[6]] = Topology[8][
     Propagator[Internal][Vertex[3][1], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[3][1], Vertex[4][3]],
-    Propagator[Loop[1]][Vertex[3][1], Vertex[4][3]],
-    Propagator[Loop[2]][Vertex[3][2], Vertex[3][2]],
-    Propagator[Loop[1]][Vertex[4][3], Vertex[4][3]] ],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][1], Vertex[4][3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][1], Vertex[4][3]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[3][2], Vertex[3][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[4][3], Vertex[4][3]] ],
 	(* Eight + Tadpole on vertex => v5 *)
   define[ThreeRed[7]] = Topology[16][
     Propagator[Internal][Vertex[3][1], Vertex[5][2]],
-    Propagator[Loop[1]][Vertex[3][1], Vertex[3][1]],
-    Propagator[Loop[2]][Vertex[5][2], Vertex[5][2]],
-    Propagator[Loop[2]][Vertex[5][2], Vertex[5][2]] ]
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[1]][Vertex[3][1], Vertex[3][1]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[5][2], Vertex[5][2]],
+    Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[2]][Vertex[5][2], Vertex[5][2]] ]
 ]
-
-
 Attributes[ TopologyList ] = {Flat}
-
-
 (* some shortcuts *)
-
 If[ $VersionNumber < 5.1, Except[patt_] = _?(!MatchQ[#, patt] &) ]
-
-TadpolesOnly = ExcludeTopologies -> Loops[Except[1]]
-
+TadpolesOnly = ExcludeTopologies -> HighEnergyPhysics`FeynCalc`Loop`Loops[Except[1]]
 TadpoleCTsOnly = ExcludeTopologies -> CTs[Except[1]]
-
-SelfEnergiesOnly = ExcludeTopologies -> {Loops[Except[2]], WFCorrections}
-
+SelfEnergiesOnly = ExcludeTopologies -> {HighEnergyPhysics`FeynCalc`Loop`Loops[Except[2]], WFCorrections}
 SelfEnergyCTsOnly = ExcludeTopologies -> {CTs[Except[2]], WFCorrectionCTs}
-
-TrianglesOnly = ExcludeTopologies -> Loops[Except[3]]
-
+TrianglesOnly = ExcludeTopologies -> HighEnergyPhysics`FeynCalc`Loop`Loops[Except[3]]
 TriangleCTsOnly = ExcludeTopologies -> CTs[Except[3]]
-
-BoxesOnly = ExcludeTopologies -> Loops[Except[4]]
-
+BoxesOnly = ExcludeTopologies -> HighEnergyPhysics`FeynCalc`Loop`Loops[Except[4]]
 BoxCTsOnly = ExcludeTopologies -> CTs[Except[4]]
-
-PentagonsOnly = ExcludeTopologies -> Loops[Except[5]]
-
+PentagonsOnly = ExcludeTopologies -> HighEnergyPhysics`FeynCalc`Loop`Loops[Except[5]]
 PentagonCTsOnly = ExcludeTopologies -> CTs[Except[5]]
-
-HexagonsOnly = ExcludeTopologies -> Loops[Except[6]]
-
+HexagonsOnly = ExcludeTopologies -> HighEnergyPhysics`FeynCalc`Loop`Loops[Except[6]]
 HexagonCTsOnly = ExcludeTopologies -> CTs[Except[6]]
-
-
 Options[ CreateTopologies ] = {
   Adjacencies -> {3, 4},
   ExcludeTopologies -> {},
   StartingTopologies -> All,
   CTOrder -> 0
 }
-
 CreateTopologies::nostart = 
 "No starting topologies defined for `1` loops and counter-term order `2`."
-
 CreateTopologies::nomatch = 
 "Warning: No starting topologies matched any of `1`."
-
 CreateTopologies::badcto = 
 "Bad counter-term order `1`."
-
 CreateTopologies::badadj = 
 "Adjacencies must be integers > 2."
-
 CreateTopologies::delundef = 
 "No $ExcludeTopologies function defined for `1`."
-
 (* main function supporting i -> o input: *)
-
 CreateTopologies[ l_Integer, i_Integer -> o_Integer, opt___Rule ] :=
   CreateTopologies[l, i + o, opt] /. 
     Propagator[External][v1:Vertex[1][j_], v2_] :>
       Propagator[ If[j > i, Outgoing, Incoming] ][v1, v2]
-
 CreateTopologies[ l_Integer, n_Integer, options___Rule ] := 
 Block[ {excl, start, cto, adj, emax, forb, tops, tree,
 opt = ActualOptions[CreateTopologies, options]},
-
   If[ !VectorQ[adj = Flatten[{Adjacencies /. opt}],
         IntegerQ[#] && # > 2 &],
     Message[CreateTopologies::badadj];
     Return[$Failed] ];
-
   If[ !IntegerQ[cto = CTOrder /. opt] || cto < 0,
     Message[CreateTopologies::badcto, cto];
     Return[$Failed] ];
-
   If[ Head[StartTop[l, cto]] === StartTop,
     Message[CreateTopologies::nostart, l, cto];
     Return[$Failed] ]; 
-
   If[ (start = StartingTopologies /. opt) === All,
     start = StartTop[l, cto],
   (* else *)
@@ -417,7 +368,6 @@ opt = ActualOptions[CreateTopologies, options]},
       Message[CreateTopologies::nomatch, forb];
       Return[TopologyList[]] ]
   ];
-
   emax = Max[adj];
   start = Select[start, FreeQ[#, Vertex[e_, ___] /; e > emax]&];
 	(* set recursion end: *)
@@ -427,11 +377,9 @@ opt = ActualOptions[CreateTopologies, options]},
     start ];
   tops = TopologyList@@
     (ConstructTopologies[l, cto, n, emax, #]&)/@ start;
-
   If[ Length[ forb = Complement[Range[3, emax], adj] ] =!= 0,
     forb = Vertex[Alternatives@@ forb, ___];
     tops = Select[tops, FreeQ[#, forb]&] ];
-
   excl = $ExcludeTopologies/@
     Union[Flatten[{ExcludeTopologies /. opt}]];
   If[ Length[excl] =!= 0,
@@ -440,21 +388,13 @@ opt = ActualOptions[CreateTopologies, options]},
     If[ Length[ forb = Position[excl, HoldPattern[ToTree[#]]] ] > 1,
       excl = ReplacePart[excl, tree, Rest[forb]] ];
     tops = Select[tops, excl] ];
-
   Sort[TopologySort/@ tops]
 ]
-
-
 Attributes[ AndFunction ] = {HoldAll}
-
 AndFunction[ f_ ] := f &
-
 AndFunction[ f__ ] := And[f] &
-
-
 CreateCTTopologies::cterr =
 "Error in CreateTopologies for `1` loops and counter-term order `2`."
-
 CreateCTTopologies[ c_Integer,
   n:(_Integer -> _Integer) | _Integer, opt___Rule ] :=
 Block[ {x},
@@ -463,14 +403,10 @@ Block[ {x},
       If[x === $Failed, Message[CreateCTTopologies::cterr, #, c - #] ];
       x )&, c, 0 ]
 ]
-
-
 CreateVFTopologies[ vf_Integer,
   n:(_Integer -> _Integer) | _Integer, opt___Rule ] :=
   CreateTopologies[0, n, CTOrder -> vf, opt] /.
     Vertex[e_, c_] -> Vertex[e, -c]
-
-
 (* Recursive creation of topologies.  The internal function that does
    all the work is ConstructTopologies.  It saves all values once found.
    To stop the recursion CreateTopologies defines ConstructTopologies
@@ -478,29 +414,21 @@ CreateVFTopologies[ vf_Integer,
    ConstructTopologies always generates ALL topologies with up to emax
    edges on any vertex.  Those edge numbers that are to be omitted
    (e.g. Adjacencies -> {4, 6}) are sorted out by CreateTopologies. *)
-
 (* if the recursion failed to stop: *)
-
 ConstructTopologies[ _, _, _?Negative, _, _ ] = TopologyList[]
-
 (* recursive generation of topologies *)
-
 ConstructTopologies[ l_, cto_, ext_, emax_, top_ ] :=
   ConstructTopologies[l, cto, ext, emax, top] =
     TopologyList[ AddOne[#, ext, emax]&/@
       ConstructTopologies[l, cto, ext - 1, emax, top] ]
-
-
 (* Add external line to a propagator.
    Vertices added by the program are numbered starting at
    100, 101, 102... hopefully this will avoid index conflicts. *)
-
 AddToPropagator[ Propagator[h_][from_, to_], n_ ] :=
-  Topology[h /. Loop[_] -> Loop][
+  Topology[h /. HighEnergyPhysics`FeynCalc`Loop`Loop[_] -> HighEnergyPhysics`FeynCalc`Loop`Loop][
     Propagator[h][from, Vertex[3][n + 99]],
     Propagator[h /. External -> Internal][Vertex[3][n + 99], to],
     Propagator[External][Vertex[1][n], Vertex[3][n + 99]] ]
-
 AddPropagator[ top_, n_ ] :=
   TopologyCompare[
     TopologyList@@
@@ -508,17 +436,13 @@ AddPropagator[ top_, n_ ] :=
         Topology[s_][p1___, Topology[snew_][pnew__], p2___] :> 
           Topology[s snew][p1, pnew, p2]
   ]
-
-
 (* add external line to a vertex *)
-
 AddToVertex[ Topology[s_][pr__], vert_, n_ ] :=
 Block[ {newv = vert},
   ++newv[[0, 1]];
   Topology[ s If[vert[[1]] < 0, Permutable, Vertex] ][ pr,
     Propagator[External][Vertex[1][n], newv] ] /. vert -> newv
 ]
-
 AddVertex[ top_, n_, emax_ ] :=
 Block[ {vert},
   vert = Union[Cases[ top,
@@ -528,95 +452,55 @@ Block[ {vert},
       TopologyList@@ Cases[vert, v:#[__] :> AddToVertex[top, v, n]] ]&)/@
     Union[Head/@ vert]
 ]
-
-
 AddOne[ top_, n_, emax_ ] :=
   TopologyList[ AddPropagator[top, n], AddVertex[top, n, emax] ]
-
-
 (* Order topologies canonically (sort of) *)
-
 Incoming2 = Outgoing
-
 topSort[ top_ ] :=
-Block[ {vert, Loop, lc = 0, vc = 0, pc = 0, Incoming2, Outgoing},
+Block[ {vert, HighEnergyPhysics`FeynCalc`Loop`Loop, lc = 0, vc = 0, pc = 0, Incoming2, Outgoing},
   Outgoing = Incoming2;
   Flatten[plist@@ MapIndexed[toSort, top, 2]]
 ]
-
-
 toSort[ Vertex[1][n_], _ ] := (vc = Max[vc, n]; vert[1][n, 0])
-
 toSort[ Vertex[e_, c_:0][n_], _ ] := vert[e][1000 + n, c]
-
-toSort[ Propagator[Loop[n_]][v__], {i_} ] :=
-  prop[Loop, psort[v], {Loop[1000 + n]}][v, i]
-
+toSort[ Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[n_]][v__], {i_} ] :=
+  prop[HighEnergyPhysics`FeynCalc`Loop`Loop, psort[v], {HighEnergyPhysics`FeynCalc`Loop`Loop[1000 + n]}][v, i]
 toSort[ Propagator[t_][v__], {i_} ] := prop[t, psort[v]][v, i]
-
-
 Attributes[ psort ] = Attributes[ plist ] = {Orderless}
-
 plist[ p_[i__], r___ ] := { toProp[Map[renum, p, {2}]][i], plist[r] }
-
 plist[ ] = {}
-
-
 renum[ x:_[n_, ___] ] := x /; n < 500
-
-renum[ x_Loop ] := x = Loop[++lc]
-
+renum[ x_HighEnergyPhysics`FeynCalc`Loop`Loop ] := x = HighEnergyPhysics`FeynCalc`Loop`Loop[++lc]
 renum[ x:h_[n_, r___] ] := (x = h[++vc, r]) /; n > 1000
-
 renum[ x:h_[_, r___] ] := x = h[--pc, r]
-
-
 toProp[ _[t_, _[v__]] ] := Propagator[t][v]
-
 toProp[ _[_, _[v__], _[t_]] ] := Propagator[t][v]
-
-
 toVert[ vert[e_][n_, 0] ] := Vertex[e][n]
-
 toVert[ vert[e_][n_, c_] ] := Vertex[e, c][n]
-
-
 ord[ _[v__][v__, i_] ] := i
-
 ord[ _[__, i_] ] := -i
-
-
 TopologySort[ tops_TopologyList ] := TopologySort/@ tops
-
 TopologySort[ top:P$Topology ] :=
   Head[top]@@ Map[toVert, Head/@ topSort[top], {2}]
-
-
 TopologyOrdering[ tops_TopologyList ] := TopologyOrdering/@ tops
-
 TopologyOrdering[ top:P$Topology ] :=
 Block[ {sort = topSort[top]},
   {Head[top]@@ Map[toVert, Head/@ sort, {2}], ord/@ sort}
 ]
-
-
 (* Compare topologies *)
-
 TopologyCompare[ tops_ ] :=
 Block[ {comp},
   comp =
-    If[ Count[ tops[[1]], Propagator[Loop[_]][__] ] > 1 ||
+    If[ Count[ tops[[1]], Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[_]][__] ] > 1 ||
           !FreeQ[tops[[1]], Vertex[_, _][_]],
-      Loop | Permutable | Internal,
+      HighEnergyPhysics`FeynCalc`Loop`Loop | Permutable | Internal,
     (* else *)
-      Loop | Permutable
+      HighEnergyPhysics`FeynCalc`Loop`Loop | Permutable
     ];
   Join[ Select[tops, FreeQ[#[[0, 1]], comp]&],
     Compare[ Select[tops, !FreeQ[#[[0, 1]], comp]&] ] ] /.
     Topology[s_. __Symbol][p__] :> Topology[s][p]
 ]
-
-
 (* Finding the symmetry factor: start with symfac = 1, append new
    propagators to loop propagators until all loop propagators have two
    additional vertices.  After each step do a TopologyCompare and choose
@@ -624,7 +508,6 @@ Block[ {comp},
    since we start with symfac = 1), then proceed to add the next
    propagator.  The inverse of the last symfac is then the s in
    Topology[s]. *)
-
 SymmetryFactor[ top:P$Topology ] :=
 Block[ {ext, p, t = Topology[1]@@ top},
   ext = Min[ 0, Cases[top, Vertex[1][n_] -> n, {2}] ];
@@ -639,10 +522,7 @@ Block[ {ext, p, t = Topology[1]@@ top},
   ];
   1/t[[0, 1]]
 ]
-
-
-ChooseProp[ pr_, _ ] := {} /; FreeQ[pr, Loop | Vertex[_, _]]
-
+ChooseProp[ pr_, _ ] := {} /; FreeQ[pr, HighEnergyPhysics`FeynCalc`Loop`Loop | Vertex[_, _]]
 ChooseProp[ pr_, {n_} ] :=
   Switch[ # < 100 &/@ Level[pr, {2}],
     {True, True},
@@ -654,77 +534,48 @@ ChooseProp[ pr_, {n_} ] :=
     _,
       {}
   ]
-
-
 (* $ExcludeTopologies[name] defines the filter "name" for use with the
    ExcludeTopologies -> ... option of CreateTopologies.
-
    When programming own filters you must make sure that the filter
    is always defined as a pure function, i.e. func[#]&.  In the filter
    function ToTree may be used which returns its argument (a topology)
    with the loops shrunk to a point named Centre[adj][n] where adj is
    the adjacency of loop n. *)
-
-$ExcludeTopologies[ Loops[n_] ] = FreeQ[ToTree[#], Centre[n]] &
-
+$ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[n_] ] = FreeQ[ToTree[#], Centre[n]] &
 $ExcludeTopologies[ CTs[n_] ] = FreeQ[#, Vertex[n, _]] &
-
-$ExcludeTopologies[ Tadpoles ] = $ExcludeTopologies[ Loops[1] ]
-
+$ExcludeTopologies[ Tadpoles ] = $ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[1] ]
 $ExcludeTopologies[ TadpoleCTs ] = $ExcludeTopologies[ CTs[1] ]
-
-$ExcludeTopologies[ SelfEnergies ] = $ExcludeTopologies[ Loops[2] ]
-
+$ExcludeTopologies[ SelfEnergies ] = $ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[2] ]
 $ExcludeTopologies[ SelfEnergyCTs ] = $ExcludeTopologies[ CTs[2] ]
-
-$ExcludeTopologies[ Triangles ] = $ExcludeTopologies[ Loops[3] ]
-
+$ExcludeTopologies[ Triangles ] = $ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[3] ]
 $ExcludeTopologies[ TriangleCTs ] = $ExcludeTopologies[ CTs[3] ]
-
-$ExcludeTopologies[ Boxes ] = $ExcludeTopologies[ Loops[4] ]
-
+$ExcludeTopologies[ Boxes ] = $ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[4] ]
 $ExcludeTopologies[ BoxCTs ] = $ExcludeTopologies[ CTs[4] ]
-
-$ExcludeTopologies[ Pentagons ] = $ExcludeTopologies[ Loops[5] ]
-
+$ExcludeTopologies[ Pentagons ] = $ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[5] ]
 $ExcludeTopologies[ PentagonCTs ] = $ExcludeTopologies[ CTs[5] ]
-
-$ExcludeTopologies[ Hexagons ] = $ExcludeTopologies[ Loops[6] ]
-
+$ExcludeTopologies[ Hexagons ] = $ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[6] ]
 $ExcludeTopologies[ HexagonCTs ] = $ExcludeTopologies[ CTs[6] ]
-
-$ExcludeTopologies[ Boxes[n_] ] = $ExcludeTopologies[ Loops[n] ]
-
+$ExcludeTopologies[ Boxes[n_] ] = $ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[n] ]
 $ExcludeTopologies[ BoxCTs[n_] ] = $ExcludeTopologies[ CTs[n] ]
-
-$ExcludeTopologies[ AllBoxes ] = $ExcludeTopologies[ Loops[n_ /; n >= 4] ]
-
+$ExcludeTopologies[ AllBoxes ] = $ExcludeTopologies[ HighEnergyPhysics`FeynCalc`Loop`Loops[n_ /; n >= 4] ]
 $ExcludeTopologies[ AllBoxCTs ] = $ExcludeTopologies[ CTs[n_ /; n >= 4] ]
-
 $ExcludeTopologies[ WFCorrections ] =
   FreeWFQ[ToTree[#], Centre[1], Centre[2]] &
-
 $ExcludeTopologies[ WFCorrections[patt_] ] =
   $ExcludeTopologies[ WFCorrections ] /.
     t_ToTree :> Select[t, FreeQ[#, Vertex[1][Except[patt]]] &]
-
 $ExcludeTopologies[ WFCorrectionCTs ] =
   FreeWFQ[#, Vertex[1, _], Vertex[2, _]] &
-
 $ExcludeTopologies[ WFCorrectionCTs[patt_] ] =
   $ExcludeTopologies[ WFCorrectionCTs ] /.
     # :> Select[#, FreeQ[#, Vertex[1][_?(!MatchQ[#, patt]&)]] &]
-
 $ExcludeTopologies[ Internal ] = FreeQ[#, Internal] &
-
 $ExcludeTopologies[ undef_ ] :=
   (Message[CreateTopologies::delundef, undef]; Seq[])
-
-
 ToTree[ top_ ] :=
 Block[ {l, v, props, loops = {}},
   props[_] = {};
-  tree = top /. Propagator[Loop[l_]][from_, to_, ___] :>
+  tree = top /. Propagator[HighEnergyPhysics`FeynCalc`Loop`Loop[l_]][from_, to_, ___] :>
     (loops = {loops, l}; props[l] = {props[l], from, to}; Seq[]);
   v = Sequence@@@ tree;
   tree = Fold[
@@ -732,27 +583,17 @@ Block[ {l, v, props, loops = {}},
       #1 /. Thread[ Union[l] -> Centre[Length[l]][#2] ] )&,
     tree, Union[Flatten[loops]] ]
 ]
-
-
 FreeWFQ[ top:P$Topology, patt1_, patt2_ ] :=
   Catch[ MapWF[Throw[False]&, top, patt1, patt2]; True ]
-
-
-LoopFields[ gr_:{}, top:P$Topology, ___ ] :=
-  Cases[AddFieldNo[top] /. List@@ gr, _[_Loop][_, _, f_, ___] -> f]
-
-
+HighEnergyPhysics`FeynCalc`Loop`LoopFields[ gr_:{}, top:P$Topology, ___ ] :=
+  Cases[AddFieldNo[top] /. List@@ gr, _[_HighEnergyPhysics`FeynCalc`Loop`Loop][_, _, f_, ___] -> f]
 WFCorrectionFields[ gr_:{}, top:P$Topology, ___ ] :=
   WFFields[ ToTree[AddFieldNo[top] /. List@@ gr],
     Centre[1], Centre[2] ]
-
 WFCorrectionCTFields[ gr_:{}, top:P$Topology, ___ ] :=
   WFFields[ AddFieldNo[top] /. List@@ gr,
     Vertex[1, _], Vertex[2, _] ]
-
 WFFields[ args__ ] := Flatten[ MapWF[((#3&)@@@ #)&, args] ]
-
-
 MapWF[ foo_, top_, patt1_, patt2_ ] :=
 Block[ {etop, res, pos, br},
   etop = top /. Incoming | Outgoing -> External;
@@ -764,18 +605,11 @@ Block[ {etop, res, pos, br},
     res = {res, DoWF[foo, br]/@ Cases[br, branch[v_] -> v]} ];
   res
 ]
-
 DoWF[ foo_, top_ ][ v_ ] :=
 Block[ {prop = Cases[top, _[_][___, v, ___]]},
   If[ Sort[#[[0, 1]]&/@ prop] === {External, Internal}, foo[prop], {} ]
 ]
-
-
 Attributes[ Curtail ] = {Orderless, Flat}
-
 Curtail[ br:branch[a_].., _[_][c___, a_, d___] ] :=
   Curtail[branch[c, d]] /; a[[0, 1]] - Length[{br}] < 2
-
-
 End[]
-
diff --git FeynArts-3.7/FeynArts/Utilities.m FeynArts-3.7/FeynArts/Utilities.m
index b59e604..c2e997c 100644
--- FeynArts-3.7/FeynArts/Utilities.m
+++ FeynArts-3.7/FeynArts/Utilities.m
@@ -3,19 +3,12 @@
 		diverse utility functions for other parts of FA
 		last modified 18 Oct 09 th
 *)
-
 Begin["`Utilities`"]
-
 Attributes[ FAPrint ] = {HoldRest}
-
 FAPrint[ l_Integer, s__ ] := Print[s] /; l <= $Verbose
-
-
 ActualOptions::noopt =
 "Warning: `2` is not a valid option of `1`."
-
 Options[ ActualOptions ] = {Warnings -> True}
-
 ActualOptions[ sym_, opts___ ] :=
 Block[ {p},
   If[ Warnings /. Options[ActualOptions],
@@ -24,82 +17,44 @@ Block[ {p},
   If[ Length[ p = Position[{opts}, _[First[#], _], 1, 1] ] === 0, #,
     {opts}[[ Sequence@@ p[[1]] ]] ]&/@ Options[sym]
 ]
-
-
 ResolveLevel::invalid =
 "Invalid level specification `1`."
-
 	(* to make things like PaintLevel -> {InsertionLevel} work: *)
 ResolveLevel[ {{___, lev_}} ] := ResolveLevel[{lev}]
-
 ResolveLevel[ lev_List ] :=
   (Union[lev /. Generic -> AAA] /. AAA -> Generic) /;
     VectorQ[lev, MatchQ[#, Generic | Classes | Particles]&]
-
 ResolveLevel[ Generic ] = {Generic}
-
 ResolveLevel[ Classes ] = {Generic, Classes}
-
 ResolveLevel[ Particles ] = {Generic, Classes, Particles}
-
 ResolveLevel[ other_ ] :=
   (Message[ResolveLevel::invalid, other]; $Failed)
-
-
 ResolveType[ Incoming ] = External
-
 ResolveType[ Outgoing ] = External
-
-ResolveType[ _Loop ] = Loop
-
+ResolveType[ _HighEnergyPhysics`FeynCalc`Loop`Loop ] = HighEnergyPhysics`FeynCalc`Loop`Loop
 ResolveType[ other_ ] = other
-
-
 ContainsQ[ expr_, {} ] = True
-
 ContainsQ[ expr_, {x_, ___} ] := False /; FreeQ[expr, x]
-
 ContainsQ[ expr_, {_, li___} ] := ContainsQ[expr, {li}]
-
-
 If[ System`Ordering[{1, 2}] =!= {1, 2},
   System`Ordering[x_] :=
     Last/@ Sort[Transpose[{x, Range[Length[x]]}]]
 ]
-
-
 (* generic fields have no signs (attribute SelfConjugate exists
    only at classes level, i.e. there are no generic antiparticles) *)
-
 ToGeneric[ expr_ ] := expr /. _. (f:P$Generic)[__] -> f
-
 ToClasses[ expr_ ] := expr /. s_. (f:P$Generic)[i_, __] :> s f[i]
-
-
 Seq = Sequence
-
-
 TakeGraph[ gr_ -> _ ] = gr
-
 TakeGraph[ gr_ ] = gr
-
 TakeIns[ _ -> ins_ ] = ins
-
 TakeIns[ _ ] = Sequence[]
-
-
 Subst[ expr_, i_List, j_List ] :=
   expr /. Thread[Take[i, Length[j]] -> j]
-
 Subst[ expr_, ___ ] = expr
-
-
 (* Canonical ordering *)
-
 PSort[ Propagator[x__] ] := PSort[ Propagator[True][x] ]
-
 PSort[ pr:Propagator[_][_, _] ] := Sort[pr]
-
 PSort[ Propagator[type_][from_, to_, part_] ] :=
   If[ !OrderedQ[{from, to}] ||
         (from === to && !OrderedQ[{part, AntiParticle[part]}]),
@@ -107,39 +62,23 @@ PSort[ Propagator[type_][from_, to_, part_] ] :=
   (* else *)
     Propagator[type][from, to, part]
   ]
-
-
 SortCrit[ a:s_. (f:P$Generic)[t_, i___] ] := {s f[t], {i}, a}
-
 SortCrit[ a:s_. f:P$Generic ] := {s f[0], {}, a}
-
 VSort[ vert_ ] := Last/@ Sort[SortCrit/@ vert]
-
-
 Vertices[ top_ ] :=
-  Union[ Cases[top, Vertex[n__][_] /; {n} =!= {1}, {2}] ]
-
-
+  Union[Join[Cases[Cases[top,Propagator[Internal][__]],Vertex[n__][_],Infinity],Cases[top,Vertex[n__][_]/;{n}=!={1},{2}]]]
 (* add Field[n] to propagator *)
-
 AddFieldNo[ top:P$Topology ] := MapIndexed[ AddFieldNo, top ]
-
 AddFieldNo[ p_[from_, to_], {n_} ] := p[from, to, Field[n]]
-
 AddFieldNo[ p_, _ ] = p
-
-
 (* Compare: First build a table of all possible permutations of
    the permutable vertices (those with negative indices), unionize it,
    and weed out the superfluous tops + get their symm factor right *)
-
 Renumber[ top_ ] :=
 Block[ {s},
   s = Sort[(Propagator@@ PSort[#])&/@ top];
   s /. MapIndexed[ #1 -> Head[#1]@@ #2 &, Vertices[s] ]
 ]
-
-
 TopPermute[ Topology[_][props__] ] :=
 Block[ {perm},
   perm = Union[ Cases[{props}, Vertex[_][_?Negative], {2}] ];
@@ -147,10 +86,7 @@ Block[ {perm},
   Sort[ Renumber[{props} /. Thread[perm -> #]]&/@
     Permutations[perm] ][[1]]
 ]
-
-
 Compare[ tops:_[] ] = tops
-
 Compare[ tops_ ] :=
 Block[ {perm, p},
   perm = TopPermute/@ tops;
@@ -159,43 +95,33 @@ Block[ {perm, p},
       Topology[s_][rest__] -> Topology[s/Length[p]][rest] )&/@
     Union[perm]
 ]
-
-
-ProcessName[ FeynAmpList[info__][___] ] := ProcessName@@ (Hold[
+ProcessName[ HighEnergyPhysics`FeynCalc`FeynAmpList`FeynAmpList[info__][___] ] := ProcessName@@ (Hold[
   Map[First, Process, {2}],
   Model, GenericModel,
   ExcludeParticles, ExcludeFieldPoints, LastSelections
 ] /. {info})
-
 ProcessName[ TopologyList[info__][___] ] := ProcessName@@ (Hold[
   Process,
   Model, GenericModel,
   ExcludeParticles, ExcludeFieldPoints, LastSelections
 ] /. {info})
-
 ProcessName[ proc_, opt__ ] :=
   ProcessName[proc] <> "_" <>
     FromCharacterCode[IntegerDigits[Hash[{opt}], 26] + 97]
-
 (*
 ProcessName[ proc_, mod_, opt__ ] :=
   ProcessName[proc, mod] <> "_" <>
     FromCharacterCode[IntegerDigits[Hash[{opt}], 26] + 97]
-
 ProcessName[ proc_, mod_ ] :=
   ProcessName[proc] <> "_" <>
     Delete[{ToString[#], "-"}&/@ Flatten[{mod}], {-1, -1}]
 *)
-
 ProcessName[ proc_ ] := StringJoin[ToString/@ (
   DeleteCases[
     Level[proc /. i_Index :> ToString[i], {-1}, Heads -> True],
     s_Symbol /; Context[s] === "System`" ] /. -1 -> "-" )]
-
-
 Pluralize[ n_, what_ ] :=
   ToString/@ n <> what <> If[Plus@@ Cases[n, _Integer] === 1, "", "s"]
-
 Statistics[ expr_, levels_, what_ ] :=
   Pluralize[
     Rest[Flatten[ {
@@ -204,33 +130,21 @@ Statistics[ expr_, levels_, what_ ] :=
         Cases[expr, Insertions[#][args__] :> Length[{args}], Infinity],
       " ", # }&/@ levels ]], 
     what ]
-
-
 Alph::badindex =
 "There is no letter with index `1`."
-
 Alph[ n_ ] := FromCharacterCode[n + 96] /; n > 0 && n < 27
-
 Alph[ n_ ] := Message[Alph::badindex, n]
-
 UCAlph[ n_ ] := FromCharacterCode[n + 64] /; n > 0 && n < 27
-
 UCAlph[ n_ ] := Message[Alph::badindex, n]
-
 MapIndexed[ (Greek[#1] = #2)&[#2[[1]], #1]&,
   { "\\alpha", "\\beta", "\\gamma", "\\delta", "\\epsilon", "\\zeta",
     "\\eta", "\\theta", "\\iota", "\\kappa", "\\lambda", "\\mu", "\\nu",
     "\\xi", "o", "\\pi", "\\rho", "\\sigma", "\\tau", "\\upsilon",
     "\\phi", "\\chi", "\\psi", "\\omega" } ]
-
 Greek[ n_ ] := Message[Alph::badindex, n]
-
 MapIndexed[ (UCGreek[#1] = #2)&[#2[[1]], #1]&,
   { "A", "B", "\\Gamma", "\\Delta", "E", "Z", "H", "\\Theta", "I", "K",
     "\\Lambda", "M", "N", "\\Xi", "O", "\\Pi", "P", "\\Sigma", "T",
     "\\Upsilon", "\\Phi", "X", "\\Psi", "\\Omega" } ]
-
 UCGreek[ n_ ] := Message[Alph::badindex, n]
-
 End[]
-
diff --git FeynArts-3.7/Models/Automatic.gen FeynArts-3.7/Models/Automatic.gen
new file mode 100644
index 0000000..c4d6fc4
--- /dev/null
+++ FeynArts-3.7/Models/Automatic.gen
@@ -0,0 +1,268 @@
+(* ****************************************************************** *)
+(*                                                                    *)
+(*                            Automatic.gen                           *)
+(*                                                                    *)
+(* ****************************************************************** *)
+
+(* 
+   Author:              Frederik Orellana 1997
+
+   Summary:             Generic model for FeynArts
+
+   Mathematica Version: 3.0 
+
+   Requirements:        FeynArts > 2, PHI, FeynCalc > 3
+
+   Description:         The coupling vector are loaded from files
+                        generated by PHI
+*)
+
+(* ****************************************************************** *)
+
+$GenericModel = "Automatic";
+
+(* ****************************************************************** *)
+
+(* The minuses for outgoing particles are removed *)
+
+$VerticesSpecifications1:=($VerticesSpecifications/.-qu_[q__]->qu[q]);
+
+(* ****************************************************************** *)
+
+(* Standard definitions for all PHI particle types *)
+
+PropagatorType[$ScalarHeads]=Straight;
+PropagatorType[$VectorHeads]=Sine;
+(*PropagatorType[$FermionHeads]=Dashing[{0.003,0.006}];*)
+(*FA seems to have lost some flexibility in costumizing the graphics*)
+PropagatorType[$FermionHeads]=ScalarDash;
+
+PropagatorArrow[$ParticleHeads]=None;
+
+KinematicIndices[$ScalarHeads] := {};
+KinematicIndices[$FermionHeads] := {};
+KinematicIndices[$VectorHeads] := {Lorentz};
+
+TheLabel[Index[Lorentz,i_]] := 
+$CouplingLorentzIndicesString<>ToString[i];
+
+(* ****************************************************************** *)
+
+(*
+  The function GenProps[p]
+  gives the propagator description for the particle type p.
+  Standard definitions are used.
+  Notice that the setting of $PropagatorMassesStates determines the 
+  renormalization state of the mass used for the propagator of each 
+  particle
+*)
+
+(* The condition added to allow redifining propagators
+   before loading FeynArts *)
+If[And@@((Head[GenProps[#]]===GenProps)&/@
+({$ScalarHeads /. Alternatives -> Sequence})),
+GenProps[a:$ScalarHeads]:={
+AnalyticalPropagator[External][ s a[i,p] ] == 1, 
+AnalyticalPropagator[Internal][ s a[i,p] ] == 
+I*PropagatorDenominator[p,Mass[a[i]]]}];
+
+If[And@@((Head[GenProps[#]]===GenProps)&/@
+({$VectorHeads /. Alternatives -> Sequence})),
+GenProps[a:$VectorHeads]:={
+AnalyticalPropagator[External][ s a[i, mom, {li2}] ] == 
+PolarizationVector[ a[i], mom, li2 ], 
+AnalyticalPropagator[Internal][ s a[i,mom,{li1}->{li2}] ] == 
+I*PropagatorDenominator[ mom , Mass[a[i]] ]*
+(-MetricTensor[li1, li2])}];
+
+If[And@@((Head[GenProps[#]]===GenProps)&/@
+({$FermionHeads /. Alternatives -> Sequence})),
+GenProps[a:$FermionHeads]:={
+AnalyticalPropagator[External][ s a[i, mom] ] == 
+NonCommutative[ 
+(*Tag, so WFRenormalize can do its thing*)
+(*DiracSpinor[
+  -mom, Mass[ a[i] ], Sequence @@ Drop[{i},1] ]*)
+HighEnergyPhysics`Phi`Couplings`Private`propSpinor[
+  -mom, Mass[ a[i] ], Sequence @@ Drop[{i},1] ] ], 
+AnalyticalPropagator[Internal][ s a[i,mom] ] == 
+NonCommutative[(*DiracGamma[ -mom ] + Mass[a[i]]*)
+HighEnergyPhysics`Phi`Couplings`Private`propGamma[
+  -mom, Mass[a[i]]] ]*
+I*PropagatorDenominator[ mom , Mass[a[i]] ]}];
+
+(* ****************************************************************** *)
+
+(* allfields is all field-types in $VerticesSpecifications
+   (that is, Pion[0], Pion[1], ... are not distinguished) *)
+(* Change 20/3-1999 - mixing fields must also be included in this list *)
+
+allfields=
+Union[Head/@Union[
+Flatten[Transpose[Transpose[
+$VerticesSpecifications1][[1]]/.Rule->List][[2]]],
+If[Length[$MixingFields]>0,Transpose[$MixingFields/.Rule->List][[1]],{}]]];
+
+(* The function GenProps is used to create propagator definitions
+   for all particle types *)
+
+M$GenericPropagators = Flatten[GenProps/@allfields];
+
+(* ****************************************************************** *)
+
+(* Only vector-type particles have Lorentz index *)
+
+kineindex[a:$VectorHeads,i_]:={ToExpression[
+$CouplingLorentzIndicesString<>ToString[i]]};
+kineindex[a:$ScalarHeads,i_]:=Sequence[];
+kineindex[a:$FermionHeads,i_]:=Sequence[];
+
+(*
+   The coupling vectors are read from the files specified in
+   $VerticesSpecifications.  The left-hand side 
+   (genericfieldsmomenta) of the defintion and the field
+   configuration (genericfields) are created with the fields
+   from $VerticesSpecifications.  The symmetry sign is also
+   taken from $VerticesSpecifications
+*)
+
+(* listrepl substitutes the list PerturbationOrder with
+   one element at a time - to pass it to XName *)
+
+(*Added 7/6-2000 to allow a list of non-Automatic XFileName's*)
+listrepl[{aa___,PerturbationOrder->b_List,
+bb___,XFileName->xn_List,cc___},nn_Integer] :=
+{aa,PerturbationOrder->b[[nn]],bb,XFileName->xn[[nn]],cc};
+
+listrepl[{aa___,XFileName->xn_List,
+bb___,PerturbationOrder->b_List,cc___},nn_Integer] :=
+{aa,PerturbationOrder->b[[nn]],bb,XFileName->xn[[nn]],cc};
+
+(**)
+
+listrepl[{aa___,PerturbationOrder->b_List,bb___},nn_Integer] :=
+{aa,PerturbationOrder->b[[nn]],bb};
+
+(
+olddir=Directory[];
+SetDirectory[$HEPDir];
+SetDirectory["HighEnergyPhysics"];
+SetDirectory["Phi"];
+SetDirectory["CouplingVectors"];
+
+Do[
+
+Do[
+
+(* The coupling vectors are loaded into an array *)
+
+gloadfile[filenr] = XName[listrepl[
+$VerticesSpecifications1[[repp]],filenr]]<>".Gen";
+
+fpath = ToFileName[{$FeynCalcDirectory, "Phi", "CouplingVectors"}, gloadfile[filenr]];
+
+VerbosePrint[1,repp," ",filenr,
+" Loading generic coupling from ",fpath];
+
+genericcouplingvector[repp,filenr] = Get[fpath];
+
+VerbosePrint[2, genericcouplingvector[repp,filenr]],
+
+{filenr,Length[PerturbationOrder/.
+$VerticesSpecifications1[[repp]]]}];
+
+(* The array is simply joined (flattened) *)
+
+genericcouplingvector[repp] =
+Join@@(Table[genericcouplingvector[repp,filenr],
+{filenr,Length[PerturbationOrder/.
+$VerticesSpecifications1[[repp]]]}]);
+
+genericfields[repp] = 
+  Table[ ToExpression["s"<>ToString[rep]]*
+  $VerticesSpecifications1[[repp,1,2,rep,0]][
+   ToExpression["nr"<>ToString[rep]] ], 
+  {rep,1,Length[$VerticesSpecifications1[[repp,1,2]]]} ];
+
+genericfieldsmomenta[repp] =
+  Table[ ToExpression["s"<>ToString[rep]]*
+  $VerticesSpecifications1[[repp,1,2,rep,0]][
+  ToExpression["nr"<>ToString[rep]],
+  ToExpression[$CouplingMomentumVariablesString<>ToString[rep]],
+  kineindex[$VerticesSpecifications1[[repp,1,2,rep,0]],rep] ], 
+  {rep,1,Length[$VerticesSpecifications1[[repp,1,2]]]} ];,
+  
+{repp,Length[$VerticesSpecifications1]}];
+
+SetDirectory[olddir];);
+
+csign[rr_]:=CouplingSign/.$VerticesSpecifications1[[rr]];
+
+(* ****************************************************************** *)
+    
+(* The loaded coupling vectors and the constructed left-hand sides are 
+   used for constructing the coupling definitions *)
+
+M$GenericCouplings  =
+  Union[Table[
+  AnalyticalCoupling@@(genericfieldsmomenta[repp])==
+  (G[csign[repp]]@@genericfields[repp]).genericcouplingvector[repp],
+  {repp,Length[$VerticesSpecifications1]}]];
+
+(* Merge coupling vectors belonging to the same vertex *)
+
+multVertPosG = Position[M$GenericCouplings,#[[1]]]& /@ M$GenericCouplings;
+
+multVertsG = (Extract[M$GenericCouplings,#[[1]]]& /@ #)& /@ multVertPosG;
+
+vertsG =  Union[(#[[1,1]] == merge @@ ((#[[2]])& /@ #))& /@ multVertsG];
+
+M$GenericCouplings=
+    vertsG /. a:merge[(G[_][__].{__})..] :> a[[1,1]].(Join @@ ((#[[2]])& /@ a));
+
+FixCouplingSigns;
+
+(* ****************************************************************** *)
+
+(* FermionFlipRules: for a certain mapping of Fermion fields in a coupling
+   we have to know which operations to perform.
+   OVERALL minus signs of the flipping are generated by defining G to be
+   anti-symmetric (G[-1]).
+   In this model, flip rules are applied for FSS- and FFV-couplings.
+   FSS contains only omega[+/-], so none of the rules matches. FVV
+   is antisymmetric and the rules match, resulting in
+   ga_mu omega[+] ->  - ga_mu omega[-]
+   ga_mu omega[-] ->  - ga-mu omega[+]. *)
+
+M$FermionFlipRule[ 1->2, 2->1, ___ ] =
+{
+  NonCommutative[ DiracGamma[li_],ChiralityProjector[ 1]] :>
+  - NonCommutative[ DiracGamma[li], ChiralityProjector[-1] ],
+  NonCommutative[ DiracGamma[li_],ChiralityProjector[-1]] :>
+  - NonCommutative[ DiracGamma[li], ChiralityProjector[ 1] ]
+};
+
+(* This was cleared in a release of FeynArts-3.7. Without it, Dirac traces are not taken *)
+$FermionLines = True;
+(* This should speed up a bit *)
+$SparseCouplings = True;
+
+(* ****************************************************************** *)
+
+M$LastGenericRules = {
+(* Outgoing vector bosons: throw away signs of momenta *)
+PolarizationVector[
+p_, _. k:(FourMomentum[ Outgoing, i_Integer ]), li_ ] :> 
+Conjugate[PolarizationVector][ p, k, li ] ,
+
+(* for the case of self-energies *)
+PolarizationVector[
+p_, k:(- FourMomentum[ Incoming, 1 ]), li_ ] :> 
+Conjugate[PolarizationVector][ p, k, li ],
+
+(* relicts of the truncation of spinors: *)
+   
+Dot[ 1, line__, 1 ] :> Dot[ line ],
+Dot[ 1, 1 ] :> 1 };
+
+(**)
diff --git FeynArts-3.7/Models/Automatic.mod FeynArts-3.7/Models/Automatic.mod
new file mode 100644
index 0000000..6b1015e
--- /dev/null
+++ FeynArts-3.7/Models/Automatic.mod
@@ -0,0 +1,357 @@
+(* ************************************************************************* *)
+(*                                                                           *)
+(*                             Automatic.mod                                 *)
+(*                                                                           *)
+(* ************************************************************************* *)
+
+(* 
+   Author:              Frederik Orellana 1997
+
+   Summary:             Classes model for FeynArts
+   
+   Mathematica Version: 3.0 
+
+   Requirements:        FeynArts > 2, PHI, FeynCalc > 3
+
+   Description:         The coupling vectors are loaded from 
+                        files generated by PHI   
+*)
+
+(* ************************************************************************* *)
+
+(* The minuses for outgoing particles are kept *)
+
+$VerticesSpecifications2:=($VerticesSpecifications/.
+                           -qu_[q__]->HoldMinus[qu][q]);
+
+(* ************************************************************************* *)
+
+$ScreenSymbolFont = "Symbol";
+
+(*
+  A table is generated with settings for the function isoindexx 
+  to be called later on.
+  isovar[fi,j] is the base j'th iso-spin variable of the field fi
+  isovarii[fi,j,i] is Index[IsoSpin[isovar[fi,j]],i]
+  isorange[fi,j] is the range of the j'th iso-spin variable of the
+  field fi.
+  The result is that e.g. isoindexx[Pion[0],1,1] returns I1, 
+  isoindexx[Pion[0],1,2] returns I2, ..., because 'I' is set to be
+  the first (and only) iso-index string of Pion[0] in
+  $CouplingIsoIndicesSpecifications.
+  isoindexxx[Pion[0],1] returns {I1}, but had Pion[0] had another
+  isospin index 'J'( e.g. Pion[0]->{{IsoRange->{1,2,3},IsoIndicesString->"I"},
+  {IsoRange->{1,2},IsoIndicesString->"J"}} ), it would have returned {I1,J1}
+*)
+
+
+Clear[iistr,iiran,isovar,isovarii,isorange,isovars,isoindexx,isoindexxx];
+
+Table[
+
+Table[
+
+    iistr=$CouplingIsoIndicesSpecifications[[rep,2,indexnr,2,2]];
+    iiran=$CouplingIsoIndicesSpecifications[[rep,2,indexnr,1,2]];
+
+    isovar[$CouplingIsoIndicesSpecifications[[rep,1]],indexnr]=
+    Index[IsoSpin[ToExpression[iistr]]];
+   
+    isovarii[$CouplingIsoIndicesSpecifications[[rep,1]],indexnr,iii_]=
+    Index[IsoSpin[ToExpression[iistr]],iii];
+
+    isorange[$CouplingIsoIndicesSpecifications[[rep,1]],indexnr]=
+    iiran;
+ 
+    setd[isoindexx[$CouplingIsoIndicesSpecifications[[rep,1]],indexnr,i_],
+    {stringj[iistr,tostr[i]]}],
+
+{indexnr,Length[$CouplingIsoIndicesSpecifications[[rep,2]]]}],
+
+{rep,Length[$CouplingIsoIndicesSpecifications]}]/.
+          
+setd->SetDelayed;  
+
+
+isovar[(a:$ParticleHeads)[___],_]:={};
+
+isovars[(a:$ParticleHeads)[i_]]:=
+Flatten[Table[isovar[a[i],indexnr],{indexnr,Length[
+a[i]/.$CouplingIsoIndicesSpecifications]}]];
+
+isovars[(a:$ParticleHeads)[___],_]:={};
+
+isoindexx[(a:$ParticleHeads)[___],_,_]:={"seq[]"};
+
+isoindexxx[(a:$ParticleHeads)[nr_],i_]:=
+Flatten[Table[isoindexx[a[nr],indexnr,i],{indexnr,
+Length[a[nr]/.$CouplingIsoIndicesSpecifications]}]];
+
+isoindexxx[(a:$ParticleHeads)[___],_,_]:={"seq[]"};
+
+(* ************************************************************************* *)
+
+(* All fields in $VerticesSpecifications *)
+(* Change 20/3-1999 - mixing fields must also be included in this list *)
+
+allfieldstot=
+Union[
+Flatten[Transpose[Transpose[
+$VerticesSpecifications1][[1]]/.Rule->List][[2]]],
+If[Length[$MixingFields]>0,Transpose[$MixingFields/.Rule->List][[1]],{}]];
+
+(* The actual setting of the ranges of the iso-spin variables *)
+
+Do[
+
+Do[
+
+  IndexRange[ isovar[$CouplingIsoIndicesSpecifications[[reps,1]],indexnr] ] = 
+
+  Evaluate[isorange[$CouplingIsoIndicesSpecifications[[reps,1]],indexnr]];
+            
+  TheLabel[ 
+     isovarii[$CouplingIsoIndicesSpecifications[[reps,1]],indexnr,i5_]
+            ] = ""
+     (*Uncomment the following and comment '' to have
+       indices displayed*)(*{((isoindexx[
+     $CouplingIsoIndicesSpecifications[[reps,1]],indexnr,reps])/.
+     tostr->ToString/.stringj->StringJoin)[[1]]," ","("," ",
+     i5,")"}*);,
+            
+{indexnr,Length[$CouplingIsoIndicesSpecifications[[reps,2]]]}],
+
+{reps,Length[$CouplingIsoIndicesSpecifications]}];
+
+(* ************************************************************************* *)
+                                                               
+(* The appearance for particles in $FAParticlesInUse is set.
+   FALabel gives the appearance, but is defined only for some particles *)
+
+TheLabel[iii_]  := ToString[iii];
+
+(TheLabel[#]=FALabel[Particle[#[0]][[1]],0])&/@$FAParticlesInUse;
+
+(* ************************************************************************* *)
+
+(*
+  The particle mass can have argument RenormalizationState[j],
+  where j is an integer specifying the order of renormalization.
+  This must be specified in $PropagatorMassesStates.
+  Notice that e.g. ParticleMass[PseudoScalar[2][0]] is
+  ParticleMass[PseudoScalar[2]], whereas ParticleMass[PseudoScalar[2][i]]
+  is just ParticleMass[PseudoScalar[2][i]] for i!=0.
+*)
+
+FAParticleMass[(a:$ParticleHeads)[i_]]:=
+  ParticleMass[a[i],##]&@@(
+      a[i]/.$PropagatorMassesStates/.(aa:$ParticleHeads)[_]->{});
+
+(* The particles can have mixing partners.  This should be specified
+   in $MixingFields *)
+
+mixps[(a:$ParticleHeads)[i_]]/;!FreeQ[$MixingFields,a[i]]:=
+a[i]/.$MixingFields;
+
+mixps[(a:$ParticleHeads)[_]]:={};
+
+(* The particle may propagate only on a certain class of propagators.
+   This should be specified in $InsertOnly *)
+
+inso[(a:$ParticleHeads)[i_]]/;!FreeQ[$InsertOnly,a[i]]:=
+a[i]/.$InsertOnly;
+
+inso[(a:$ParticleHeads)[_]]:={};
+
+(*
+  descr[p[i]] returns the description for the particle p[i].
+  Apart from the iso-spins, standard definitions are used for the
+  three types of particles.
+  All three types can have iso-spin indices.
+  (Only vectors have kinematical indices - see Automatic.gen.)
+  The propagator label is again given by FALabel.
+*)
+
+                (*The Sequence below inserted because of changes
+                from FA2.1 to FA2.2 - after advise by Thomas Hahn*) 
+
+(* Change 20/3-1999 - allow specification of SelfConjugate *)
+
+descr[(a:$VectorHeads)[i_]]:=
+          a[i]  == {
+          SelfConjugate ->
+          If[MemberQ[
+          {True,False},SelfConjugation[a[i]]],SelfConjugation[a[i]],True], 
+                Indices -> isovars[a[i]],
+                Mass -> FAParticleMass[a[i]], 
+                PropagatorLabel -> (*We use that Particle[aN][0]=Particle[a[N]]. For i=!=0 FALabel definitions must be modified*)
+                ComposedChar[Sequence@@Join[{FALabel[Particle[a[i]][[1]],i]},
+                isovars[a[i]]]], 
+                PropagatorType -> Sine, 
+                PropagatorArrow -> None,
+                MixingPartners -> mixps[a[i]],
+                InsertOnly -> inso[a[i]] };
+
+descr[(a:$FermionHeads)[i_]]:=
+          a[i]  == {
+          SelfConjugate ->
+          If[MemberQ[
+          {True,False},SelfConjugation[a[i]]],SelfConjugation[a[i]],False], 
+                Indices -> isovars[a[i]], 
+                Mass -> FAParticleMass[a[i]], 
+                PropagatorLabel -> 
+                ComposedChar[Sequence@@Join[{FALabel[Particle[a[i]][[1]],i]},
+                isovars[a[i]]]],
+                (*PropagatorType -> Dashing[{0.003,0.006}],*)
+								PropagatorType -> ScalarDash,
+                PropagatorArrow -> Forward,
+                MixingPartners -> mixps[a[i]],
+                InsertOnly -> inso[a[i]] };
+
+descr[(a:$ScalarHeads)[i_]]:=
+          a[i] == {
+          SelfConjugate ->
+          If[MemberQ[
+          {True,False},SelfConjugation[a[i]]],SelfConjugation[a[i]],True], 
+          Indices -> isovars[a[i]], 
+                Mass -> FAParticleMass[a[i]], 
+                PropagatorLabel -> 
+                ComposedChar[Sequence@@Join[{FALabel[Particle[a[i]][[1]],i]},
+                isovars[a[i]]]],
+                PropagatorType -> Straight,
+                PropagatorArrow -> None,
+                MixingPartners -> mixps[a[i]],
+                InsertOnly -> inso[a[i]] };
+
+(* ************************************************************************* *)
+
+(* The function descr is used to create descriptions for all particles *)
+
+M$ClassesDescription = (descr/@allfieldstot/.
+{(Indices->{}):>Sequence[],(MixingPartners->{}):>Sequence[],
+(InsertOnly->{}):>Sequence[]});
+
+(* ************************************************************************* *)
+
+(*
+  The coupling vectors are read from the files specified in
+  $VerticesSpecifications.  The left-hand side (classesfields) of the 
+  defintion is created with the fields from $VerticesSpecifications
+*)
+
+olddir=Directory[];
+SetDirectory[$HEPDir];
+SetDirectory["HighEnergyPhysics"];
+SetDirectory["Phi"];
+SetDirectory["CouplingVectors"];
+
+Do[
+
+Do[
+
+(* The coupling vectors are loaded into an array *)
+
+cloadfile[filenr] = XName[listrepl[
+$VerticesSpecifications1[[repp]],filenr]]<>".Mod";
+
+fpath = ToFileName[{$FeynCalcDirectory, "Phi", "CouplingVectors"}, cloadfile[filenr]];
+
+VerbosePrint[1,repp," ",filenr,
+" Loading classes coupling from ",fpath];
+
+classescouplingvector[repp,filenr] = (Get[fpath]),
+
+{filenr,Length[PerturbationOrder/.
+$VerticesSpecifications1[[repp]]]}];
+
+(*
+  The array is parsed into a list of coupling vectors
+  with counterterm entries (if there are any couterterms).
+  Each coupling vector has the length of the flattened
+  array, and each element of each coupling vector is a
+  list of length Length[PerturbationOrder].  E.g. for
+  PerturbationOrder={2,4}, a classes coupling vector
+  corresponding to e.g. a generic coupling vector of the
+  form {m^2,p1^2,p1*p2,...,m^4,e^4,p1^4,...} would have the
+  form {{a1,0},{a2,0},{a3,0},...,{0,b1},{0,b2},...}
+*)
+
+(* The list of zeros into which we will insert the coupling of
+   the right counterterm order, e.g. {0,0} becomes {a1,0} or
+   {0,b1} *)
+
+zerolist=Table[0,{Length[PerturbationOrder/.
+$VerticesSpecifications1[[repp]]]}];
+
+(* A temporary array of the form outerlist[innerlist[a1,a2,...],
+   innerlist[b1,b2,...],...] *)
+
+templist=outerlist@@innerlist/@Table[classescouplingvector[repp,filerep],
+  {filerep,Length[PerturbationOrder/.
+$VerticesSpecifications1[[repp]]]}]/.innerlist[{ga__}]:>innerlist@@Join[ga];
+
+(* Transforming the above array into the array we need *)
+
+(*zeroreplacerules=(
+        Table[templist[[pos]]->(
+        ReplacePart[zerolist,#,pos]&/@(
+        templist[[pos]]/.innerlist->List)),{pos,Length[templist]}]);
+
+classescouplingvector[repp] =
+Join@@(templist/.zeroreplacerules);*)
+
+classescouplingvector[repp]=
+        Join@@Table[
+        ReplacePart[zerolist,#,pos]&/@(
+        templist[[pos]]/.innerlist->List),{pos,Length[templist]}];
+
+(* The list of in/out fields is extracted from $VerticesSpecifications *)  
+
+classesfields[repp] = Table[ 
+           $VerticesSpecifications2[[repp,1,2,rep,0]][
+           $VerticesSpecifications1[[repp,1,2,rep,1]],
+           ToExpression[
+           isoindexxx[$VerticesSpecifications1[[repp,1,2,rep]],rep]/.
+           tostr->ToString/.stringj->StringJoin]/.{{seq[]}->Sequence[],
+           {seq[],___}->Sequence[]}], 
+                 {rep,1,Length[$VerticesSpecifications1[[repp,1,2]]]} ]/.
+                 HoldMinus[a_][b__]:>-a[b];,
+                                             
+{repp,Length[$VerticesSpecifications1]}];
+
+SetDirectory[olddir];
+
+(* ************************************************************************* *)
+
+(* The coupling vectors and the list of in/out fields are used
+   for constructing the coupling definitions *)
+
+M$CouplingMatrices =
+
+Table[
+   
+  C@@(classesfields[repp])==classescouplingvector[repp],
+
+{repp,Length[$VerticesSpecifications1]}];
+
+(* Merge coupling vectors belonging to the same vertex *)
+
+multVertPosC = Position[M$CouplingMatrices,#[[1]]]& /@ M$CouplingMatrices;
+
+multVertsC = (Extract[M$CouplingMatrices, #[[1]]] & /@ #) & /@ multVertPosC;
+
+M$CouplingMatrices = Union[(#[[1, 1]] == Join @@ ((#[[2]]) & /@ #)) & /@ multVertsC];
+
+FixCouplingIndices;
+
+(* ************************************************************************* *)
+
+extraLastRuls={HoldPattern[IndexDelta[i_Integer,i_Integer]] -> 1,
+                         IndexDelta[i_Integer,j_Integer] -> 0};
+
+M$LastModelRules = If[ListQ[M$LastModelRules ],
+ Union[M$LastModelRules, extraLastRuls,$LastModelRules ],
+ Union[extraLastRuls,$LastModelRules ]
+ ];
+
+(**)
diff --git FeynArts-3.7/Models/Lorentz.gen FeynArts-3.7/Models/Lorentz.gen
index 4728619..a34f6a8 100644
--- FeynArts-3.7/Models/Lorentz.gen
+++ FeynArts-3.7/Models/Lorentz.gen
@@ -3,52 +3,34 @@
 		Generic model file for the Lorentz formalism
 		by A. Denner, H. Eck, O. Hahn, S. Kueblbeck 1995
 		last modified 4 May 10 by Thomas Hahn
-
 This file defines the generic analytical propagators and couplings.
 The model described herein is the standard generic model of renormalizable
 field theories (11 generic couplings) with 3 additional 2-vertices.
-
 Reference:
 	A. Denner, "Techniques for the calculation of electroweak
 	radiative corrections at the one-loop level and results for
 	W-physics at LEP200", Fortschr. d. Physik 41 (1993) 4
 *)
-
 	(* Kinematic indices are `transported' along a propagator line.
 	   KinematicIndices[X] = {Name} means that the generic field X
 	   will carry an index Index[Name, i] along the line:  
 	   X[ n, {m..}, p, {Index[Name, i]} -> {Index[Name, i + 1]} ] *)
-
 KinematicIndices[ F ] = {};
 KinematicIndices[ V ] = {Lorentz};
 KinematicIndices[ S ] = {};
 KinematicIndices[ SV ] = {Lorentz};
 KinematicIndices[ U ] = {}
-
 $FermionLines = True
-
 P$NonCommuting = F | U
-
 Attributes[ MetricTensor ] = Attributes[ ScalarProduct ] = {Orderless}
-
-
 FourVector/: -FourVector[ mom_, mu___ ] := FourVector[Expand[-mom], mu]
-
 FourVector[ 0, ___ ] = 0
-
-
 SpinorType[j_Integer, ___] := MajoranaSpinor /; SelfConjugate[F[j]]
-
 SpinorType[_Integer, __] = DiracSpinor
-
-
 M$GenericPropagators = {
-
 	(* general fermion propagator: *)
-
   AnalyticalPropagator[External][ s1 F[j1, mom] ] == 
-    NonCommutative[ SpinorType[j1][-mom, Mass[F[j1]]] ],
-
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ SpinorType[j1][-mom, Mass[F[j1]]] ],
 	(* Remarks:
 	   Fermionic propagators have (like all others, too) their
 	   momentum flowing from left to right. The fermion flow (for
@@ -60,43 +42,30 @@ M$GenericPropagators = {
 	   according to the Majorana paper. However, this rule is given
 	   for a momentum flowing against the fermion flow so, again, we
 	   end up with S(-p). *)
-
   AnalyticalPropagator[Internal][ s1 F[j1, mom] ] ==
-    NonCommutative[ DiracSlash[-mom] + Mass[F[j1]] ] *
-      I PropagatorDenominator[mom, Mass[F[j1]]], 
-
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ DiracSlash[-mom] + Mass[F[j1]] ] *
+      I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Mass[F[j1]]], 
 	(* general vector boson propagator: *)
-
   AnalyticalPropagator[External][ s1 V[j1, mom, {li2}] ] ==
-    PolarizationVector[V[j1], mom, li2],
-
+    HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[V[j1], mom, li2],
   AnalyticalPropagator[Internal][ s1 V[j1, mom, {li1} -> {li2}] ] ==
-    -I PropagatorDenominator[mom, Mass[V[j1]]] *
-      (MetricTensor[li1, li2] - (1 - GaugeXi[V[j1]]) *
+    -I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Mass[V[j1]]] *
+      (MetricTensor[li1, li2] - (1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[V[j1]]) *
          FourVector[mom, li1] FourVector[mom, li2] *
-         PropagatorDenominator[mom, Sqrt[GaugeXi[V[j1]]] Mass[V[j1]]]),
-
+         HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Sqrt[HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[V[j1]]] Mass[V[j1]]]),
 	(* general mixing scalar-vector propagator: *)
-
   AnalyticalPropagator[Internal][ s1 SV[j1, mom, {li1} -> {li2}] ] == 
-    I Mass[SV[j1]] PropagatorDenominator[mom, Mass[SV[j1]]] *
+    I Mass[SV[j1]] HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Mass[SV[j1]]] *
       FourVector[mom, If[s1 == 1 || s1 == -2, li1, li2]],
-
 	(* general scalar propagator: *)
-
   AnalyticalPropagator[External][ s1 S[j1, mom] ] == 1,
-
   AnalyticalPropagator[Internal][ s1 S[j1, mom] ] ==
-    I PropagatorDenominator[mom, Sqrt[GaugeXi[S[j1]]] Mass[S[j1]]],
-
+    I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Sqrt[HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[S[j1]]] Mass[S[j1]]],
 	(* general Fadeev-Popov ghost propagator: *)
-
   AnalyticalPropagator[External][ s1 U[j1, mom] ] == 1,
-
   AnalyticalPropagator[Internal][ s1 U[j1, mom] ] ==
-    I PropagatorDenominator[mom, Sqrt[GaugeXi[U[j1]]] Mass[U[j1]]]
+    I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Sqrt[HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[U[j1]]] Mass[U[j1]]]
 }
-
 	(* Definition of the generic couplings.
 	   The couplings must be defined as a Dot product of the (generic)
 	   coupling vector G[+/-][ field1, field2, .. ] and the
@@ -120,129 +89,96 @@ M$GenericPropagators = {
 	      are present in the generic coupling. Again, it is possible
 	      to define flippings that change the sign of Gamma and to
 	      take care for those signs by using a G[-]. *)
-
 M$GenericCouplings = {
-
 	(* V-V: *)
-
   AnalyticalCoupling[ s1 V[j1, mom1, {li1}], s2 V[j2, mom2, {li2}] ] ==
     G[1][s1 V[j1], s2 V[j2]] .
       { MetricTensor[li1, li2] ScalarProduct[mom1, mom2],
         MetricTensor[li1, li2],
         FourVector[mom1, li2] FourVector[mom2, li1] },
-
 	(* S-V: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 V[j2, mom2, {li2}] ] ==
     G[1][s1 S[j1], s2 V[j2]] .
       { FourVector[mom1, li2],
         FourVector[mom2, li2] },
-
 	(* S-S: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2] ] ==
     G[1][s1 S[j1], s2 S[j2]] .
       { ScalarProduct[mom1, mom2],
         1 },
-
 	(* U-U: *)
-
   AnalyticalCoupling[ s1 U[j1, mom1], s2 U[j2, mom2] ] ==
     G[-1][s1 U[j1], s2 U[j2]] .
       { ScalarProduct[mom1, mom2],
         1 },
-
 	(* F-F: *)
-
   AnalyticalCoupling[ s1 F[j1, mom1], s2 F[j2, mom2] ] ==
     G[-1][s1 F[j1], s2 F[j2]] .
-      { NonCommutative[DiracSlash[mom1], ChiralityProjector[-1]],
-        NonCommutative[DiracSlash[mom2], ChiralityProjector[+1]],
-        NonCommutative[ChiralityProjector[-1]],
-        NonCommutative[ChiralityProjector[+1]] },
-
+      { HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracSlash[mom1], ChiralityProjector[-1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracSlash[mom2], ChiralityProjector[+1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[-1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[+1]] },
 	(* V-V-V-V: *)
-
   AnalyticalCoupling[ s1 V[j1, mom1, {li1}], s2 V[j2, mom2, {li2}], 
       s3 V[j3, mom3, {li3}], s4 V[j4, mom4, {li4}] ] ==
     G[1][s1 V[j1], s2 V[j2], s3 V[j3], s4 V[j4]] .
       { MetricTensor[li1, li2] MetricTensor[li3, li4],
         MetricTensor[li1, li3] MetricTensor[li2, li4],
         MetricTensor[li1, li4] MetricTensor[li3, li2] },
-
 	(* V-V-V: *)
-
   AnalyticalCoupling[ s1 V[j1, mom1, {li1}], s2 V[j2, mom2, {li2}], 
       s3 V[j3, mom3, {li3}] ] ==
     G[-1][s1 V[j1], s2 V[j2], s3 V[j3]] .
       { MetricTensor[li1, li2] FourVector[mom2 - mom1, li3] +
           MetricTensor[li2, li3] FourVector[mom3 - mom2, li1] +
           MetricTensor[li3, li1] FourVector[mom1 - mom3, li2] },
-
 	(* S-S-S-S: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2],
       s3 S[j3, mom3], s4 S[j4, mom4] ] ==
     G[1][s1 S[j1], s2 S[j2], s3 S[j3], s4 S[j4]] .
       { 1 },
-
 	(* S-S-S: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2], s3 S[j3, mom3] ] ==
     G[1][s1 S[j1], s2 S[j2], s3 S[j3]] .
       { 1 },
-
 	(* S-S-V-V: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2],
       s3 V[j3, mom3, {li3}], s4 V[j4, mom4, {li4}] ] ==
     G[1][s1 S[j1], s2 S[j2], s3 V[j3], s4 V[j4]] .
       { MetricTensor[li3, li4] },
-
 	(* S-S-V: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2],
       s3 V[j3, mom3, {li3}] ] == 
     G[-1][s1 S[j1], s2 S[j2], s3 V[j3]] .
       { FourVector[mom1 - mom2, li3] },
-
 	(* S-V-V: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 V[j2, mom2, {li2}], 
       s3 V[j3, mom3, {li3}] ] ==
     G[1][s1 S[j1], s2 V[j2], s3 V[j3]] .
       { MetricTensor[li2, li3] },
-
 	(* F-F-V: *)
-
   AnalyticalCoupling[ s1 F[j1, mom1], s2 F[j2, mom2],
       s3 V[j3, mom3, {li3}] ] ==
     G[-1][s1 F[j1], s2 F[j2], s3 V[j3]] .
-      { NonCommutative[DiracMatrix[li3], ChiralityProjector[-1]], 
-        NonCommutative[DiracMatrix[li3], ChiralityProjector[+1]] },
+      { HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracMatrix[li3], ChiralityProjector[-1]], 
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracMatrix[li3], ChiralityProjector[+1]] },
  
 	(* F-F-S: *)
-
   AnalyticalCoupling[ s1 F[j1, mom1], s2 F[j2, mom2], s3 S[j3, mom3] ] ==
     G[1][s1 F[j1], s2 F[j2], s3 S[j3]] . 
-      { NonCommutative[ChiralityProjector[-1]],  
-        NonCommutative[ChiralityProjector[+1]] },
-
+      { HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[-1]],  
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[+1]] },
 	(* U-U-V: *)
-
   AnalyticalCoupling[ s1 U[j1, mom1], s2 U[j2, mom2],
       s3 V[j3, mom3, {li3}] ] ==
     G[1][s1 U[j1], s2 U[j2], s3 V[j3]] .
       { FourVector[mom1, li3],
         FourVector[mom2, li3] },
-
 	(* S-U-U: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 U[j2, mom2], s3 U[j3, mom3] ] ==
     G[1][s1 S[j1], s2 U[j2], s3 U[j3]] .
       { 1 }
 }
-
 	(* FlippingRules: the flipping rules determines how Dirac
 	   objects change when the order of fermion fields in the
 	   coupling is reversed. In other words, it defines how the
@@ -251,64 +187,44 @@ M$GenericCouplings = {
 	   only gamma_mu omega_pm since the others are either
 	   unchanged or not used (sigma_{mu,nu}).
 	   See Denner, Eck, Hahn, Kueblbeck, NPB 387 (1992) 467. *)
-
 M$FlippingRules =
-  NonCommutative[dm:_DiracMatrix | _DiracSlash, ChiralityProjector[pm_]] ->
-    -NonCommutative[dm, ChiralityProjector[-pm]]
-
+  HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[dm:_DiracMatrix | _DiracSlash, ChiralityProjector[pm_]] ->
+    -HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[dm, ChiralityProjector[-pm]]
 	(* TruncationRules: rule for omitting the wave functions of
 	   external Propagators defined in this file. *)
-
 M$TruncationRules = {
-  _PolarizationVector -> 1,
+  _HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector -> 1,
   _DiracSpinor -> 1,
   _MajoranaSpinor -> 1 
 }
-
 	(* LastGenericRules: the very last rules that are applied to an
 	   amplitude before it is returned by CreateFeynAmp. *)
-
 M$LastGenericRules = {
-  PolarizationVector[p_, _. mom:FourMomentum[Outgoing, _], li_] :>
-    Conjugate[PolarizationVector][p, mom, li]
+  HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[p_, _. mom:FourMomentum[Outgoing, _], li_] :>
+    Conjugate[HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector][p, mom, li]
 }
-
-
 	(* cosmetics: *)
-
 	(*  left spinor in chain + mom incoming -> \bar v
 	    left spinor in chain + mom outgoing -> \bar u
 	   right spinor in chain + mom incoming -> u
 	   right spinor in chain + mom outgoing -> v *)
-Format[
+format1[
   FermionChain[
-    NonCommutative[_[s1_. mom1_, mass1_]],
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[_[s1_. mom1_, mass1_]],
     r___,
-    NonCommutative[_[s2_. mom2_, mass2_]]] ] :=
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[_[s2_. mom2_, mass2_]]] ] :=
   Overscript[If[FreeQ[mom1, Incoming], "u", "v"], "_"][mom1, mass1] .
     r . If[FreeQ[mom2, Outgoing], "u", "v"][mom2, mass2]
-
-Format[ DiracSlash ] = "gs"
-
-Format[ DiracMatrix ] = "ga"
-
-Format[ ChiralityProjector[1] ] = SequenceForm["om", Subscript["+"]]
-
-Format[ ChiralityProjector[-1] ] = SequenceForm["om", Subscript["-"]]
-
-Format[ GaugeXi[a_] ] := SequenceForm["xi", Subscript[a]]
-
-Format[ PolarizationVector ] = "ep"
-
+format1[ DiracSlash ] = "gs"
+format1[ DiracMatrix ] = "ga"
+format1[ ChiralityProjector[1] ] = SequenceForm["om", Subscript["+"]]
+format1[ ChiralityProjector[-1] ] = SequenceForm["om", Subscript["-"]]
+format1[ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[a_] ] := SequenceForm["xi", Subscript[a]]
+format1[ HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector ] = "ep"
 Unprotect[Conjugate];
-Format[ Conjugate[a_] ] = SequenceForm[a, Superscript["*"]];
+format1[ Conjugate[a_] ] = SequenceForm[a, Superscript["*"]];
 Protect[Conjugate]
-
-Format[ MetricTensor ] = "g"
-
-Format[ ScalarProduct[a__] ] := Dot[a]
-
-Format[ FourVector[a_, b_] ] := a[b]
-
-Format[ FourVector[a_] ] := a
-
+format1[ MetricTensor ] = "g"
+format1[ ScalarProduct[a__] ] := Dot[a]
+format1[ FourVector[a_, b_] ] := a[b]
+format1[ FourVector[a_] ] := a
diff --git FeynArts-3.7/Models/Lorentzbgf.gen FeynArts-3.7/Models/Lorentzbgf.gen
index 99cc1b7..a75da27 100644
--- FeynArts-3.7/Models/Lorentzbgf.gen
+++ FeynArts-3.7/Models/Lorentzbgf.gen
@@ -4,50 +4,33 @@
 		in the background field formalism
 		by A. Denner, H. Eck, O. Hahn, S. Kueblbeck 1995
 		last modified 4 May 10 by Thomas Hahn
-
 This file defines the generic analytical propagators and couplings.
 The model described herein is the standard generic model of renormalizable
 field theories (11 generic couplings) with 3 additional 2-vertices.
-
 Reference:
 	A. Denner, "Techniques for the calculation of electroweak
 	radiative corrections at the one-loop level and results for
 	W-physics at LEP200", Fortschr. d. Physik 41 (1993) 4
 *)
-
 	(* Kinematic indices are `transported' along a propagator line.
 	   KinematicIndices[X] = {Name} means that the generic field X
 	   will carry an index Index[Name, i] along the line:  
 	   X[ n, {m..}, p, {Index[Name, i]} -> {Index[Name, i + 1]} ] *)
-
 KinematicIndices[ F ] = {};
 KinematicIndices[ V ] = {Lorentz};
 KinematicIndices[ S ] = {};
 KinematicIndices[ SV ] = {Lorentz};
 KinematicIndices[ U ] = {}
-
 $FermionLines = True
-
 Attributes[ MetricTensor ] = Attributes[ ScalarProduct ] = {Orderless}
-
-
 FourVector/: -FourVector[ mom_, mu___ ] := FourVector[Expand[-mom], mu]
-
 FourVector[ 0, ___ ] = 0
-
-
 SpinorType[j_Integer, ___] := MajoranaSpinor /; SelfConjugate[F[j]]
-
 SpinorType[_Integer, __] = DiracSpinor
-
-
 M$GenericPropagators = {
-
 	(* general fermion propagator: *)
-
   AnalyticalPropagator[External][ s1 F[j1, mom] ] == 
-    NonCommutative[ SpinorType[j1][-mom, Mass[F[j1]]] ],
-
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ SpinorType[j1][-mom, Mass[F[j1]]] ],
 	(* Remarks:
 	   Fermionic propagators have (like all others, too) their
 	   momentum flowing from left to right. The fermion flow (for
@@ -59,43 +42,30 @@ M$GenericPropagators = {
 	   according to the Majorana paper. However, this rule is given
 	   for a momentum flowing against the fermion flow so, again, we
 	   end up with S(-p). *)
-
   AnalyticalPropagator[Internal][ s1 F[j1, mom] ] ==
-    NonCommutative[ DiracSlash[-mom] + Mass[F[j1]] ] *
-      I PropagatorDenominator[mom, Mass[F[j1]]], 
-
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ DiracSlash[-mom] + Mass[F[j1]] ] *
+      I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Mass[F[j1]]], 
 	(* general vector boson propagator: *)
-
   AnalyticalPropagator[External][ s1 V[j1, mom, {li2}] ] ==
-    PolarizationVector[V[j1], mom, li2],
-
+    HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[V[j1], mom, li2],
   AnalyticalPropagator[Internal][ s1 V[j1, mom, {li1} -> {li2}] ] ==
-    -I PropagatorDenominator[mom, Mass[V[j1]]] *
-      (MetricTensor[li1, li2] - (1 - GaugeXi[V[j1]]) *
+    -I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Mass[V[j1]]] *
+      (MetricTensor[li1, li2] - (1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[V[j1]]) *
          FourVector[mom, li1] FourVector[mom, li2] *
-         PropagatorDenominator[mom, Sqrt[GaugeXi[V[j1]]] Mass[V[j1]]]),
-
+         HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Sqrt[HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[V[j1]]] Mass[V[j1]]]),
 	(* general mixing scalar-vector propagator: *)
-
   AnalyticalPropagator[Internal][ s1 SV[j1, mom, {li1} -> {li2}] ] == 
-    I Mass[SV[j1]] PropagatorDenominator[mom, Mass[SV[j1]]] *
+    I Mass[SV[j1]] HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Mass[SV[j1]]] *
       FourVector[mom, If[s1 == 1 || s1 == -2, li1, li2]],
-
 	(* general scalar propagator: *)
-
   AnalyticalPropagator[External][ s1 S[j1, mom] ] == 1,
-
   AnalyticalPropagator[Internal][ s1 S[j1, mom] ] ==
-    I PropagatorDenominator[mom, Sqrt[GaugeXi[S[j1]]] Mass[S[j1]]],
-
+    I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Sqrt[HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[S[j1]]] Mass[S[j1]]],
 	(* general Fadeev-Popov ghost propagator: *)
-
   AnalyticalPropagator[External][ s1 U[j1, mom] ] == 1,
-
   AnalyticalPropagator[Internal][ s1 U[j1, mom] ] ==
-    I PropagatorDenominator[mom, Sqrt[GaugeXi[U[j1]]] Mass[U[j1]]]
+    I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Sqrt[HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[U[j1]]] Mass[U[j1]]]
 }
-
 	(* Definition of the generic couplings.
 	   The couplings must be defined as a Dot product of the (generic)
 	   coupling vector G[+/-][ field1, field2, .. ] and the
@@ -119,58 +89,43 @@ M$GenericPropagators = {
 	      are present in the generic coupling. Again, it is possible
 	      to define flippings that change the sign of Gamma and to
 	      take care for those signs by using a G[-]. *)
-
 M$GenericCouplings = {
-
 	(* V-V: *)
-
   AnalyticalCoupling[ s1 V[j1, mom1, {li1}], s2 V[j2, mom2, {li2}] ] ==
     G[1][s1 V[j1], s2 V[j2]] .
       { MetricTensor[li1, li2] ScalarProduct[mom1, mom2],
         MetricTensor[li1, li2],
         FourVector[mom1, li2] FourVector[mom2, li1] },
-
 	(* S-V: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 V[j2, mom2, {li2}] ] ==
     G[1][s1 S[j1], s2 V[j2]] .
       { FourVector[mom1, li2],
         FourVector[mom2, li2] },
-
 	(* S-S: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2] ] ==
     G[1][s1 S[j1], s2 S[j2]] .
       { ScalarProduct[mom1, mom2],
         1 },
-
 	(* U-U: *)
-
   AnalyticalCoupling[ s1 U[j1, mom1], s2 U[j2, mom2] ] ==
     G[-1][s1 U[j1], s2 U[j2]] .
       { ScalarProduct[mom1, mom2],
         1 },
-
 	(* F-F: *)
-
   AnalyticalCoupling[ s1 F[j1, mom1], s2 F[j2, mom2] ] ==
     G[-1][s1 F[j1], s2 F[j2]] .
-      { NonCommutative[DiracSlash[mom1], ChiralityProjector[-1]],
-        NonCommutative[DiracSlash[mom2], ChiralityProjector[+1]],
-        NonCommutative[ChiralityProjector[-1]],
-        NonCommutative[ChiralityProjector[+1]] },
-
+      { HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracSlash[mom1], ChiralityProjector[-1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracSlash[mom2], ChiralityProjector[+1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[-1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[+1]] },
 	(* V-V-V-V: *)
-
   AnalyticalCoupling[ s1 V[j1, mom1, {li1}], s2 V[j2, mom2, {li2}], 
       s3 V[j3, mom3, {li3}], s4 V[j4, mom4, {li4}] ] ==
     G[1][s1 V[j1], s2 V[j2], s3 V[j3], s4 V[j4]] .
       { MetricTensor[li1, li2] MetricTensor[li3, li4],
         MetricTensor[li1, li3] MetricTensor[li2, li4],
         MetricTensor[li1, li4] MetricTensor[li3, li2] },
-
 	(* V-V-V: *)
-
   AnalyticalCoupling[ s1 V[j1, mom1, {li1}], s2 V[j2, mom2, {li2}], 
       s3 V[j3, mom3, {li3}] ] ==
     G[-1][s1 V[j1], s2 V[j2], s3 V[j3]] .
@@ -180,86 +135,64 @@ M$GenericCouplings = {
         MetricTensor[li1, li2] FourVector[mom3, li3],
         MetricTensor[li3, li1] FourVector[mom2, li2],
         MetricTensor[li2, li3] FourVector[mom1, li1] },
-
 	(* S-S-S-S: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2],
       s3 S[j3, mom3], s4 S[j4, mom4] ] ==
     G[1][s1 S[j1], s2 S[j2], s3 S[j3], s4 S[j4]] .
       { 1 },
-
 	(* S-S-S: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2], s3 S[j3, mom3] ] ==
     G[1][s1 S[j1], s2 S[j2], s3 S[j3]] .
       { 1 },
-
 	(* S-S-V-V: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2],
       s3 V[j3, mom3, {li3}], s4 V[j4, mom4, {li4}] ] ==
     G[1][s1 S[j1], s2 S[j2], s3 V[j3], s4 V[j4]] .
       { MetricTensor[li3, li4] },
-
 	(* S-S-V: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2],
       s3 V[j3, mom3, {li3}] ] == 
     G[-1][s1 S[j1], s2 S[j2], s3 V[j3]] .
       { FourVector[mom1, li3],
         FourVector[mom2, li3] },
-
 	(* S-V-V: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 V[j2, mom2, {li2}], 
       s3 V[j3, mom3, {li3}] ] ==
     G[1][s1 S[j1], s2 V[j2], s3 V[j3]] .
       { MetricTensor[li2, li3] },
-
 	(* F-F-V: *)
-
   AnalyticalCoupling[ s1 F[j1, mom1], s2 F[j2, mom2],
       s3 V[j3, mom3, {li3}] ] ==
     G[-1][s1 F[j1], s2 F[j2], s3 V[j3]] .
-      { NonCommutative[DiracMatrix[li3], ChiralityProjector[-1]], 
-        NonCommutative[DiracMatrix[li3], ChiralityProjector[+1]] },
+      { HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracMatrix[li3], ChiralityProjector[-1]], 
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracMatrix[li3], ChiralityProjector[+1]] },
  
 	(* F-F-S: *)
-
   AnalyticalCoupling[ s1 F[j1, mom1], s2 F[j2, mom2], s3 S[j3, mom3] ] ==
     G[1][s1 F[j1], s2 F[j2], s3 S[j3]] . 
-      { NonCommutative[ChiralityProjector[-1]],  
-        NonCommutative[ChiralityProjector[+1]] },
-
+      { HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[-1]],  
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[+1]] },
 	(* U-U-V: *)
-
   AnalyticalCoupling[ s1 U[j1, mom1], s2 U[j2, mom2],
       s3 V[j3, mom3, {li3}] ] ==
     G[1][s1 U[j1], s2 U[j2], s3 V[j3]] .
       { FourVector[mom1, li3],
         FourVector[mom2, li3] },
-
 	(* U-U-V-V: *)
-
   AnalyticalCoupling[ s1 U[j1, mom1], s2 U[j2, mom2],
       s3 V[j3, mom3, {li3}], s4 V[j4, mom4, {li4}] ] ==
     G[1][s1 U[j1], s2 U[j2], s3 V[j3], s4 V[j4]] .
       { MetricTensor[li3, li4] },
-
 	(* S-U-U: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 U[j2, mom2], s3 U[j3, mom3] ] ==
     G[1][s1 S[j1], s2 U[j2], s3 U[j3]] .
       { 1 },
-
 	(* S-S-U-U: *)
-
   AnalyticalCoupling[ s1 S[j1, mom1], s2 S[j2, mom2],
       s3 U[j3, mom3], s4 U[j4, mom4] ] ==
     G[1][s1 S[j1], s2 S[j2], s3 U[j3], s4 U[j4]] .
       { 1 }
 }
-
 	(* FlippingRules: the flipping rules determines how Dirac
 	   objects change when the order of fermion fields in the
 	   coupling is reversed. In other words, it defines how the
@@ -268,64 +201,44 @@ M$GenericCouplings = {
 	   only gamma_mu omega_pm since the others are either
 	   unchanged or not used (sigma_{mu,nu}).
 	   See Denner, Eck, Hahn, Kueblbeck, NPB 387 (1992) 467. *)
-
 M$FlippingRules =
-  NonCommutative[dm:_DiracMatrix | _DiracSlash, ChiralityProjector[pm_]] ->
-    -NonCommutative[dm, ChiralityProjector[-pm]]
-
+  HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[dm:_DiracMatrix | _DiracSlash, ChiralityProjector[pm_]] ->
+    -HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[dm, ChiralityProjector[-pm]]
 	(* TruncationRules: rule for omitting the wave functions of
 	   external Propagators defined in this file. *)
-
 M$TruncationRules = {
-  _PolarizationVector -> 1,
+  _HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector -> 1,
   _DiracSpinor -> 1,
   _MajoranaSpinor -> 1 
 }
-
 	(* LastGenericRules: the very last rules that are applied to an
 	   amplitude before it is returned by CreateFeynAmp. *)
-
 M$LastGenericRules = {
-  PolarizationVector[p_, _. mom:FourMomentum[Outgoing, _], li_] :>
-    Conjugate[PolarizationVector][p, mom, li]
+  HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[p_, _. mom:FourMomentum[Outgoing, _], li_] :>
+    Conjugate[HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector][p, mom, li]
 }
-
-
 	(* cosmetics: *)
-
 	(*  left spinor in chain + mom incoming -> \bar v
 	    left spinor in chain + mom outgoing -> \bar u
 	   right spinor in chain + mom incoming -> u
 	   right spinor in chain + mom outgoing -> v *)
-Format[
+format1[
   FermionChain[
-    NonCommutative[_[s1_. mom1_, mass1_]],
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[_[s1_. mom1_, mass1_]],
     r___,
-    NonCommutative[_[s2_. mom2_, mass2_]]] ] :=
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[_[s2_. mom2_, mass2_]]] ] :=
   Overscript[If[FreeQ[mom1, Incoming], "u", "v"], "_"][mom1, mass1] .
     r . If[FreeQ[mom2, Outgoing], "u", "v"][mom2, mass2]
-
-Format[ DiracSlash ] = "gs"
-
-Format[ DiracMatrix ] = "ga"
-
-Format[ ChiralityProjector[1] ] = SequenceForm["om", Subscript["+"]]
-
-Format[ ChiralityProjector[-1] ] = SequenceForm["om", Subscript["-"]]
-
-Format[ GaugeXi[a_] ] := SequenceForm["xi", Subscript[a]]
-
-Format[ PolarizationVector ] = "ep"
-
+format1[ DiracSlash ] = "gs"
+format1[ DiracMatrix ] = "ga"
+format1[ ChiralityProjector[1] ] = SequenceForm["om", Subscript["+"]]
+format1[ ChiralityProjector[-1] ] = SequenceForm["om", Subscript["-"]]
+format1[ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[a_] ] := SequenceForm["xi", Subscript[a]]
+format1[ HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector ] = "ep"
 Unprotect[Conjugate];
-Format[ Conjugate[a_] ] = SequenceForm[a, Superscript["*"]];
+format1[ Conjugate[a_] ] = SequenceForm[a, Superscript["*"]];
 Protect[Conjugate]
-
-Format[ MetricTensor ] = "g"
-
-Format[ ScalarProduct[a__] ] := Dot[a]
-
-Format[ FourVector[a_, b_] ] := a[b]
-
-Format[ FourVector[a_] ] := a
-
+format1[ MetricTensor ] = "g"
+format1[ ScalarProduct[a__] ] := Dot[a]
+format1[ FourVector[a_, b_] ] := a[b]
+format1[ FourVector[a_] ] := a
diff --git FeynArts-3.7/Models/MSSM.mod FeynArts-3.7/Models/MSSM.mod
index fc0fd98..a0defec 100644
--- FeynArts-3.7/Models/MSSM.mod
+++ FeynArts-3.7/Models/MSSM.mod
@@ -4,45 +4,31 @@
 		by Thomas Hahn
 		based on the Feynman rules of the MSSM by Arnd Kraft
 		last modified 13 Aug 09 by Thomas Hahn
-
 This file contains the definition of the minimal supersymmetric standard
 model for FeynArts.  It needs the Generic model file Lorentz.gen.
-
 When you change things, remember:
-
 -- All particles are arranged in classes.  For single particle
    model definitions each particle lives in its own class.
-
 -- For each class the common SelfConjugate behaviour and the
    IndexRange MUST be present in the definitions.
-
 -- IMPORTANT: The coupling matrices MUST be declared in the
    SAME order as the Generic coupling.
-
 This file introduces the following symbols:
-
 	coupling constants and masses:
 	------------------------------
 	EL:		electron charge (Thomson limit)
 	CW, SW:		cosine and sine of weak mixing angle
-
 	MW, MZ:		W, and Z masses
 	Mh0, MHH, MA0, MHp: the Higgs masses
-
 	MLE:		lepton class mass
 	ME, MM, ML:	lepton masses (e, mu, tau)
-
 	MQU:		u-type quark class mass
 	MU, MC, MT:	u-type quark masses (up, charm, top)
-
 	MQD:		d-type quark class mass
 	MD, MS, MB:	d-type quark masses (down, strange, bottom)
-
 	MSf:		sfermion mass
-
 	CKM:		quark mixing matrix
 			(set CKM = IndexDelta for no quark-mixing)
-
 	CA, SA:		{Cos, Sin}[alpha]
 	CB, SB, TB:	{Cos, Sin, Tan}[beta]
 	C2A, S2A:	{Cos, Sin}[2 alpha]
@@ -51,35 +37,25 @@ This file introduces the following symbols:
 			where alpha is the (h0, H0) mixing angle
 			and tan[beta] is the ratio of the VEVs of
 			the two Higgs doublets
-
 	ZNeu:		neutralino mixing matrix (4x4)
 	UCha, VCha:	chargino mixing matrices (2x2)
 	USf[t]:		t-type sfermion 1-2 mixing matrices (2x2)
-
 	Af[t, i]:	soft breaking parameters
 	MUE:		the H1-H2 mixing parameter
 *)
-
-
 (* $HKSign is the sign in the SU(2) covariant derivative,
    i.e. D_\mu = \partial_\mu + $HKSign I g A^a_\mu \tau^a,
    so 1 = Haber-Kane, -1 = Denner conventions *)
-
 If[ !ValueQ[$HKSign], $HKSign = 1 ]
-
 IndexRange[ Index[Generation] ] = Range[3];
 IndexRange[ Index[Colour] ] = NoUnfold[Range[3]];
 IndexRange[ Index[Sfermion] ] = Range[2];
 IndexRange[ Index[Chargino] ] = Range[2];
 IndexRange[ Index[Neutralino] ] = Range[4]
-
 IndexStyle[ Index[Generation | Chargino | Neutralino, i_Integer] ] :=
   Alph[i + 8] 
-
 IndexStyle[ Index[Sfermion, i_Integer] ] := Alph[i + 18]
-
 M$ClassesDescription = {
-
 	(* Neutrinos: I_3 = +1/2, Q = 0 *)
   F[1] == {
 	SelfConjugate -> False,
@@ -88,7 +64,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["\\nu", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* massive Leptons: I_3 = -1/2, Q = -1 *)
   F[2] == {
 	SelfConjugate -> False,
@@ -97,7 +72,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["e", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Quarks (u): I_3 = +1/2, Q = +2/3 *)
   F[3] == {
 	SelfConjugate -> False,
@@ -106,7 +80,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Quarks (d): I_3 = -1/2, Q = -1/3 *)
   F[4] == {
 	SelfConjugate -> False,
@@ -115,7 +88,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["d", Index[Generation]],
 	PropagatorType -> Straight, 
 	PropagatorArrow -> Forward },
-
 	(* Neutralinos *)
   F[11] == {
 	SelfConjugate -> True,
@@ -125,7 +97,6 @@ M$ClassesDescription = {
 	  ComposedChar["\\chi", Index[Neutralino], "0", "\\tilde"],
 	PropagatorType -> Straight,
 	PropagatorArrow -> None },
-
 	(* Charginos *)
   F[12] == {
 	SelfConjugate -> False,
@@ -135,7 +106,6 @@ M$ClassesDescription = {
 	  ComposedChar["\\chi", Index[Chargino], Null, "\\tilde"],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Gauge bosons: Q = 0 *)
   V[1] == {
 	SelfConjugate -> True,
@@ -144,7 +114,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "\\gamma",
 	PropagatorType -> Sine,
 	PropagatorArrow -> None },
-
   V[2] == {
 	SelfConjugate -> True, 
 	Indices -> {},
@@ -152,7 +121,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "Z",
 	PropagatorType -> Sine,
 	PropagatorArrow -> None },
-
 	(* Gauge bosons: Q = -1 *)
   V[3] == {
 	SelfConjugate -> False,
@@ -161,7 +129,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "W",
 	PropagatorType -> Sine,
 	PropagatorArrow -> Forward },
-
 	(* CP-even Higgs doublet: Q = 0 *)
   S[1] == {
 	SelfConjugate -> True,
@@ -170,7 +137,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["h", Null, "0"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> None },
-
   S[2] == {
 	SelfConjugate -> True,
 	Indices -> {},
@@ -178,7 +144,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["H", Null, "0"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> None },
-
 	(* CP-odd Higgs doublet: Q = 0 *)
   S[3] == {
 	SelfConjugate -> True,
@@ -187,7 +152,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["A", Null, "0"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> None },
-
   S[4] == {
 	SelfConjugate -> True,
 	Indices -> {},
@@ -195,7 +159,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["G", Null, "0"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> None },
-
 	(* charged Higgs doublet: Q = -1 *)
   S[5] == {
 	SelfConjugate -> False,
@@ -204,7 +167,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "H",
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> Forward },
-
   S[6] == {
 	SelfConjugate -> False,
 	Indices -> {},
@@ -212,7 +174,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "G",
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> Forward },
-
 	(* Sneutrinos: Q = 0 *)
   S[11] == {
 	SelfConjugate -> False,
@@ -221,7 +182,6 @@ M$ClassesDescription = {
 	  ComposedChar["\\nu", Index[Generation], Null, "\\tilde"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> Forward },
-
 	(* Sleptons: Q = -1 *)
   S[12] == {
 	SelfConjugate -> False,
@@ -230,7 +190,6 @@ M$ClassesDescription = {
 	  ComposedChar["e", Index[Generation], Index[Sfermion], "\\tilde"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> Forward },
-
 	(* Squarks (u): Q = +2/3 *)
   S[13] == {
 	SelfConjugate -> False,
@@ -239,7 +198,6 @@ M$ClassesDescription = {
 	  ComposedChar["u", Index[Generation], Index[Sfermion], "\\tilde"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> Forward },
-
 	(* Squarks (d): Q = -1/3 *)
   S[14] == {
 	SelfConjugate -> False,
@@ -248,7 +206,6 @@ M$ClassesDescription = {
 	  ComposedChar["d", Index[Generation], Index[Sfermion], "\\tilde"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> Forward },
-
 	(* Ghosts: Q = 0 *)
   U[1] == {
 	SelfConjugate -> False,
@@ -257,7 +214,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "\\gamma"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
   U[2] == {
 	SelfConjugate -> False,
 	Indices -> {},
@@ -265,7 +221,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "Z"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
 	(* Ghosts: Q = -1 *)
   U[3] == {
 	SelfConjugate -> False,
@@ -274,7 +229,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "-"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
   U[4] == {
 	SelfConjugate -> False,
 	Indices -> {},
@@ -283,7 +237,6 @@ M$ClassesDescription = {
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward }
 }
-
 MLE[1] = ME;
 MLE[2] = MM;
 MLE[3] = ML;
@@ -295,7 +248,6 @@ MQD[2] = MS;
 MQD[3] = MB;
 MQU[gen_, _] = MQU[gen];
 MQD[gen_, _] = MQD[gen]
-
 TheLabel[ F[1, {1}] ] = ComposedChar["\\nu", "e"]; 
 TheLabel[ F[1, {2}] ] = ComposedChar["\\nu", "\\mu"]; 
 TheLabel[ F[1, {3}] ] = ComposedChar["\\nu", "\\tau"]; 
@@ -308,10 +260,8 @@ TheLabel[ F[3, {3, ___}] ] = "t";
 TheLabel[ F[4, {1, ___}] ] = "d"; 
 TheLabel[ F[4, {2, ___}] ] = "s";
 TheLabel[ F[4, {3, ___}] ] = "b"
-
 TheMass[ S[11, {gen_, ___}] ] = MSf[1, 1, gen];
 TheMass[ S[typ:12 | 13 | 14, {sf_, gen_, ___}] ] := MSf[sf, typ - 10, gen]
-
 TheLabel[ S[11, {1}] ] = ComposedChar["\\nu", "e", Null, "\\tilde"];
 TheLabel[ S[11, {2}] ] = ComposedChar["\\nu", "\\mu", Null, "\\tilde"];
 TheLabel[ S[11, {3}] ] = ComposedChar["\\nu", "\\tau", Null, "\\tilde"];
@@ -333,43 +283,32 @@ TheLabel[ S[14, {sf_, 2, ___}] ] :=
   ComposedChar["s", Null, IndexStyle[sf], "\\tilde"];
 TheLabel[ S[14, {sf_, 3, ___}] ] :=
   ComposedChar["b", Null, IndexStyle[sf], "\\tilde"]
-
-GaugeXi[ V[1] ] = GaugeXi[A];
-GaugeXi[ V[2] ] = GaugeXi[Z];
-GaugeXi[ V[3] ] = GaugeXi[W];
-GaugeXi[ U[1] ] = GaugeXi[A];
-GaugeXi[ U[2] ] = GaugeXi[Z];
-GaugeXi[ U[3] ] = GaugeXi[W];
-GaugeXi[ U[4] ] = GaugeXi[W];
-GaugeXi[ S[4] ] = GaugeXi[Z];
-GaugeXi[ S[6] ] = GaugeXi[W];
-GaugeXi[ S[_Integer, ___] ] = 1
-
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[1] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[2] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[1] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[2] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[4] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[4] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[6] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[_Integer, ___] ] = 1
 M$LastModelRules = {}
-
-
 (* some short-hands for excluding classes of particles *)
-
 NoGeneration1 = ExcludeParticles ->
   {F[1|2|3|4, {1, ___}], S[11, {1, ___}], S[12|13|14, {_, 1, ___}]}
-
 NoGeneration2 = ExcludeParticles ->
   {F[1|2|3|4, {2, ___}], S[11, {2, ___}], S[12|13|14, {_, 2, ___}]}
-
 NoGeneration3 = ExcludeParticles ->
   {F[1|2|3|4, {3, ___}], S[11, {3, ___}], S[12|13|14, {_, 3, ___}]}
-
 NoSUSYParticles = ExcludeParticles ->
   {S[11], S[12], S[13], S[14], S[2], S[3], S[5], F[11], F[12]}
-
 THDMParticles = ExcludeParticles ->
   {S[11], S[12], S[13], S[14], F[11], F[12]}
-
 NoElectronHCoupling =
   ExcludeFieldPoints -> {
     FieldPoint[0][-F[2, {1}], F[2, {1}], S],
     FieldPoint[0][-F[2, {1}], F[1, {1}], S] }
-
 NoLightFHCoupling =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[2], F[2], S],
@@ -379,7 +318,6 @@ NoLightFHCoupling =
     FieldPoint[_][-F[4], F[4], S],
     FieldPoint[_][-F[4], F[3, {1, ___}], S],
     FieldPoint[_][-F[4], F[3, {2, ___}], S] }
-
 M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] == 
   {{((I/2)*EL*(CW^2 - SW^2)*$HKSign)/(CW*SW)}}, 
  C[S[4], S[6], -V[3]] == {{(EL*$HKSign)/(2*SW)}}, 
@@ -390,14 +328,14 @@ M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] ==
  C[-S[6], V[2], V[3]] == {{((-I)*EL*MW*SW)/CW}}, 
  C[V[1], -V[3], V[3]] == {{(-I)*EL}}, C[V[2], -V[3], V[3]] == 
   {{((-I)*CW*EL*$HKSign)/SW}}, C[S[4], U[3], -U[3]] == 
-  {{-(EL*MW*GaugeXi[W])/(2*SW)}}, C[S[4], U[4], -U[4]] == 
-  {{(EL*MW*GaugeXi[W])/(2*SW)}}, C[S[6], U[1], -U[3]] == 
-  {{(-I)*EL*MW*$HKSign*GaugeXi[W]}}, C[-S[6], U[1], -U[4]] == 
-  {{(-I)*EL*MW*$HKSign*GaugeXi[W]}}, C[S[6], U[2], -U[3]] == 
-  {{((I/2)*EL*MW*(-CW^2 + SW^2)*GaugeXi[W])/(CW*SW)}}, 
- C[-S[6], U[2], -U[4]] == {{((I/2)*EL*MW*(-CW^2 + SW^2)*GaugeXi[W])/
-     (CW*SW)}}, C[S[6], U[4], -U[2]] == {{((I/2)*EL*MW*GaugeXi[Z])/(CW*SW)}}, 
- C[-S[6], U[3], -U[2]] == {{((I/2)*EL*MW*GaugeXi[Z])/(CW*SW)}}, 
+  {{-(EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/(2*SW)}}, C[S[4], U[4], -U[4]] == 
+  {{(EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/(2*SW)}}, C[S[6], U[1], -U[3]] == 
+  {{(-I)*EL*MW*$HKSign*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]}}, C[-S[6], U[1], -U[4]] == 
+  {{(-I)*EL*MW*$HKSign*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]}}, C[S[6], U[2], -U[3]] == 
+  {{((I/2)*EL*MW*(-CW^2 + SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/(CW*SW)}}, 
+ C[-S[6], U[2], -U[4]] == {{((I/2)*EL*MW*(-CW^2 + SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/
+     (CW*SW)}}, C[S[6], U[4], -U[2]] == {{((I/2)*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z])/(CW*SW)}}, 
+ C[-S[6], U[3], -U[2]] == {{((I/2)*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z])/(CW*SW)}}, 
  C[-U[3], U[3], V[1]] == {{(-I)*EL}, {0}}, C[-U[4], U[4], V[1]] == 
   {{I*EL}, {0}}, C[-U[3], U[3], V[2]] == {{((-I)*CW*EL*$HKSign)/SW}, {0}}, 
  C[-U[4], U[4], V[2]] == {{(I*CW*EL*$HKSign)/SW}, {0}}, 
@@ -462,12 +400,12 @@ M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] ==
  C[S[2], V[2], V[2]] == {{(I*CBA*EL*MW)/(CW^2*SW)}}, 
  C[S[1], V[3], -V[3]] == {{(I*EL*MW*SBA)/SW}}, 
  C[S[2], V[3], -V[3]] == {{(I*CBA*EL*MW)/SW}}, 
- C[S[1], U[2], -U[2]] == {{((-I/2)*EL*MW*SBA*GaugeXi[Z])/(CW^2*SW)}}, 
- C[S[2], U[2], -U[2]] == {{((-I/2)*CBA*EL*MW*GaugeXi[Z])/(CW^2*SW)}}, 
- C[S[1], U[3], -U[3]] == {{((-I/2)*EL*MW*SBA*GaugeXi[W])/SW}}, 
- C[S[2], U[3], -U[3]] == {{((-I/2)*CBA*EL*MW*GaugeXi[W])/SW}}, 
- C[S[1], U[4], -U[4]] == {{((-I/2)*EL*MW*SBA*GaugeXi[W])/SW}}, 
- C[S[2], U[4], -U[4]] == {{((-I/2)*CBA*EL*MW*GaugeXi[W])/SW}}, 
+ C[S[1], U[2], -U[2]] == {{((-I/2)*EL*MW*SBA*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z])/(CW^2*SW)}}, 
+ C[S[2], U[2], -U[2]] == {{((-I/2)*CBA*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z])/(CW^2*SW)}}, 
+ C[S[1], U[3], -U[3]] == {{((-I/2)*EL*MW*SBA*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/SW}}, 
+ C[S[2], U[3], -U[3]] == {{((-I/2)*CBA*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/SW}}, 
+ C[S[1], U[4], -U[4]] == {{((-I/2)*EL*MW*SBA*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/SW}}, 
+ C[S[2], U[4], -U[4]] == {{((-I/2)*CBA*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/SW}}, 
  C[S[1], S[1], S[1], S[1]] == {{(((-3*I)/4)*C2A^2*EL^2)/(CW^2*SW^2)}}, 
  C[S[1], S[1], S[1], S[2]] == {{(((-3*I)/4)*C2A*EL^2*S2A)/(CW^2*SW^2)}}, 
  C[S[1], S[1], S[2], S[2]] == {{((-I/4)*EL^2*(-1 + 3*S2A^2))/(CW^2*SW^2)}}, 
@@ -1452,7 +1390,7 @@ M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] ==
       IndexDelta[o1, o2]*USf[4, j1][s2, 1])/SW^2}}, 
  C[S[14, {s1, j1, o1}], -S[14, {s2, j2, o2}], S[14, {s3, j3, o3}], 
    -S[14, {s4, j4, o4}]] == 
-  {{IndexDelta[j1, j4]*IndexDelta[j2, j3]*((-I)*GS^2*SUNTSum[o2, o3, o4, o1]*
+  {{IndexDelta[j1, j4]*IndexDelta[j2, j3]*((-I)*Gstrong^2*SUNTSum[o2, o3, o4, o1]*
         (Conjugate[USf[4, j1][s1, 1]]*USf[4, j1][s4, 1] - 
          Conjugate[USf[4, j1][s1, 2]]*USf[4, j1][s4, 2])*
         (Conjugate[USf[4, j2][s3, 1]]*USf[4, j2][s2, 1] - 
@@ -1469,7 +1407,7 @@ M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] ==
              (CB^2*MW^2*SW^2*USf[4, j1][s4, 2]*USf[4, j2][s2, 1] + 
               9*CW^2*MQD[j1]*MQD[j2]*USf[4, j1][s4, 1]*USf[4, j2][s2, 2]))))/
         (CB^2*CW^2*MW^2*SW^2)) + IndexDelta[j1, j2]*IndexDelta[j3, j4]*
-      ((-I)*GS^2*SUNTSum[o2, o1, o4, o3]*(Conjugate[USf[4, j1][s1, 1]]*
+      ((-I)*Gstrong^2*SUNTSum[o2, o1, o4, o3]*(Conjugate[USf[4, j1][s1, 1]]*
           USf[4, j1][s2, 1] - Conjugate[USf[4, j1][s1, 2]]*USf[4, j1][s2, 2])*
         (Conjugate[USf[4, j3][s3, 1]]*USf[4, j3][s4, 1] - 
          Conjugate[USf[4, j3][s3, 2]]*USf[4, j3][s4, 2]) - 
@@ -1504,7 +1442,7 @@ M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] ==
        2*SW^2*Conjugate[USf[4, j1][s1, 2]]*USf[4, j1][s2, 2]))/(CW^2*SW^2)}}, 
  C[S[14, {s1, j1, o1}], -S[14, {s2, j2, o2}], S[13, {s3, j3, o3}], 
    -S[13, {s4, j4, o4}]] == 
-  {{IndexDelta[j1, j2]*IndexDelta[j3, j4]*((-I)*GS^2*SUNTSum[o2, o1, o4, o3]*
+  {{IndexDelta[j1, j2]*IndexDelta[j3, j4]*((-I)*Gstrong^2*SUNTSum[o2, o1, o4, o3]*
         (Conjugate[USf[3, j3][s3, 1]]*USf[3, j3][s4, 1] - 
          Conjugate[USf[3, j3][s3, 2]]*USf[3, j3][s4, 2])*
         (Conjugate[USf[4, j1][s1, 1]]*USf[4, j1][s2, 1] - 
@@ -1586,7 +1524,7 @@ M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] ==
        4*SW^2*Conjugate[USf[3, j3][s3, 2]]*USf[3, j3][s4, 2]))/(CW^2*SW^2)}}, 
  C[S[13, {s1, j1, o1}], -S[13, {s2, j2, o2}], S[13, {s3, j3, o3}], 
    -S[13, {s4, j4, o4}]] == 
-  {{IndexDelta[j1, j4]*IndexDelta[j2, j3]*((-I)*GS^2*SUNTSum[o2, o3, o4, o1]*
+  {{IndexDelta[j1, j4]*IndexDelta[j2, j3]*((-I)*Gstrong^2*SUNTSum[o2, o3, o4, o1]*
         (Conjugate[USf[3, j1][s1, 1]]*USf[3, j1][s4, 1] - 
          Conjugate[USf[3, j1][s1, 2]]*USf[3, j1][s4, 2])*
         (Conjugate[USf[3, j2][s3, 1]]*USf[3, j2][s2, 1] - 
@@ -1603,7 +1541,7 @@ M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] ==
              (-2*MW^2*SB^2*SW^2*USf[3, j1][s4, 2]*USf[3, j2][s2, 1] + 
               9*CW^2*MQU[j1]*MQU[j2]*USf[3, j1][s4, 1]*USf[3, j2][s2, 2]))))/
         (CW^2*MW^2*SB^2*SW^2)) + IndexDelta[j1, j2]*IndexDelta[j3, j4]*
-      ((-I)*GS^2*SUNTSum[o2, o1, o4, o3]*(Conjugate[USf[3, j1][s1, 1]]*
+      ((-I)*Gstrong^2*SUNTSum[o2, o1, o4, o3]*(Conjugate[USf[3, j1][s1, 1]]*
           USf[3, j1][s2, 1] - Conjugate[USf[3, j1][s1, 2]]*USf[3, j1][s2, 2])*
         (Conjugate[USf[3, j3][s3, 1]]*USf[3, j3][s4, 1] - 
          Conjugate[USf[3, j3][s3, 2]]*USf[3, j3][s4, 2]) - 
@@ -1619,51 +1557,29 @@ M$CouplingMatrices = {C[S[6], -S[6], V[1]] == {{I*EL}}, C[S[6], -S[6], V[2]] ==
              (-2*MW^2*SB^2*SW^2*USf[3, j1][s2, 2]*USf[3, j3][s4, 1] + 
               9*CW^2*MQU[j1]*MQU[j3]*USf[3, j1][s2, 1]*USf[3, j3][s4, 2]))))/
         (CW^2*MW^2*SB^2*SW^2))}}}
-
-
 (* The following definitions of renormalization constants are
    for the on-shell renormalization of the MSSM in a scheme
    similar to A. Denner, Fortschr. d. Physik, 41 (1993) 4.
-
    The renormalization constants are not directly used by
    FeynArts, and hence do not restrict the generation of diagrams
    and amplitudes in any way. *)
-
 Clear[RenConst]
-
 RenConst[ dMf1[type_, j1_] ] := MassRC[F[type, {j1}]]
-
 RenConst[ dZfL1[type_, j1_, j2_] ] :=
   FieldRC[F[type, {j1}], F[type, {j2}]][[1]]
-
 RenConst[ dZfR1[type_, j1_, j2_] ] :=
   FieldRC[F[type, {j1}], F[type, {j2}]][[2]]
-
 RenConst[ dMZsq1 ] := MassRC[V[2]]
-
 RenConst[ dMWsq1 ] := MassRC[V[3]]
-
 RenConst[ dMHsq1 ] := MassRC[S[1]]
-
 RenConst[ dZAA1 ] := FieldRC[V[1]]
-
 RenConst[ dZAZ1 ] := FieldRC[V[1], V[2]]
-
 RenConst[ dZZA1 ] := FieldRC[V[2], V[1]]
-
 RenConst[ dZZZ1 ] := FieldRC[V[2]]
-
 RenConst[ dZG01 ] := FieldRC[S[2]]
-
 RenConst[ dZW1 ] := FieldRC[V[3]]
-
 RenConst[ dZGp1 ] := FieldRC[S[3]]
-
 RenConst[ dZH1 ] := FieldRC[S[1]]
-
 RenConst[ dTH1 ] := TadpoleRC[S[1]]
-
 RenConst[ dSW1 ] := -$HKSign CW^2/SW/2 (dMZsq1/MZ^2 - dMWsq1/MW^2)
-
 RenConst[ dZe1 ] := -1/2 (dZAA1 - $HKSign SW/CW dZZA1)
-
diff --git FeynArts-3.7/Models/MSSMQCD.mod FeynArts-3.7/Models/MSSMQCD.mod
index ba29f4f..5a70c8c 100644
--- FeynArts-3.7/Models/MSSMQCD.mod
+++ FeynArts-3.7/Models/MSSMQCD.mod
@@ -4,43 +4,26 @@
 		to include the strong interactions
 		by Christian Schappacher
 		last modified 13 Aug 09 by Thomas Hahn
-
 Note: The four-squark couplings are part of MSSM.mod even though
 a part of their coupling is proportional to Alfas.
-
 This file introduces the following symbols in addition to the ones in
 MSSM.mod:
-
-	GS: the strong coupling constant
-
+	Gstrong: the strong coupling constant
 	MGl: the gluino mass
 	SqrtEGl: sqrt of the gluino phase (phase of M_3)
-
 	SUNT[a, i, j]: the generators of SU(N)
 		(half the Gell-Mann matrices)
-
 	SUNTSum[i, j, k, l] = \sum_g SUNT[g, i, j] SUNT[g, k, l]
-
 	SUNF[a, b, c]: the structure constants of SU(N)
-
 	SUNF[a, b, c, d]: a short-hand for the sum
 		\sum_i SUNF[a, b, i] SUNF[i, c, d]
-
-	GaugeXi[G]: gluon gauge parameter
+	HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[G]: gluon gauge parameter
 *)
-
-
 LoadModel["MSSM"]
-
 If[ TrueQ[$NoElectroweak], M$CouplingMatrices = {} ]
-
-
 IndexRange[ Index[Gluon] ] = NoUnfold[Range[8]]
-
 M$ClassesDescription = Join[ M$ClassesDescription, {
-
 (*--- gluons -----------------------------------------------------------*)
-
   V[5] == {
 	SelfConjugate -> True,
 	Indices -> {Index[Gluon]},
@@ -48,10 +31,7 @@ M$ClassesDescription = Join[ M$ClassesDescription, {
 	PropagatorLabel -> "g",
 	PropagatorType -> Cycles,
 	PropagatorArrow -> None },
-
-
 (*--- gluon ghosts -----------------------------------------------------*)
-
   U[5] == {
 	SelfConjugate -> False,
 	Indices -> {Index[Gluon]},
@@ -60,10 +40,7 @@ M$ClassesDescription = Join[ M$ClassesDescription, {
 	PropagatorLabel -> ComposedChar["u", "g"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
-
 (*--- gluinos ----------------------------------------------------------*)
-
   F[15] == { 
 	SelfConjugate -> True,
 	Indices -> {Index[Gluon]},
@@ -71,130 +48,85 @@ M$ClassesDescription = Join[ M$ClassesDescription, {
 	PropagatorLabel -> ComposedChar["g", Null, Null, "\\tilde"],
 	PropagatorType -> Straight, 
 	PropagatorArrow -> None }
-
 } ]
-
-
 MGl[_] = MGl
-
-GaugeXi[ V[5] ] = GaugeXi[G];
-GaugeXi[ U[5] ] = GaugeXi[G]
-
-
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[5] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[G];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[5] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[G]
 M$CouplingMatrices = Join[ M$CouplingMatrices, {
-
-
 (*--- gluon-gluon-gluon-gluon ------------------------------------------*)
-
-  C[ V[5, {g1}], V[5, {g2}], V[5, {g3}], V[5, {g4}] ] == -I GS^2 * 
+  C[ V[5, {g1}], V[5, {g2}], V[5, {g3}], V[5, {g4}] ] == -I Gstrong^2 * 
     { { SUNF[g1, g3, g2, g4] - SUNF[g1, g4, g3, g2]},
       { SUNF[g1, g2, g3, g4] + SUNF[g1, g4, g3, g2]},
       {-SUNF[g1, g2, g3, g4] - SUNF[g1, g3, g2, g4]} },
-
-
 (*--- gluon-gluon-gluon ------------------------------------------------*)
-
-  C[ V[5, {g1}], V[5, {g2}], V[5, {g3}] ] == GS *
+  C[ V[5, {g1}], V[5, {g2}], V[5, {g3}] ] == Gstrong *
     { {SUNF[g1, g2, g3]} },
-
-
 (*--- ghost-ghost-gluon ------------------------------------------------*)
-
-  C[ -U[5, {g1}], U[5, {g2}], V[5, {g3}] ] == GS *
+  C[ -U[5, {g1}], U[5, {g2}], V[5, {g3}] ] == Gstrong *
     { {SUNF[g1, g2, g3]},
       {0} },
-
-
 (*--- quark-quark-gluon ------------------------------------------------*)
-
-  C[ -F[3, {j1, o1}], F[3, {j2, o2}], V[5, {g1}] ] == -I GS *
+  C[ -F[3, {j1, o1}], F[3, {j2, o2}], V[5, {g1}] ] == -I Gstrong *
     IndexDelta[j1, j2] SUNT[g1, o1, o2] * 
     { {1},
       {1} },
-
-  C[ -F[4, {j1, o1}], F[4, {j2, o2}], V[5, {g1}] ] == -I GS *
+  C[ -F[4, {j1, o1}], F[4, {j2, o2}], V[5, {g1}] ] == -I Gstrong *
     IndexDelta[j1, j2] SUNT[g1, o1, o2] *
     { {1},
       {1} },
-
-
 (*--- gluino-gluino-gluon ----------------------------------------------*)
-
-  C[ F[15, {g1}], F[15, {g2}], V[5, {g3}] ] == -GS *
+  C[ F[15, {g1}], F[15, {g2}], V[5, {g3}] ] == -Gstrong *
     SUNF[g1, g2, g3] *
     { {1},
       {1} },
-
-
 (*--- squark-squark-gluon ----------------------------------------------*)
-
-  C[ S[13, {s1, j1, o1}], -S[13, {s2, j2, o2}], V[5, {g1}] ] == -I GS *
+  C[ S[13, {s1, j1, o1}], -S[13, {s2, j2, o2}], V[5, {g1}] ] == -I Gstrong *
     { {IndexDelta[s1, s2] IndexDelta[j1, j2] SUNT[g1, o2, o1]} },
-
-  C[ S[14, {s1, j1, o1}], -S[14, {s2, j2, o2}], V[5, {g1}] ] == -I GS *
+  C[ S[14, {s1, j1, o1}], -S[14, {s2, j2, o2}], V[5, {g1}] ] == -I Gstrong *
     { {IndexDelta[s1, s2] IndexDelta[j1, j2] SUNT[g1, o2, o1]} },
-
-
 (*--- gluino-quark-squark ----------------------------------------------*)
-
-  C[ F[15, {g1}], -F[3, {j1, o1}], S[13, {s2, j2, o2}] ] == I GS *
+  C[ F[15, {g1}], -F[3, {j1, o1}], S[13, {s2, j2, o2}] ] == I Gstrong *
     Sqrt[2] SUNT[g1, o1, o2] IndexDelta[j1, j2] *
     { { Conjugate[USf[3, j1][s2, 2]] Conjugate[SqrtEGl]},
       {-Conjugate[USf[3, j1][s2, 1]] SqrtEGl} },
-
-  C[ F[15, {g1}], -F[4, {j1, o1}], S[14, {s2, j2, o2}] ] == I GS *
+  C[ F[15, {g1}], -F[4, {j1, o1}], S[14, {s2, j2, o2}] ] == I Gstrong *
     Sqrt[2] SUNT[g1, o1, o2] IndexDelta[j1, j2] *
     { { Conjugate[USf[4, j1][s2, 2]] Conjugate[SqrtEGl]},
       {-Conjugate[USf[4, j1][s2, 1]] SqrtEGl} },
-
-  C[ F[15, {g1}], F[3, {j1, o1}], -S[13, {s2, j2, o2}] ] == I GS *
+  C[ F[15, {g1}], F[3, {j1, o1}], -S[13, {s2, j2, o2}] ] == I Gstrong *
     Sqrt[2] SUNT[g1, o2, o1] IndexDelta[j1, j2] *
     { {-USf[3, j1][s2, 1] Conjugate[SqrtEGl]},
       { USf[3, j1][s2, 2] SqrtEGl} },
-
-  C[ F[15, {g1}], F[4, {j1, o1}], -S[14, {s2, j2, o2}] ] == I GS *
+  C[ F[15, {g1}], F[4, {j1, o1}], -S[14, {s2, j2, o2}] ] == I Gstrong *
     Sqrt[2] SUNT[g1, o2, o1] IndexDelta[j1, j2] *
     { {-USf[4, j1][s2, 1] Conjugate[SqrtEGl]},
       { USf[4, j1][s2, 2] SqrtEGl} },
-
-
 (*--- squark-squark-gluon-gluon ----------------------------------------*)
-
   C[ S[13, {s1, j1, o1}], -S[13, {s2, j2, o2}], V[5, {g1}], V[5, {g2}] ] ==
-    I GS^2 IndexDelta[s1, s2] IndexDelta[j1, j2] *
+    I Gstrong^2 IndexDelta[s1, s2] IndexDelta[j1, j2] *
     { {SUNT[g1, g2, o2, o1] + SUNT[g2, g1, o2, o1]} },
-
   C[ S[14, {s1, j1, o1}], -S[14, {s2, j2, o2}], V[5, {g1}], V[5, {g2}] ] ==
-    I GS^2 IndexDelta[s1, s2] IndexDelta[j1, j2] *
+    I Gstrong^2 IndexDelta[s1, s2] IndexDelta[j1, j2] *
     { {SUNT[g1, g2, o2, o1] + SUNT[g2, g1, o2, o1]} },
-
-
 (*--- squark-squark-gluon-gauge ----------------------------------------*)
-
   C[ S[13, {s1, j1, o1}], -S[13, {s2, j2, o2}], V[5, {g1}], V[1] ] ==
-    2 I EL GS IndexDelta[s1, s2] IndexDelta[j1, j2] SUNT[g1, o2, o1] *
+    2 I EL Gstrong IndexDelta[s1, s2] IndexDelta[j1, j2] SUNT[g1, o2, o1] *
     { {2/3} }, 
-
   C[ S[14, {s1, j1, o1}], -S[14, {s2, j2, o2}], V[5, {g1}], V[1] ] ==
-    2 I EL GS IndexDelta[s1, s2] IndexDelta[j1, j2] SUNT[g1, o2, o1] *
+    2 I EL Gstrong IndexDelta[s1, s2] IndexDelta[j1, j2] SUNT[g1, o2, o1] *
     { {-1/3} }, 
-
   C[ S[13, {s1, j1, o1}], -S[13, {s2, j2, o2}], V[5, {g1}], V[2] ] ==
-    2 I EL/SW/CW GS IndexDelta[j1, j2] SUNT[g1, o2, o1] *
+    2 I EL/SW/CW Gstrong IndexDelta[j1, j2] SUNT[g1, o2, o1] *
     { {1/2 Conjugate[USf[3, j1][s1, 1]] USf[3, j1][s2, 1] -
          2/3 IndexDelta[s1, s2] SW^2} }, 
-
   C[ S[14, {s1, j1, o1}], -S[14, {s2, j2, o2}], V[5, {g1}], V[2] ] ==
-    2 I EL/SW/CW GS IndexDelta[j1, j2] SUNT[g1, o2, o1] *
+    2 I EL/SW/CW Gstrong IndexDelta[j1, j2] SUNT[g1, o2, o1] *
     { {-1/2 Conjugate[USf[4, j1][s1, 1]] USf[4, j1][s2, 1] +
          1/3 IndexDelta[s1, s2] SW^2} }, 
-
   C[ S[13, {s1, j1, o1}], -S[14, {s2, j2, o2}], V[5, {g1}], V[3] ] ==
-    I EL/SW GS Sqrt[2] Conjugate[CKM[j1, j2]] SUNT[g1, o2, o1] *
+    I EL/SW Gstrong Sqrt[2] Conjugate[CKM[j1, j2]] SUNT[g1, o2, o1] *
     { {Conjugate[USf[3, j1][s1, 1]] USf[4, j2][s2, 1]} }, 
-
   C[ S[14, {s2, j2, o2}], -S[13, {s1, j1, o1}], V[5, {g1}], -V[3] ] ==
-    I EL/SW GS Sqrt[2] CKM[j1, j2] SUNT[g1, o1, o2] *
+    I EL/SW Gstrong Sqrt[2] CKM[j1, j2] SUNT[g1, o1, o2] *
     { {Conjugate[USf[4, j2][s2, 1]] USf[3, j1][s1, 1]} }
 } ]
-
diff --git FeynArts-3.7/Models/QED.gen FeynArts-3.7/Models/QED.gen
index 7183ee3..941b58c 100644
--- FeynArts-3.7/Models/QED.gen
+++ FeynArts-3.7/Models/QED.gen
@@ -5,50 +5,33 @@
 		by A. Denner, H. Eck, O. Hahn, S. Kueblbeck
 		last modified 4 May 10 by Thomas Hahn
 *)
-
-
 	(* Kinematic indices are `transported' along a propagator line.
 	   KinematicIndices[X] = {Name} means that the generic field X
 	   will carry an index Index[Name, i] along the line:  
 	   X[ n, {m..}, p, {Index[Name, i]} -> {Index[Name, i + 1]} ] *)
-
 KinematicIndices[ F ] = {};
 KinematicIndices[ V ] = {Lorentz}
-
 IndexStyle[ Index[Lorentz, i_Integer] ] := Greek[i + 11]
-
 Attributes[ MetricTensor ] = Attributes[ ScalarProduct ] = {Orderless}
-
-
 FourVector/: -FourVector[ mom_, mu___ ] := FourVector[Expand[-mom], mu]
-
 FourVector[ 0, ___ ] = 0
-
-
 M$GenericPropagators = {
-
 	(* general fermion propagator: *)
-
   AnalyticalPropagator[External][ s F[i, mom] ] == 
-    NonCommutative[
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[
       DiracSpinor[-mom, Mass[F[i]], Sequence@@ Drop[{i}, 1]] ],
-
   AnalyticalPropagator[Internal][ s F[i, mom] ] ==
-    NonCommutative[ DiracSlash[-mom] + Mass[F[i]] ] *
-      I PropagatorDenominator[mom, Mass[F[i]]], 
-
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ DiracSlash[-mom] + Mass[F[i]] ] *
+      I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Mass[F[i]]], 
 	(* general vector boson propagator: *)
-
   AnalyticalPropagator[External][ s V[i, mom, {li2}] ] ==
-    PolarizationVector[V[i], mom, li2],
-
+    HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[V[i], mom, li2],
   AnalyticalPropagator[Internal][ s V[i, mom, {li1} -> {li2}] ] ==
-    -I PropagatorDenominator[mom, Mass[V[i]]] *
-      (MetricTensor[li1, li2] - (1 - GaugeXi[V[i]]) *
+    -I HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Mass[V[i]]] *
+      (MetricTensor[li1, li2] - (1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[V[i]]) *
          FourVector[mom, li1] FourVector[mom, li2] *
-         PropagatorDenominator[mom, Sqrt[GaugeXi[V[i]]] Mass[V[i]]])
+         HighEnergyPhysics`FeynCalc`PropagatorDenominator`PropagatorDenominator[mom, Sqrt[HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[V[i]]] Mass[V[i]]])
 }
-
 	(* Definition of the generic couplings.
 	   The couplings must be defined as a Dot product of the (generic)
 	   coupling vector G[+/-][ field1, field2, .. ] and the
@@ -72,35 +55,27 @@ M$GenericPropagators = {
 	      are present in the generic coupling. Again, it is possible
 	      to define flippings that change the sign of Gamma and to
 	      take care for those signs by using a G[-]. *)
-
 M$GenericCouplings = {
-
         (* F-F: *)
-
   AnalyticalCoupling[ s1 F[i, mom1], s2 F[j, mom2] ] ==
     G[1][s1 F[i], s2 F[j]] .
-      { NonCommutative[DiracSlash[mom1], ChiralityProjector[-1]],
-        NonCommutative[DiracSlash[mom2], ChiralityProjector[+1]],
-        NonCommutative[ChiralityProjector[-1]],
-        NonCommutative[ChiralityProjector[+1]] },
-
+      { HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracSlash[mom1], ChiralityProjector[-1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracSlash[mom2], ChiralityProjector[+1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[-1]],
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[ChiralityProjector[+1]] },
 	(* V-V: *)
-
   AnalyticalCoupling[ s1 V[i, mom1, {li1}], s2 V[j, mom2, {li2}] ] ==
     G[1][s1 V[i], s2 V[j]] .
       { MetricTensor[li1, li2] ScalarProduct[mom1, mom2],
         MetricTensor[li1, li2],
         FourVector[mom1, li2] FourVector[mom2, li1] },
-
 	(* F-F-V: *)
-
   AnalyticalCoupling[ s1 F[i, mom1], s2 F[j, mom2],
       s3 V[k, mom3, {li3}] ] ==
     G[-1][s1 F[i], s2 F[j], s3 V[k]] .
-      { NonCommutative[DiracMatrix[li3], ChiralityProjector[-1]], 
-        NonCommutative[DiracMatrix[li3], ChiralityProjector[+1]] }
+      { HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracMatrix[li3], ChiralityProjector[-1]], 
+        HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[DiracMatrix[li3], ChiralityProjector[+1]] }
 }
-
 	(* FlippingRules: the flipping rules determines how Dirac
 	   objects change when the order of fermion fields in the
 	   coupling is reversed. In other words, it defines how the
@@ -109,63 +84,43 @@ M$GenericCouplings = {
 	   only gamma_mu omega_pm since the others are either
 	   unchanged or not used (sigma_{mu,nu}).
 	   See Denner, Eck, Hahn, Kueblbeck, NPB 387 (1992) 467. *)
-
 M$FlippingRules =
-  NonCommutative[dm:_DiracMatrix | _DiracSlash, ChiralityProjector[pm_]] ->
-    -NonCommutative[dm, ChiralityProjector[-pm]]
-
+  HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[dm:_DiracMatrix | _DiracSlash, ChiralityProjector[pm_]] ->
+    -HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[dm, ChiralityProjector[-pm]]
 	(* TruncationRules: rule for omitting the wave functions of
 	   external Propagators defined in this file. *)
-
 M$TruncationRules = {
-  _PolarizationVector -> 1,
+  _HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector -> 1,
   _DiracSpinor -> 1
 }
-
 	(* LastGenericRules: the very last rules that are applied to an
 	   amplitude before it is returned by CreateFeynAmp. *)
-
 M$LastGenericRules = {
 	(* relicts of the truncation of spinors: *)
   Dot[1, line__, 1] :> Dot[line],
   Dot[1, 1] :> 1,
 	(* outgoing vector bosons: throw away signs of momenta *)
-  PolarizationVector[p_, _. k:FourMomentum[Outgoing, _], li_] :>
-    Conjugate[PolarizationVector][p, k, li]
+  HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector[p_, _. k:FourMomentum[Outgoing, _], li_] :>
+    Conjugate[HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector][p, k, li]
 }
-
-
 	(* cosmetics: *)
-
-Format[
+format1[
   FermionChain[
-    NonCommutative[_[s1_. mom1_, mass1_]],
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[_[s1_. mom1_, mass1_]],
     r___,
-    NonCommutative[_[s2_. mom2_, mass2_]]] ] :=
+    HighEnergyPhysics`FeynCalc`NonCommutative`NonCommutative[_[s2_. mom2_, mass2_]]] ] :=
   Overscript[If[FreeQ[mom1, Incoming], "u", "v"], "_"][mom1, mass1] .
     r . If[FreeQ[mom2, Outgoing], "u", "v"][mom2, mass2]
-
-Format[ DiracSlash ] = "gs"
-
-Format[ DiracMatrix ] = "ga"
-
-Format[ ChiralityProjector[1] ] = SequenceForm["om", Subscript["+"]]
-
-Format[ ChiralityProjector[-1] ] = SequenceForm["om", Subscript["-"]]
-
-Format[ GaugeXi[a_] ] := SequenceForm["xi", Subscript[a]]
-
-Format[ PolarizationVector ] = "ep"
-
+format1[ DiracSlash ] = "gs"
+format1[ DiracMatrix ] = "ga"
+format1[ ChiralityProjector[1] ] = SequenceForm["om", Subscript["+"]]
+format1[ ChiralityProjector[-1] ] = SequenceForm["om", Subscript["-"]]
+format1[ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[a_] ] := SequenceForm["xi", Subscript[a]]
+format1[ HighEnergyPhysics`FeynCalc`PolarizationVector`PolarizationVector ] = "ep"
 Unprotect[Conjugate];
-Format[ Conjugate[a_] ] := SequenceForm[a, Superscript["*"]];
+format1[ Conjugate[a_] ] := SequenceForm[a, Superscript["*"]];
 Protect[Conjugate]
-
-Format[ MetricTensor ] = "g"
-
-Format[ ScalarProduct[a__] ] := Dot[a]
-
-Format[ FourVector[a_, b_] ] := a[b]
-
-Format[ FourVector[a_] ] := a
-
+format1[ MetricTensor ] = "g"
+format1[ ScalarProduct[a__] ] := Dot[a]
+format1[ FourVector[a_, b_] ] := a[b]
+format1[ FourVector[a_] ] := a
diff --git FeynArts-3.7/Models/QED.mod FeynArts-3.7/Models/QED.mod
index f48b223..993d9b9 100644
--- FeynArts-3.7/Models/QED.mod
+++ FeynArts-3.7/Models/QED.mod
@@ -3,41 +3,24 @@
 		Classes model file for leptons-only QED
 		by Hagen Eck and Sepp Kueblbeck
 		last modified 6 Mar 07 by Thomas Hahn
-
-
 This file introduces the following symbols:
-
 	coupling constants and masses:
 	------------------------------
 	EL:		electron charge (Thomson limit)
-
 	MLE:		lepton class mass
 	ME, MM, ML:	lepton masses (e, mu, tau)
-
-	GaugeXi[A]:	photon gauge parameter
-
-
+	HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A]:	photon gauge parameter
 	one-loop renormalization constants (RCs):
 	-----------------------------------------
 	dZe1:		electromagnetic charge RC
-
 	dZAA1:		photon field RC
-
 	dMf1:		fermion mass RCs
 	dZfL1, dZfR1:	fermion field RCs
 *)
-
-
 IndexRange[ Index[Generation] ] = {1, 2, 3}
-
 IndexStyle[ Index[Generation, i_Integer] ] := Alph[i + 8]
-
-
 ViolatesQ[ q__ ] := Plus[q] =!= 0
-
-
 M$ClassesDescription = {
-
 	(* Leptons (e, mu, tau)
 	   note that in SM.mod the leptons live in class 2 (F[2]) *)
   F[1] == {
@@ -48,7 +31,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["e", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Photon *)
   V[1] == {
 	SelfConjugate -> True,
@@ -57,71 +39,46 @@ M$ClassesDescription = {
 	PropagatorType -> Sine,
 	PropagatorArrow -> None }
 }
-
 MLE[1] = ME;
 MLE[2] = MM;
 MLE[3] = ML
-
 TheLabel[ F[1, {1}] ] = "e";
 TheLabel[ F[1, {2}] ] = "\\mu";
 TheLabel[ F[1, {3}] ] = "\\tau"
-
-GaugeXi[ V[1] ] = GaugeXi[A]
-
-
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[1] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A]
 	(* the nomenclature has been kept compatible with SM.mod even
 	   though some indices are unnecessary since everything is
 	   flavour-diagonal here *)
-
 mdZfLR1[ type_, j1_ ] :=
   Mass[F[type, j1]]/2 *
     (dZfL1[type, j1, j1] + Conjugate[dZfR1[type, j1, j1]])
-
 mdZfRL1[ type_, j1_ ] :=
   Mass[F[type, j1]]/2 *
     (dZfR1[type, j1, j1] + Conjugate[dZfL1[type, j1, j1]])
-
 dZfL1cc[ type_, j1_ ] :=
   dZfL1[type, j1, j1]/2 + Conjugate[dZfL1[type, j1, j1]]/2
-
 dZfR1cc[ type_, j1_ ] :=
   dZfR1[type, j1, j1]/2 + Conjugate[dZfR1[type, j1, j1]]/2
-
-
 M$CouplingMatrices = {
-
 	(* F-F:  G(+) . { slash[mom1] omega[-], slash[mom2] omega[+],
 	                  omega[-], omega[+] } *)
-
   C[ -F[1, {j1}], F[1, {j2}] ] == I IndexDelta[j1, j2] *
     { {0, -dZfL1cc[1, j1]},
       {0, dZfR1cc[1, j1]},
       {0, -mdZfLR1[1, j1] - dMf1[1, j1]},
       {0, -mdZfRL1[1, j1] - dMf1[1, j1]} },
-
 	(* V-V:  G(+) . { -g[mu, nu] mom^2, g[mu, nu], -mom[mu] mom[nu] } *)
-
   C[ V[1], V[1] ] == I * 
     { {0, dZAA1},
       {0, 0},
       {0, -dZAA1} },
-
 	(* F-F-V:  G(-) . { gamma[mu3] omega[-], gamma[mu3] omega[+] } *)
-
   C[ -F[1, {j1}], F[1, {j2}], V[1] ] == I EL IndexDelta[j1, j2] *
     { {1, dZe1 + dZAA1/2 + dZfL1cc[1, j1]},
       {1, dZe1 + dZAA1/2 + dZfR1cc[1, j1]} }
 }
-
-
 M$LastModelRules = {}
-
-
 (* some short-hands for excluding classes of particles *)
-
 NoGeneration1 = ExcludeParticles -> F[_, {1}]
-
 NoGeneration2 = ExcludeParticles -> F[_, {2}]
-
 NoGeneration3 = ExcludeParticles -> F[_, {3}]
-
diff --git FeynArts-3.7/Models/SM.mod FeynArts-3.7/Models/SM.mod
index 61793ac..2d73d05 100644
--- FeynArts-3.7/Models/SM.mod
+++ FeynArts-3.7/Models/SM.mod
@@ -3,26 +3,19 @@
 		Classes model file for the Standard Model
 		by Hagen Eck and Sepp Kueblbeck 1995
 		last modified 4 May 10 by Thomas Hahn
-
 This file contains the definition of a Classes model for FeynArts.
 It needs the Generic model file Lorentz.gen.
-
 When you change things, remember:
-
 -- All particles are arranged in classes. For single particle
    model definitions each particle lives in its own class.
-
 -- For each class the common SelfConjugate behaviour and the
    IndexRange MUST be present in the definitions.
-
 -- IMPORTANT: The coupling matrices MUST be declared in the
    SAME order as the Generic coupling.
-
 Reference:
 	Ansgar Denner, "Techniques for the calculation of electroweak
 	radiative corrections at one-loop level and results for
 	W-physics at LEP200", Fortschr. d. Physik, 41 (1993) 4
-
 Oct 95: one-loop counter terms added by Stefan Bauberger:
 	Some corrections and addition of all one-loop counter terms
 	according to A. Denner.  The gauge-fixing terms are assumed not
@@ -30,9 +23,7 @@ Oct 95: one-loop counter terms added by Stefan Bauberger:
 	include field renormalization of the Goldstone bosons.
 	The counter terms associated with quark mixing are not well
 	tested yet.
-
 Apr 99: Christian Schappacher added colour indices for the quarks
-
 Apr 99:	Terms for ghost sector updated by Ayres Freitas.
 	The gauge-fixing terms are still assumed not to be renormalized
 	but the renormalized gauge parameters follow the R_xi-gauge.
@@ -40,106 +31,70 @@ Apr 99:	Terms for ghost sector updated by Ayres Freitas.
 	The 2-loop counter terms for vector-boson selfenergies and for
 	the W-nu-l vertex have been added.
 	Old versions of the changes of sbau are removed!
-
 Apr 01:	Thomas Hahn added the definitions of the renormalization
 	constants a la A. Denner.
-
 This file introduces the following symbols:
-
 	coupling constants and masses:
 	------------------------------
 	EL:		electron charge (Thomson limit)
 	CW, SW:		cosine and sine of Weinberg angle
-
 	MW, MZ, MH:	W, Z, Higgs masses
-
 	MLE:		lepton class mass
 	ME, MM, ML:	lepton masses (e, mu, tau)
-
 	MQU:		u-type quark class mass
 	MU, MC, MT:	u-type quark masses (up, charm, top)
-
 	MQD:		d-type quark class mass
 	MD, MS, MB:	d-type quark masses (down, strange, bottom)
-
 	CKM:		quark mixing matrix
 			(set CKM = IndexDelta for no quark-mixing)
-
-	GaugeXi[A, W, Z]: photon, W, Z gauge parameters
-
-
+	HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A, W, Z]: photon, W, Z gauge parameters
 	one-loop renormalization constants (RCs):
 	-----------------------------------------
 	dZe1:		electromagnetic charge RC
 	dSW1, dCW1:	Weinberg angle sine/cosine RC
-
 	dZH1, dMHsq1:	Higgs field and mass RC
 	dZW1, dMWsq1:	W field and mass RC
 	dMZsq1:		Z mass RC
 	dZZZ1, dZZA1,
 	dZAZ1, dZAA1:	Z and photon field RCs
-
 	dMf1:		fermion mass RCs
 	dZfL1, dZfR1:	fermion field RCs
-
 	dCKM1:		quark mixing matrix RCs
-
 	dZG01, dZGp1:	field RC for unphysical scalars
 	dUZZ1, dUZA1,
 	dUAZ1, dUAA1:	field RCs for photon and Z ghosts
 	dUW1:		field RC for +/- ghosts
-
 	two-loop renormalization constants:
 	-----------------------------------
 	dZe2:           electromagnetic charge RC
 	dSW2:           weak mixing angle sine/cosine RC
-
 	dZW2, dMWsq2:	W field and mass RC
 	dMZsq2:		Z mass RC
 	dZZZ2, dZZA2,
 	dZAZ2, dZAA2:	Z and photon field RCs
-
 	dZfL2:		fermion field RCs
 *)
-
-
 IndexRange[ Index[Generation] ] = Range[3]
-
 IndexRange[ Index[Colour] ] = NoUnfold[Range[3]]
-
 IndexStyle[ Index[Generation, i_Integer] ] := Alph[i + 8]
-
 MaxGenerationIndex = 3
-
-
 ViolatesQ[ q__ ] := Plus[q] =!= 0
-
-
 mdZfLR1[ type_, j1_, j2_ ] :=
   Mass[F[type, {j1}]]/2 dZfL1[type, j1, j2] +
     Mass[F[type, {j2}]]/2 Conjugate[dZfR1[type, j2, j1]]
-
 mdZfRL1[ type_, j1_, j2_ ] :=
   Mass[F[type, {j1}]]/2 dZfR1[type, j1, j2] +
     Mass[F[type, {j2}]]/2 Conjugate[dZfL1[type, j2, j1]]
-
-
 (* the leptonic field RCs are diagonal: *)
-
 dZfL1[ type:1 | 2, j1_, j2_ ] :=
   IndexDelta[j1, j2] dZfL1[type, j1, j1] /; j1 =!= j2
-
 dZfR1[ type:1 | 2, j1_, j2_ ] :=
   IndexDelta[j1, j2] dZfR1[type, j1, j1] /; j1 =!= j2
-
-
 (* some short-hands for fermionic couplings: *)
-
 FermionCharge[1] = 0;
 FermionCharge[2] = -1;
 FermionCharge[3] = 2/3;
 FermionCharge[4] = -1/3
-
 gR[ type_ ] :=
   -SW/CW FermionCharge[type];
 gL[ type_ ] :=
@@ -149,10 +104,7 @@ dgR[ type_ ] :=
 dgL[ type_ ] :=
   If[ OddQ[type], 1/2, -1/2 ]/(SW CW) *
     (dZe1 + (SW^2 - CW^2)/(CW^2 SW) dSW1) + dgR[type]
-
-
 M$ClassesDescription = {
-
 	(* Leptons (neutrino): I_3 = +1/2, Q = 0 *)
   F[1] == {
 	SelfConjugate -> False,
@@ -162,7 +114,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["\\nu", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Leptons (electron): I_3 = -1/2, Q = -1 *)
   F[2] == {
 	SelfConjugate -> False,
@@ -172,7 +123,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["e", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Quarks (u): I_3 = +1/2, Q = +2/3 *)
   F[3] == {
 	SelfConjugate -> False,
@@ -182,7 +132,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Quarks (d): I_3 = -1/2, Q = -1/3 *) 
   F[4] == {
 	SelfConjugate -> False,
@@ -192,7 +141,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["d", Index[Generation]],
 	PropagatorType -> Straight, 
 	PropagatorArrow -> Forward },
-
 	(* Gauge bosons: Q = 0 *)
   V[1] == {
 	SelfConjugate -> True,
@@ -201,7 +149,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "\\gamma",
 	PropagatorType -> Sine,
 	PropagatorArrow -> None },
-
   V[2] == {
 	SelfConjugate -> True, 
 	Indices -> {},
@@ -209,7 +156,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "Z",
 	PropagatorType -> Sine,
 	PropagatorArrow -> None },
-
 	(* Gauge bosons: Q = -1 *)
   V[3] == {
 	SelfConjugate -> False,
@@ -219,7 +165,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "W",
 	PropagatorType -> Sine,
 	PropagatorArrow -> Forward },
-
 (*
   V[4] == {
 	SelfConjugate -> True,
@@ -230,7 +175,6 @@ M$ClassesDescription = {
 	PropagatorType -> Sine,
 	PropagatorArrow -> None },
 *)
-
 	(* mixing Higgs gauge bosons: Q = 0 *) 
   SV[2] == {
 	SelfConjugate -> True,
@@ -240,7 +184,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> {ComposedChar["G", Null, "0"], "Z"},
 	PropagatorType -> {ScalarDash, Sine},
 	PropagatorArrow -> None },
-
 	(* mixing Higgs gauge bosons: charged *) 
   SV[3] == {
 	SelfConjugate -> False,
@@ -251,7 +194,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> {"G", "W"},
 	PropagatorType -> {ScalarDash, Sine},
 	PropagatorArrow -> Forward },
-
 	(* physical Higgs: Q = 0 *) 
   S[1] == {
 	SelfConjugate -> True,
@@ -260,7 +202,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "H",
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> None },
-
 	(* unphysical Higgs: neutral *) 
   S[2] == {
 	SelfConjugate -> True,
@@ -269,7 +210,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["G", Null, "0"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> None },
-
 	(* unphysical Higgs: Q = -1 *)  
   S[3] == {
 	SelfConjugate -> False,
@@ -279,7 +219,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "G",
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> Forward },
-
 	(* Ghosts: neutral *) 
   U[1] == {
 	SelfConjugate -> False,
@@ -289,7 +228,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "\\gamma"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
   U[2] == {
 	SelfConjugate -> False,
 	Indices -> {},
@@ -298,7 +236,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "Z"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
 	(* Ghosts: charged *) 
   U[3] == {
 	SelfConjugate -> False,
@@ -308,7 +245,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "-"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
   U[4] == {
 	SelfConjugate -> False,
 	Indices -> {},
@@ -318,7 +254,6 @@ M$ClassesDescription = {
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward }
 }
-
 MLE[1] = ME;
 MLE[2] = MM;
 MLE[3] = ML;
@@ -330,7 +265,6 @@ MQD[2] = MS;
 MQD[3] = MB;
 MQU[gen_, _] := MQU[gen];
 MQD[gen_, _] := MQD[gen]
-
 TheLabel[ F[1, {1}] ] = ComposedChar["\\nu", "e"]; 
 TheLabel[ F[1, {2}] ] = ComposedChar["\\nu", "\\mu"]; 
 TheLabel[ F[1, {3}] ] = ComposedChar["\\nu", "\\tau"]; 
@@ -343,38 +277,30 @@ TheLabel[ F[3, {3, ___}] ] = "t";
 TheLabel[ F[4, {1, ___}] ] = "d"; 
 TheLabel[ F[4, {2, ___}] ] = "s";
 TheLabel[ F[4, {3, ___}] ] = "b"
-
-GaugeXi[ V[1] ] = GaugeXi[A];
-GaugeXi[ V[2] ] = GaugeXi[Z];
-GaugeXi[ V[3] ] = GaugeXi[W];
-GaugeXi[ S[1] ] = 1;
-GaugeXi[ S[2] ] = GaugeXi[Z];
-GaugeXi[ S[3] ] = GaugeXi[W];
-GaugeXi[ U[1] ] = GaugeXi[A];
-GaugeXi[ U[2] ] = GaugeXi[Z];
-GaugeXi[ U[3] ] = GaugeXi[W];
-GaugeXi[ U[4] ] = GaugeXi[W]
-
-
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[1] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[2] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[1] ] = 1;
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[2] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[1] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[2] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[4] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]
 M$CouplingMatrices = {
-
 	(* V-V:  G(+) . { -g[mu, nu] mom^2, g[mu, nu], -mom[mu] mom[nu] } *)
-
   C[ -V[3], V[3] ] == I *
     { {0, dZW1, dZW2},
       {0, MW^2 dZW1 + dMWsq1, MW^2 dZW2 + dMWsq2 + dMWsq1 dZW1},
       {0, -dZW1, -dZW2} },
-
   C[ V[2], V[2] ] == I *
     { {0, dZZZ1, dZZZ2 + 1/4 dZAZ1^2},
       {0, MZ^2 dZZZ1 + dMZsq1, MZ^2 dZZZ2 + dMZsq2 + dMZsq1 dZZZ1},
       {0, -dZZZ1, -dZZZ2 - 1/4 dZAZ1^2} },
-
   C[ V[1], V[1] ] == I *
     { {0, dZAA1, dZAA2 + 1/4 dZZA1^2},
       {0, 0, 1/4 MZ^2 dZZA1^2},
       {0, -dZAA1, -dZAA2 - 1/4 dZZA1^2} },
-
   C[ V[1], V[2] ] == I *
     { {0, dZAZ1/2 + dZZA1/2,
     	  (dZAZ2 + dZZA2 + 1/2 dZZA1 dZZZ1 + 1/2 dZAZ1 dZAA1)/2},
@@ -382,48 +308,37 @@ M$CouplingMatrices = {
           (MZ^2 dZZA2 + 1/2 MZ^2 dZZZ1 dZZA1 + dMZsq1 dZZA1)/2},
       {0, -dZAZ1/2 - dZZA1/2,
           -(dZAZ2 + dZZA2 + 1/2 dZZA1 dZZZ1 + 1/2 dZAZ1 dZAA1)/2} },
-
 	(* S-V:  G(+) . { mom1[mu], mom2[mu] } *)
-
   C[ S[3], -V[3] ] == I MW/4 *
     { {0, -dZW1 - dZGp1 - dMWsq1/MW^2},
       {0, dZW1 + dZGp1 + dMWsq1/MW^2} },
-
   C[ -S[3], V[3] ] == I MW/4 *
     { {0, dZW1 + dZGp1 + dMWsq1/MW^2},
       {0, -dZW1 - dZGp1 - dMWsq1/MW^2} },
-
   C[ S[2], V[2] ] == MZ/4 *
     { {0, dZZZ1 + dZG01 + dMZsq1/MZ^2},
       {0, -dZZZ1 - dZG01 - dMZsq1/MZ^2} },
-
   C[ S[2], V[1] ] == MZ/4 *
     { {0, dZZA1},
       {0, -dZZA1} },
-
 	(* S-S:  G(+) . { -mom^2, 1 } *)
-
   C[ S[1], S[1] ] == -I *
     { {0, dZH1},
       {0, dMHsq1 + MH^2 dZH1} },
-
   C[ S[2], S[2] ] == -I *
     { {0, dZG01},
       {0, -EL/(2 MW SW) dTH1} },
-
   C[ S[3], -S[3] ] == -I *
     { {0, dZGp1},
       {0, -EL/(2 MW SW) dTH1} },
-
 	(* U-U:  G(+) . { -mom^2, 1 } *)
-
   C[ U[1], -U[1] ] == -I *
     { {0, -dZAA1/2 + dUAA1},
       {0, 0} },
   
   C[ U[2], -U[2] ] == -I *
     { {0, -dZZZ1/2 + dUZZ1},
-      {0, GaugeXi[Z] (MZ^2 (-dZG01/2 + dUZZ1) + dMZsq1/2) } },
+      {0, HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z] (MZ^2 (-dZG01/2 + dUZZ1) + dMZsq1/2) } },
   
   C[ U[2], -U[1] ] == -I *
     { {0, -dZAZ1/2 + dUAZ1},
@@ -431,57 +346,47 @@ M$CouplingMatrices = {
   
   C[ U[1], -U[2] ] == -I *
     { {0, -dZZA1/2 + dUZA1},
-      {0, GaugeXi[Z] MZ^2 dUZA1} },
+      {0, HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z] MZ^2 dUZA1} },
   
   C[ U[3], -U[3] ] == -I *
     { {0, -dZW1/2 + dUW1},
-      {0, GaugeXi[W] (MW^2 (-dZGp1/2 + dUW1) + dMWsq1/2) } },
-
+      {0, HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W] (MW^2 (-dZGp1/2 + dUW1) + dMWsq1/2) } },
   C[ U[4], -U[4] ] == -I *
     { {0, -dZW1/2 + dUW1},
-      {0, GaugeXi[W] (MW^2 (-dZGp1/2 + dUW1) + dMWsq1/2) } },
-
+      {0, HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W] (MW^2 (-dZGp1/2 + dUW1) + dMWsq1/2) } },
 	(* F-F:  G(+) . { slash[mom1] omega[-], slash[mom2] omega[+],
 	                  omega[-], omega[+] } *)
-
   C[ -F[1, {j1}], F[1, {j2}] ] == I *
     { {0, -AddHC[dZfL1[1, j1, j2]]},
       {0, AddHC[dZfR1[1, j1, j2]]},
       {0, 0},
       {0, 0} },
-
   C[ -F[2, {j1}], F[2, {j2}] ] == I *
     { {0, -AddHC[dZfL1[2, j1, j2]]},
       {0, AddHC[dZfR1[2, j1, j2]]},
       {0, -mdZfLR1[2, j1, j2] - IndexDelta[j1, j2] dMf1[2, j1]},
       {0, -mdZfRL1[2, j1, j2] - IndexDelta[j1, j2] dMf1[2, j1]} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}] ] == I IndexDelta[o1, o2] *
     { {0, -AddHC[dZfL1[3, j1, j2]]},
       {0, AddHC[dZfR1[3, j1, j2]]},
       {0, -mdZfLR1[3, j1, j2] - IndexDelta[j1, j2] dMf1[3, j1]},
       {0, -mdZfRL1[3, j1, j2] - IndexDelta[j1, j2] dMf1[3, j1]} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}] ] == I IndexDelta[o1, o2] *
     { {0, -AddHC[dZfL1[4, j1, j2]]},
       {0, AddHC[dZfR1[4, j1, j2]]},
       {0, -mdZfLR1[4, j1, j2] - IndexDelta[j1, j2] dMf1[4, j1]},
       {0, -mdZfRL1[4, j1, j2] - IndexDelta[j1, j2] dMf1[4, j1]} },
-
 	(* V-V-V-V:  G(+) . { g[mu1, mu2] g[mu3, mu4],
 	                      g[mu1, mu4] g[mu2, mu3],
 	                      g[mu1, mu3] g[mu2, mu4] } *)
-
   C[ -V[3], -V[3], V[3], V[3] ] == I EL^2/SW^2 *
     { {2, 4 dZe1 - 4 dSW1/SW + 4 dZW1}, 
       {-1, -2 dZe1 + 2 dSW1/SW - 2 dZW1},
       {-1, -2 dZe1 + 2 dSW1/SW - 2*dZW1} },
-
   C[ -V[3], V[3], V[2], V[2] ] == -I EL^2 CW^2/SW^2 *
     { {2, 4 dZe1 - 4 dSW1/(SW CW^2) + 2 dZW1 + 2 dZZZ1 - 2 dZAZ1 SW/CW}, 
       {-1, -2 dZe1 + 2 dSW1/(SW CW^2) - dZW1 - dZZZ1 + dZAZ1 SW/CW},
       {-1, -2 dZe1 + 2 dSW1/(SW CW^2) - dZW1 - dZZZ1 + dZAZ1 SW/CW} },
-
   C[ -V[3], V[3], V[1], V[2] ] == I EL^2 CW/SW *
     { {2, 4 dZe1 - 2 dSW1/(SW CW^2) + 2 dZW1 +
             dZZZ1 + dZAA1 - SW/CW dZAZ1 - CW/SW dZZA1},
@@ -489,50 +394,37 @@ M$CouplingMatrices = {
             dZZZ1/2 - dZAA1/2 + SW/CW dZAZ1/2 + CW/SW dZZA1/2},
       {-1, -2 dZe1 + dSW1/(SW CW^2) - dZW1 -
             dZZZ1/2 - dZAA1/2 + SW/CW dZAZ1/2 + CW/SW dZZA1/2} },
-
   C[ -V[3], V[3], V[1], V[1] ] == -I EL^2 *
     { {2, 4 dZe1 + 2 dZW1 + 2 dZAA1 - 2 CW/SW dZZA1}, 
       {-1, -2 dZe1 - dZW1 - dZAA1 + CW/SW dZZA1},
       {-1, -2 dZe1 - dZW1 - dZAA1 + CW/SW dZZA1} },
-
 	(* V-V-V:  G(-) . (g[mu1, mu2] (p2 - p1)_mu3 +
 	                   g[mu2, mu3] (p3 - p2)_mu1 +
 	                   g[mu3, mu1] (p1 - p3)_mu2) *)
-
   C[ V[1], -V[3], V[3] ] == -I EL *
     { {1, dZe1 + dZW1 + dZAA1/2 - CW/SW dZZA1/2} },
-
   C[ V[2], -V[3], V[3] ] == I EL CW/SW *
     { {1, dZe1 - dSW1/(SW CW^2) + dZW1 + dZZZ1/2 - SW/CW dZAZ1/2} },
-
 	(* S-S-S-S:  G(+) . 1 *)
-
   C[ S[1], S[1], S[1], S[1] ] == -3 I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + 2 dZH1} },
-
   C[ S[1], S[1], S[2], S[2] ] == -I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + dZH1 + dZG01} },
-
   C[ S[1], S[1], S[3], -S[3] ] == -I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + dZH1 + dZGp1} },
-
   C[ S[2], S[2], S[2], S[2] ] == -3 I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + 2 dZG01} },
-
   C[ S[2], S[2], S[3], -S[3] ] == -I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + dZG01 + dZGp1} },
-
   C[ S[3], S[3], -S[3], -S[3] ] == -I EL^2 MH^2/(2 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + 2 dZGp1} },
-
 	(* S-S-S:  G(+) . 1 *)
-
   C[ S[1], S[1], S[1] ] == -3 I EL MH^2/(2 SW MW) *
     { {1, dZe1 - dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/(2 MW^2) + 3/2 dZH1} },
@@ -540,140 +432,100 @@ M$CouplingMatrices = {
   C[ S[1], S[2], S[2] ] == -I EL MH^2/(2 SW MW) *
     { {1, dZe1 - dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/(2 MW^2) + dZH1/2 + dZG01} },
-
   C[ S[3], S[1], -S[3] ] == -I EL MH^2/(2 SW MW) *
     { {1, dZe1 - dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/(2 MW^2) + dZH1/2 + dZGp1} },
-
 	(* S-S-V-V:  G(+) . g[mu3, mu4] *)
-
   C[ S[1], S[1], V[3], -V[3] ] == I EL^2/(2 SW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dZW1 + dZH1} },
-
   C[ S[2], S[2], V[3], -V[3] ] == I EL^2/(2 SW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dZW1 + dZG01} },
-
   C[ S[3], -S[3], V[3], -V[3] ] == I EL^2/(2 SW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dZW1 + dZGp1} },
-
   C[ S[3], -S[3], V[2], V[2] ] == I EL^2 (SW^2 - CW^2)^2/(2 CW^2 SW^2) *
     { {1, 2 dZe1 + 2/(SW CW^2 (SW^2 - CW^2)) dSW1 + dZZZ1 + dZGp1 +
             2 SW CW/(SW^2 - CW^2) dZAZ1} },
-
   C[ S[3], -S[3], V[1], V[2] ] == I EL^2 (SW^2 - CW^2)/(CW SW) *
     { {1, 2 dZe1 + dSW1/(SW CW^2 (SW^2 - CW^2)) + dZZZ1/2 + dZAA1/2 +
             dZGp1 + (SW^2 - CW^2)/(4 SW CW) dZZA1 +
             SW CW/(SW^2 - CW^2) dZAZ1} },
-
   C[ S[3], -S[3], V[1], V[1] ] == 2 I EL^2 *
     { {1, 2 dZe1 + dZAA1 + dZGp1 + (SW^2 - CW^2)/(2 SW CW) dZZA1} },
-
   C[ S[1], S[1], V[2], V[2] ] == I EL^2/(2 CW^2 SW^2) *
     { {1, 2 dZe1 + 2 (SW^2 - CW^2)/(SW CW^2) dSW1 + dZZZ1 + dZH1} },
-
   C[ S[2], S[2], V[2],  V[2] ] == I EL^2/(2 CW^2 SW^2) *
     { {1, 2 dZe1 + 2 (SW^2 - CW^2)/(SW CW^2) dSW1 + dZZZ1 + dZG01} },
-
   C[ S[1], S[1], V[1], V[2] ] == I EL^2/(2 CW^2 SW^2) *
     { {0, dZZA1/2} },
-
   C[ S[2], S[2], V[1], V[2] ] == I EL^2/(2 CW^2 SW^2) *
     { {0, dZZA1/2} },
-
   C[ S[1], -S[3], V[3], V[2] ] == -I EL^2/(2 CW) *
     { {1, 2 dZe1 - dCW1/CW + dZW1/2 + dZH1/2 + dZGp1/2 +
             dZZZ1/2 + CW/SW dZAZ1/2} },
-
   C[ S[1], S[3], -V[3], V[2] ] == -I EL^2/(2 CW) *
     { {1, 2 dZe1 - dCW1/CW + dZW1/2 + dZH1/2 + dZGp1/2 +
             dZZZ1/2 + CW/SW dZAZ1/2} },
-
   C[ S[1], S[3], -V[3], V[1] ] == -I EL^2/(2 SW) *
     { {1, 2 dZe1 - dSW1/SW + dZW1/2 + dZH1/2 + dZGp1/2 +
             dZAA1/2 + SW/CW dZZA1/2} },
-
   C[ S[1], -S[3], V[3], V[1] ] == -I EL^2/(2 SW) *
     { {1, 2 dZe1 - dSW1/SW + dZW1/2 + dZH1/2 + dZGp1/2 +
             dZAA1/2 + SW/CW dZZA1/2} },
-
   C[ S[3], S[2], V[2], -V[3] ] == EL^2/(2 CW) *
     { {1, 2 dZe1 - dCW1/CW + dZW1/2 + dZZZ1/2 + dZGp1/2 + dZG01/2 +
             CW/SW dZAZ1/2} },
-
   C[ -S[3], S[2], V[2], V[3] ] == -EL^2/(2 CW) *
     { {1, 2 dZe1 - dCW1/CW + dZW1/2 + dZZZ1/2 + dZGp1/2 + dZG01/2 +
             CW/SW dZAZ1/2} },
-
   C[ S[3], S[2], V[1], -V[3] ] == EL^2/(2 SW) *
     { {1, 2 dZe1 - dSW1/SW + dZW1/2 + dZAA1/2 + dZGp1/2 + dZG01/2 +
             SW/CW dZZA1/2} },
-
   C[ -S[3], S[2], V[1], V[3] ] == -EL^2/(2 SW) *
     { {1, 2 dZe1 - dSW1/SW + dZW1/2 + dZAA1/2 + dZGp1/2 + dZG01/2 +
             SW/CW dZZA1/2} },
-
 	(* S-S-V:  G(-) . (p1 - p2)_mu3 *)
-
   C[ S[2], S[1], V[1] ] == EL/(2 CW SW) *
     { {0, dZZA1/2} },
-
   C[ S[2], S[1], V[2] ] == EL/(2 CW SW) *
     { {1, dZe1 + (SW^2 - CW^2)/(CW^2 SW) dSW1 + dZH1/2 + dZZZ1/2 +
             dZG01/2} },
-
   C[ -S[3], S[3], V[1] ] == -I EL *
     { {1, dZe1 + dZAA1/2 + dZGp1 + (SW^2 - CW^2)/(2 SW CW) dZZA1/2} },
-
   C[ -S[3], S[3], V[2] ] == -I EL (SW^2 - CW^2)/(2 CW SW) *
     { {1, dZe1 + dSW1/((SW^2 - CW^2) CW^2 SW) + dZZZ1/2 + dZGp1 +
             2 SW CW/(SW^2 - CW^2) dZAZ1/2} },
-
   C[ S[3], S[1], -V[3] ] == -I EL/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZW1/2 + dZH1/2 + dZGp1/2} },
-
   C[ -S[3], S[1], V[3] ] == I EL/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZW1/2 + dZH1/2 + dZGp1/2} },
-
   C[ S[3], S[2], -V[3] ] == EL/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZW1/2 + dZGp1/2 + dZG01/2} },
-
   C[ -S[3], S[2], V[3] ] == EL/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZW1/2 + dZGp1/2 + dZG01/2} },
-
 	(* S-V-V:  G(+) . g[mu2, mu3] *)
-
   C[ S[1], -V[3], V[3] ] == I EL MW/SW *
     { {1, dZe1 - dSW1/SW + dMWsq1/(2 MW^2) + dZH1/2 + dZW1} },
-
   C[ S[1], V[2], V[2] ] == I EL MW/(SW CW^2) *
     { {1, dZe1 + (2 SW^2 - CW^2)/(CW^2 SW) dSW1 + dMWsq1/(2 MW^2) +
             dZH1/2 + dZZZ1} },
-
   C[ S[1], V[2], V[1] ] == I EL MW/(SW CW^2) *
     { {0, dZZA1/2} },
-
   C[ -S[3], V[3], V[2] ] == -I EL MW SW/CW *
     { {1, dZe1 + dSW1/(CW^2 SW) + dMWsq1/(2 MW^2) + dZW1/2 + dZZZ1/2 +
             dZGp1/2 + CW/SW dZAZ1/2} },
-
   C[ S[3], -V[3], V[2] ] == -I EL MW SW/CW *
     { {1, dZe1 + dSW1/(CW^2 SW) + dMWsq1/(2 MW^2) + dZW1/2 + dZZZ1/2 +
             dZGp1/2 + CW/SW dZAZ1/2} },
-
   C[ -S[3], V[3], V[1] ] == -I EL MW *
     { {1, dZe1 + dMWsq1/(2 MW^2) + dZW1/2 + dZAA1/2 + dZGp1/2 +
             SW/CW dZZA1/2} },
-
   C[ S[3], -V[3], V[1] ] == -I EL MW *
     { {1, dZe1 + dMWsq1/(2 MW^2) + dZW1/2 + dZAA1/2 + dZGp1/2 +
             SW/CW dZZA1/2} },
-
 	(* F-F-V:  G(-) . { gamma[mu3] omega[-], gamma[mu3] omega[+] } *)
-
   C[ -F[1, {j1}], F[1, {j2}], V[1] ] == I EL *
     { {0, gL[1] IndexDelta[j1, j2] dZZA1/2},
       {0, 0} },
-
   C[ -F[2, {j1}], F[2, {j2}], V[1] ] == I EL *
     { {-FermionCharge[2] IndexDelta[j1, j2],
         -FermionCharge[2] *
@@ -683,7 +535,6 @@ M$CouplingMatrices = {
         -FermionCharge[2] *
           (IndexDelta[j1, j2] (dZe1 + dZAA1/2) + AddHC[dZfR1[2, j1, j2]]) +
           gR[2] IndexDelta[j1, j2] dZZA1/2} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}], V[1] ] == I EL IndexDelta[o1, o2] *
     { {-FermionCharge[3] IndexDelta[j1, j2],
         -FermionCharge[3] *
@@ -693,7 +544,6 @@ M$CouplingMatrices = {
         -FermionCharge[3] *
           (IndexDelta[j1, j2] (dZe1 + dZAA1/2) + AddHC[dZfR1[3, j1, j2]]) +
           gR[3] IndexDelta[j1, j2] dZZA1/2} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}], V[1] ] == I EL IndexDelta[o1, o2] *
     { {-FermionCharge[4] IndexDelta[j1, j2],
         -FermionCharge[4] *
@@ -703,13 +553,11 @@ M$CouplingMatrices = {
         -FermionCharge[4] *
           (IndexDelta[j1, j2] (dZe1 + dZAA1/2) + AddHC[dZfR1[4, j1, j2]]) +
           gR[4] IndexDelta[j1, j2] dZZA1/2} },
-
   C[ -F[1, {j1}], F[1, {j2}], V[2] ] == I EL *
     { {gL[1] IndexDelta[j1, j2],
         IndexDelta[j1, j2] (gL[1] dZZZ1/2 + dgL[1]) +
         gL[1] AddHC[dZfL1[1, j1, j2]]},
       {0, 0} },
-
   C[ -F[2, {j1}], F[2, {j2}], V[2] ] == I EL *
     { {gL[2] IndexDelta[j1, j2],
         IndexDelta[j1, j2] *
@@ -719,7 +567,6 @@ M$CouplingMatrices = {
         IndexDelta[j1, j2] *
           (gR[2] dZZZ1/2 + dgR[2] - FermionCharge[2] dZAZ1/2) +
           gR[2] AddHC[dZfR1[2, j1, j2]]} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}], V[2] ] == I EL IndexDelta[o1, o2] *
     { {gL[3] IndexDelta[j1, j2],
         IndexDelta[j1, j2] *
@@ -729,7 +576,6 @@ M$CouplingMatrices = {
         IndexDelta[j1, j2] *
           (gR[3] dZZZ1/2 + dgR[3] - FermionCharge[3] dZAZ1/2) +
           gR[3] AddHC[dZfR1[3, j1, j2]]} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}], V[2] ] == I EL IndexDelta[o1, o2] *
     { {gL[4] IndexDelta[j1, j2],
         IndexDelta[j1, j2] *
@@ -739,7 +585,6 @@ M$CouplingMatrices = {
         IndexDelta[j1, j2] *
           (gR[4] dZZZ1/2 + dgR[4] - FermionCharge[4] dZAZ1/2) +
           gR[4] AddHC[dZfR1[4, j1, j2]]} },
-
   C[ -F[1, {j1}], F[2, {j2}], -V[3] ] ==
     I EL/(Sqrt[2] SW) IndexDelta[j1, j2] *
     { {1, dZe1 - dSW1/SW + dZW1/2 +
@@ -754,7 +599,6 @@ M$CouplingMatrices = {
             1/4 (dZW1 dZfL1[2, j1, j1] + dZW1 Conjugate[dZfL1[1, j1, j1]] +
                    Conjugate[dZfL1[1, j1, j1]] dZfL1[2, j1, j1]) },
       {0, 0, 0} },
-
   C[ -F[2, {j1}], F[1, {j2}], V[3] ] ==
     I EL/(Sqrt[2] SW) IndexDelta[j1, j2] *
     { {1, dZe1 - dSW1/SW + dZW1/2 +
@@ -769,7 +613,6 @@ M$CouplingMatrices = {
 	    1/4 (dZW1 Conjugate[dZfL1[2, j1, j1]] + dZW1 dZfL1[1, j1, j1] +
               dZfL1[1, j1, j1] Conjugate[dZfL1[2, j1, j1]]) },
       {0, 0, 0} },
-
   C[ -F[3, {j1, o1}], F[4, {j2, o2}], -V[3] ] ==
     I EL/(Sqrt[2] SW) IndexDelta[o1, o2] *
     { {CKM[j1, j2],
@@ -779,7 +622,6 @@ M$CouplingMatrices = {
           CKM[j1, gn] dZfL1[4, gn, j2],
         {gn, MaxGenerationIndex}]},
       {0, 0} },
-
   C[ -F[4, {j2, o2}], F[3, {j1, o1}], V[3] ] ==
     I EL/(Sqrt[2] SW) IndexDelta[o1, o2] *
     { {Conjugate[CKM[j1, j2]],
@@ -790,9 +632,7 @@ M$CouplingMatrices = {
             Conjugate[CKM[gn, j2]] dZfL1[3, gn, j1],
           {gn, MaxGenerationIndex}]},
       {0, 0} },
-
 	(* F-F-S:  G(+) . { omega[-], omega[+] } *)
-
   C[ -F[2, {j1}], F[2, {j2}], S[1] ] == -I EL/(2 SW MW) *
     { {Mass[F[2, {j1}]] IndexDelta[j1, j2],
         Mass[F[2, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
@@ -802,7 +642,6 @@ M$CouplingMatrices = {
         Mass[F[2, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[2, j1]/Mass[F[2, {j1}]] - dMWsq1/(2 MW^2) + dZH1/2) +
           mdZfRL1[2, j1, j2]} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}], S[1] ] ==
     -I EL/(2 SW MW) IndexDelta[o1, o2] *
     { {Mass[F[3, {j1}]] IndexDelta[j1, j2],
@@ -813,7 +652,6 @@ M$CouplingMatrices = {
         Mass[F[3, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[3, j1]/Mass[F[3, {j1}]] - dMWsq1/(2 MW^2) + dZH1/2) +
           mdZfRL1[3, j1, j2]} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}], S[1] ] ==
     -I EL/(2 SW MW) IndexDelta[o1, o2] *
     { {Mass[F[4, {j1}]] IndexDelta[j1, j2],
@@ -824,7 +662,6 @@ M$CouplingMatrices = {
         Mass[F[4, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[4, j1]/Mass[F[4, {j1}]] - dMWsq1/(2 MW^2) + dZH1/2) +
           mdZfRL1[4, j1, j2]} },
-
   C[ -F[2, {j1}], F[2, {j2}], S[2] ] == -EL/(2 SW MW) *
     { {Mass[F[2, {j1}]] IndexDelta[j1, j2],
         Mass[F[2, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
@@ -834,7 +671,6 @@ M$CouplingMatrices = {
         -Mass[F[2, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[2, j1]/Mass[F[2, {j1}]] - dMWsq1/(2 MW^2) + dZG01/2) -
           mdZfRL1[2, j1, j2]} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}], S[2] ] ==
     EL/(2 SW MW) IndexDelta[o1, o2] *
     { {Mass[F[3, {j1}]] IndexDelta[j1, j2],
@@ -845,7 +681,6 @@ M$CouplingMatrices = {
         -Mass[F[3, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[3, j1]/Mass[F[3, {j1}]] - dMWsq1/(2 MW^2) + dZG01/2) -
           mdZfRL1[3, j1, j2]} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}], S[2] ] ==
     -EL/(2 SW MW) IndexDelta[o1, o2] *
     { {Mass[F[4, {j1}]] IndexDelta[j1, j2],
@@ -856,7 +691,6 @@ M$CouplingMatrices = {
         -Mass[F[4, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[4, j1]/Mass[F[4, {j1}]] - dMWsq1/(2 MW^2) + dZG01/2) -
           mdZfRL1[4, j1, j2]} },
-
   C[ -F[3, {j1, o1}], F[4, {j2, o2}], -S[3] ] ==
     I EL/(Sqrt[2] SW MW) IndexDelta[o1, o2] *
     { {Mass[F[3, {j1}]] CKM[j1, j2],
@@ -875,7 +709,6 @@ M$CouplingMatrices = {
             Mass[F[4, {j2}]] Conjugate[dZfL1[3, gn, j1]] CKM[gn, j2] +
             Mass[F[4, {gn}]] CKM[j1, gn] dZfR1[4, gn, j2],
           {gn, MaxGenerationIndex}]} },
-
   C[ -F[4, {j2, o2}], F[3, {j1, o1}], S[3] ] ==
     -I EL/(Sqrt[2] SW MW) IndexDelta[o1, o2] *
     { {Mass[F[4, {j2}]] Conjugate[CKM[j1, j2]],
@@ -899,130 +732,93 @@ M$CouplingMatrices = {
             Mass[F[3, {gn}]] Conjugate[CKM[gn, j2]] *
               dZfR1[3, gn, j1],
           {gn, MaxGenerationIndex}]} },
-
   C[ -F[1, {j1}], F[2, {j2}], -S[3] ] ==
     -I EL Mass[F[2, {j1}]]/(Sqrt[2] SW MW) IndexDelta[j1, j2] *
     { {0, 0},
       {1, dZe1 - dSW1/SW + dMf1[2, j1]/Mass[F[2, {j1}]] -
             dMWsq1/(2 MW^2) + dZGp1/2 +
             Conjugate[dZfL1[1, j1, j1]]/2 + dZfR1[2, j1, j1]/2} },
-
   C[ -F[2, {j1}], F[1, {j2}], S[3] ] ==
     -I EL Mass[F[2, {j1}]]/(Sqrt[2] SW MW) IndexDelta[j1, j2] *
     { {1, dZe1 - dSW1/SW + dMf1[2, j1]/Mass[F[2, {j1}]] -
             dMWsq1/(2 MW^2) + dZGp1/2 +
             dZfL1[1, j1, j1]/2 + Conjugate[dZfR1[2, j1, j1]]/2},
       {0, 0} },
-
 	(* U-U-V:  G(+) . { p1_mu3, p2_mu3 } *)
-
   C[ -U[3], U[3], V[1] ] == -I EL *
     { {1, dZe1 + dZAA1/2 - dZW1/2 + dUW1 - CW/SW dZZA1/2},
       {0, 0} },
-
   C[ -U[4], U[4], V[1] ] == I EL *
     { {1, dZe1 + dZAA1/2 - dZW1/2 + dUW1 - CW/SW dZZA1/2},
       {0, 0} },
-
   C[ -U[3], U[3], V[2] ] == I EL CW/SW *
     { {1, dZe1 - 1/(CW^2 SW) dSW1 + dZZZ1/2 - dZW1/2 + dUW1 - SW/CW dZAZ1/2},
       {0, 0} },
-
   C[ -U[4], U[4], V[2] ] == -I EL CW/SW *
     { {1, dZe1 - 1/(CW^2 SW) dSW1 + dZZZ1/2 - dZW1/2 + dUW1 - SW/CW dZAZ1/2},
       {0, 0} },
-
   C[ -U[3], U[2], V[3] ] == -I EL CW/SW *
     { {1, dZe1 - 1/(CW^2 SW) dSW1 + dUZZ1 - SW/CW dUAZ1},
       {0, 0} },
-
   C[ -U[2], U[3], -V[3] ] == -I EL *
     { {CW/SW,
        CW/SW (dZe1 - 1/(CW^2 SW) dSW1 + dZW1/2 - dZZZ1/2 + dUW1) + dZZA1/2},
       {0, 0} }, 
-
   C[ -U[4], U[2], -V[3] ] == I EL CW/SW *
     { {1, dZe1 - 1/(CW^2 SW) dSW1 + dUZZ1 - SW/CW dUAZ1},
       {0, 0} },
-
   C[ -U[2], U[4], V[3] ] == I EL *
     { {CW/SW,
        CW/SW (dZe1 - 1/(CW^2 SW) dSW1 + dZW1/2 - dZZZ1/2 + dUW1) + dZZA1/2},
       {0, 0} },
-
   C[ -U[3], U[1], V[3] ] == I EL *
     { {1, dZe1 + dUAA1 - CW/SW dUZA1},
       {0, 0} },
-
   C[ -U[1], U[3], -V[3] ] == I EL *
     { {1, dZe1 + dZW1/2 - dZAA1/2 + dUW1 + CW/SW dZAZ1/2},
       {0, 0} },
-
   C[ -U[4], U[1], -V[3] ] == -I EL *
     { {1, dZe1 + dUAA1 - CW/SW dUZA1},
       {0, 0} },
-
   C[ -U[1], U[4], V[3] ] == -I EL *
     { {1, dZe1 + dZW1/2 - dZAA1/2 + dUW1 + CW/SW dZAZ1/2},
       {0, 0} },
-
 	(* S-U-U:  G(+) . 1 *)
-
-  C[ S[1], -U[2], U[2] ] == -I EL MZ GaugeXi[Z]/(2 SW CW) *
+  C[ S[1], -U[2], U[2] ] == -I EL MZ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z]/(2 SW CW) *
     { {1, dZe1 + (SW^2 - CW^2)/(CW^2 SW) dSW1 + dZH1/2 - dZG01/2 + dUZZ1} },
-
-  C[ S[1], -U[3], U[3] ] == -I EL MW GaugeXi[W]/(2 SW) *
+  C[ S[1], -U[3], U[3] ] == -I EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZH1/2 - dZGp1/2 + dUW1} },
-
-  C[ S[1], -U[4], U[4] ] == -I EL MW GaugeXi[W]/(2 SW) *
+  C[ S[1], -U[4], U[4] ] == -I EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZH1/2 - dZGp1/2 + dUW1} },
-
-  C[ S[2], -U[4], U[4] ] == EL MW GaugeXi[W]/(2 SW) *
+  C[ S[2], -U[4], U[4] ] == EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZG01/2 - dZGp1/2 + dUW1} },
-
-  C[ S[2], -U[3], U[3] ] == -EL MW GaugeXi[W]/(2 SW) *
+  C[ S[2], -U[3], U[3] ] == -EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZG01/2 - dZGp1/2 + dUW1} },
-
-  C[ -S[3], -U[2], U[3] ] == I EL MZ GaugeXi[Z]/(2 SW) *
+  C[ -S[3], -U[2], U[3] ] == I EL MZ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZGp1/2 - dZG01/2 + dUW1} },
-
-  C[ S[3], -U[2], U[4] ] == I EL MZ GaugeXi[Z]/(2 SW) *
+  C[ S[3], -U[2], U[4] ] == I EL MZ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z]/(2 SW) *
     { {1, dZe1 + dSW1/SW + dZGp1/2 - dZG01/2 + dUW1} },
-
-  C[ -S[3], -U[4], U[2] ] == I EL (SW^2 - CW^2) MW GaugeXi[W]/(2 CW SW) *
+  C[ -S[3], -U[4], U[2] ] == I EL (SW^2 - CW^2) MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 CW SW) *
     { {1, dZe1 + dSW1/((SW^2 - CW^2) CW^2 SW) + dUZZ1 +
         (2 SW CW)/(SW^2 - CW^2) dUAZ1} },
-
-  C[ S[3], -U[3], U[2] ] == I EL (SW^2 - CW^2) MW GaugeXi[W]/(2 CW SW) *
+  C[ S[3], -U[3], U[2] ] == I EL (SW^2 - CW^2) MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 CW SW) *
     { {1, dZe1 + dSW1/((SW^2 - CW^2) CW^2 SW) + dUZZ1 +
         (2 SW CW)/(SW^2 - CW^2) dUAZ1} },
-
-  C[ -S[3], -U[4], U[1] ] == I EL MW GaugeXi[W] *
+  C[ -S[3], -U[4], U[1] ] == I EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W] *
     { {1, dZe1 + dUAA1 + (SW^2 - CW^2)/(2 SW CW) dUZA1} },
-
-  C[ S[3], -U[3], U[1] ] == I EL MW GaugeXi[W] *
+  C[ S[3], -U[3], U[1] ] == I EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W] *
     { {1, dZe1 + dUAA1 + (SW^2 - CW^2)/(2 SW CW) dUZA1} }
 }
-
-
 M$LastModelRules = {}
-
-
 (* some short-hands for excluding classes of particles *)
-
 QEDOnly = ExcludeParticles -> {F[1], V[2], V[3], S, SV, U[2], U[3], U[4]}
-
 NoGeneration1 = ExcludeParticles -> F[_, {1, ___}]
-
 NoGeneration2 = ExcludeParticles -> F[_, {2, ___}]
-
 NoGeneration3 = ExcludeParticles -> F[_, {3, ___}]
-
 NoElectronHCoupling =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[2, {1}], F[2, {1}], S],
     FieldPoint[_][-F[2, {1}], F[1, {1}], S] }
-
 NoLightFHCoupling =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[2], F[2], S],
@@ -1032,7 +828,6 @@ NoLightFHCoupling =
     FieldPoint[_][-F[4], F[4], S],
     FieldPoint[_][-F[4], F[3, {1, ___}], S],
     FieldPoint[_][-F[4], F[3, {2, ___}], S] }
-
 NoQuarkMixing =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[4, {1, ___}], F[3, {2, ___}], S[3]],
@@ -1047,56 +842,33 @@ NoQuarkMixing =
     FieldPoint[_][-F[4, {3, ___}], F[3, {1, ___}], V[3]],
     FieldPoint[_][-F[4, {3, ___}], F[3, {2, ___}], S[3]],
     FieldPoint[_][-F[4, {3, ___}], F[3, {2, ___}], V[3]] }
-
-
 (* The following definitions of renormalization constants
    are for the on-shell renormalization of the Standard Model in
    the scheme of A. Denner, Fortschr. d. Physik, 41 (1993) 4.
-
    The renormalization constants are not directly used by
    FeynArts, and hence do not restrict the generation of diagrams
    and amplitudes in any way. *)
-
 Clear[RenConst]
-
 RenConst[ dMf1[type_, j1_] ] := MassRC[F[type, {j1}]]
-
 RenConst[ dZfL1[type_, j1_, j2_] ] :=
   FieldRC[F[type, {j1}], F[type, {j2}]][[1]]
-
 RenConst[ dZfR1[type_, j1_, j2_] ] :=
   FieldRC[F[type, {j1}], F[type, {j2}]][[2]]
-
 RenConst[ dCKM1[j1_, j2_] ] := 1/4 IndexSum[
   (dZfL1[3, j1, gn] - Conjugate[dZfL1[3, gn, j1]]) CKM[gn, j2] -
   CKM[j1, gn] (dZfL1[4, gn, j2] - Conjugate[dZfL1[4, j2, gn]]),
   {gn, MaxGenerationIndex} ]
-
 RenConst[ dMZsq1 ] := MassRC[V[2]]
-
 RenConst[ dMWsq1 ] := MassRC[V[3]]
-
 RenConst[ dMHsq1 ] := MassRC[S[1]]
-
 RenConst[ dZAA1 ] := FieldRC[V[1]]
-
 RenConst[ dZAZ1 ] := FieldRC[V[1], V[2]]
-
 RenConst[ dZZA1 ] := FieldRC[V[2], V[1]]
-
 RenConst[ dZZZ1 ] := FieldRC[V[2]]
-
 RenConst[ dZG01 ] := FieldRC[S[2]]
-
 RenConst[ dZW1 ] := FieldRC[V[3]]
-
 RenConst[ dZGp1 ] := FieldRC[S[3]]
-
 RenConst[ dZH1 ] := FieldRC[S[1]]
-
 RenConst[ dTH1 ] := TadpoleRC[S[1]]
-
 RenConst[ dSW1 ] := CW^2/SW/2 (dMZsq1/MZ^2 - dMWsq1/MW^2)
-
 RenConst[ dZe1 ] := -1/2 (dZAA1 + SW/CW dZZA1)
-
diff --git FeynArts-3.7/Models/SMQCD.mod FeynArts-3.7/Models/SMQCD.mod
index 1b544fb..ff3afae 100644
--- FeynArts-3.7/Models/SMQCD.mod
+++ FeynArts-3.7/Models/SMQCD.mod
@@ -4,36 +4,22 @@
 		to include the strong interactions
 		by Christian Schappacher
 		last modified 13 Aug 09 by Thomas Hahn
-
 This file introduces the following symbols in addition to the ones in
 SM.mod:
-
-	GS: the strong coupling constant
-
+	Gstrong: the strong coupling constant
 	SUNT[a, i, j]: the generators of SU(N)
 		(half the Gell-Mann matrices)
-
 	SUNF[a, b, c]: the structure constants of SU(N)
-
 	SUNF[a, b, c, d]: a short-hand for the sum
 		\sum_i SUNF[a, b, i] SUNF[i, c, d]
-
-	GaugeXi[G]: gluon gauge parameter
-
+	HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[G]: gluon gauge parameter
 	dZGG1: gluon field RC
         dZg1: strong coupling-constant RC
 *)
-
-
 LoadModel[ StringReplace[$Input, "QCD" -> ""], "" ]
-
 If[ $NoElectroweak === True, M$CouplingMatrices = {} ]
-
-
 IndexRange[ Index[Gluon] ] = NoUnfold[Range[8]]
-
 M$ClassesDescription = Join[ M$ClassesDescription, {
-
   V[5] == {
 	SelfConjugate -> True,
 	Indices -> {Index[Gluon]},
@@ -41,7 +27,6 @@ M$ClassesDescription = Join[ M$ClassesDescription, {
 	PropagatorLabel -> "g",
 	PropagatorType -> Cycles,
 	PropagatorArrow -> None },
-
   U[5] == {
 	SelfConjugate -> False,
 	Indices -> {Index[Gluon]},
@@ -51,65 +36,41 @@ M$ClassesDescription = Join[ M$ClassesDescription, {
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward }
 } ]
-
-
-GaugeXi[ V[5] ] = GaugeXi[G];
-GaugeXi[ U[5] ] = GaugeXi[G]
-
-
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[5] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[G];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[5] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[G]
 M$CouplingMatrices = Join[ M$CouplingMatrices, {
-
-
 (*--- gluon-gluon counter term -----------------------------------------*)
-
   C[ V[5, {g1}], V[5, {g2}] ] == I IndexDelta[g1, g2] *
     { {0, dZGG1},
       {0, 0},
       {0, -dZGG1} },
-
 (*--- gluon-gluon-gluon-gluon ------------------------------------------*)
-
-  C[ V[5, {g1}], V[5, {g2}], V[5, {g3}], V[5, {g4}] ] == -I GS^2 *
+  C[ V[5, {g1}], V[5, {g2}], V[5, {g3}], V[5, {g4}] ] == -I Gstrong^2 *
     { ( SUNF[g1, g3, g2, g4] - SUNF[g1, g4, g3, g2] ) * 
       {1, 2 dZg1 + 2 dZGG1},
       ( SUNF[g1, g2, g3, g4] + SUNF[g1, g4, g3, g2] ) * 
       {1, 2 dZg1 + 2 dZGG1},
       (-SUNF[g1, g2, g3, g4] - SUNF[g1, g3, g2, g4] ) * 
       {1, 2 dZg1 + 2 dZGG1} },
-
-
 (*--- gluon-gluon-gluon ------------------------------------------------*)
-
-  C[ V[5, {g1}], V[5, {g2}], V[5, {g3}] ] == GS SUNF[g1, g2, g3] *
+  C[ V[5, {g1}], V[5, {g2}], V[5, {g3}] ] == Gstrong SUNF[g1, g2, g3] *
     { {1, dZg1 + dZGG1 + dZGG1/2} },
-
-
 (*--- ghost-ghost-gluon ------------------------------------------------*)
-
-  C[ -U[5, {g1}], U[5, {g2}], V[5, {g3}] ] == GS SUNF[g1, g2, g3] *
+  C[ -U[5, {g1}], U[5, {g2}], V[5, {g3}] ] == Gstrong SUNF[g1, g2, g3] *
     { {1, dZg1 + dZGG1/2}, {0, 0} },
-
-
 (*--- quark-quark-gluon ------------------------------------------------*)
-
-  C[ -F[3, {j1, o1}], F[3, {j2, o2}], V[5, {g1}] ] == -I GS *
+  C[ -F[3, {j1, o1}], F[3, {j2, o2}], V[5, {g1}] ] == -I Gstrong *
     SUNT[g1, o1, o2] *
     { {IndexDelta[j1, j2],
         (dZg1 + dZGG1/2) IndexDelta[j1, j2] + AddHC[dZfL1[3, j1, j2]]}, 
       {IndexDelta[j1, j2],
         (dZg1 + dZGG1/2) IndexDelta[j1, j2] + AddHC[dZfR1[3, j1, j2]]} },
-
-  C[ -F[4, {j1, o1}], F[4, {j2, o2}], V[5, {g1}] ] == -I GS *
+  C[ -F[4, {j1, o1}], F[4, {j2, o2}], V[5, {g1}] ] == -I Gstrong *
     SUNT[g1, o1, o2] *
     { {IndexDelta[j1, j2],
          (dZg1 + dZGG1/2) IndexDelta[j1, j2] + AddHC[dZfL1[4, j1, j2]]}, 
       {IndexDelta[j1, j2],
          (dZg1 + dZGG1/2) IndexDelta[j1, j2] + AddHC[dZfR1[4, j1, j2]]} }
-
 } ]
-
-
 RenConst[ dZGG1 ] := UVDivergentPart[FieldRC[V[5]]]
-
 RenConst[ dZg1 ] := -1/2 dZGG1
-
diff --git FeynArts-3.7/Models/SMbgf.mod FeynArts-3.7/Models/SMbgf.mod
index f540a92..227d5f9 100644
--- FeynArts-3.7/Models/SMbgf.mod
+++ FeynArts-3.7/Models/SMbgf.mod
@@ -3,44 +3,25 @@
 		Classes model file for the Standard Model in
 		the background field formalism
 		last modified 13 Aug 09 by Thomas Hahn
-
 Reference:
 	A. Denner, S. Dittmaier, and G. Weiglein
 	Nucl. Phys. B440 (1995) 95
-
 This file introduces the following symbols in addition to the ones in
 SM.mod:
-
-	GaugeXi[Q, bg]:		gauge parameters
-
+	HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q, bg]:		gauge parameters
 V[10, 20, 30] and S[10, 20, 30] are the background fields respectively of
 V[1, 2, 3] and S[1, 2, 3].
-
 *)
-
-
 IndexRange[ Index[Generation] ] = Range[3]
-
 IndexRange[ Index[Colour] ] = NoUnfold[Range[3]]
-
 IndexStyle[ Index[Generation, i_Integer] ] := Alph[i + 8]
-
 MaxGenerationIndex = 3
-
-
 ViolatesQ[ q__ ] := Plus[q] =!= 0
-
-
 (* the leptonic field RCs are diagonal: *)
-
 dZfL1[ type:1 | 2, j1_, j2_ ] :=
   IndexDelta[j1, j2] dZfL1[type, j1, j1] /; j1 =!= j2
-
 dZfR1[ type:1 | 2, j1_, j2_ ] :=
   IndexDelta[j1, j2] dZfR1[type, j1, j1] /; j1 =!= j2
-
-
-
 M$ClassesDescription =
 {F[1] == {SelfConjugate -> False, Indices -> {Index[Generation]}, Mass -> 0, 
    QuantumNumbers -> LeptonNumber, PropagatorLabel -> 
@@ -59,20 +40,20 @@ M$ClassesDescription =
     ComposedChar["d", Index[Generation]], PropagatorType -> Straight, 
    PropagatorArrow -> Forward}, V[1] == {SelfConjugate -> True, 
    Indices -> {}, Mass -> 0, PropagatorLabel -> "\\gamma", 
-   PropagatorType -> Sine, PropagatorArrow -> None, InsertOnly -> Loop}, 
+   PropagatorType -> Sine, PropagatorArrow -> None, InsertOnly -> HighEnergyPhysics`FeynCalc`Loop`Loop}, 
  V[10] == {SelfConjugate -> True, Indices -> {}, Mass -> 0, 
    PropagatorLabel -> ComposedChar["\\gamma", Null, Null, "\\hat"], 
    PropagatorType -> Sine, PropagatorArrow -> None, 
    InsertOnly -> {Internal, External}}, 
  V[2] == {SelfConjugate -> True, Indices -> {}, Mass -> MZ, 
    PropagatorLabel -> "Z", PropagatorType -> Sine, PropagatorArrow -> None, 
-   InsertOnly -> Loop}, V[20] == {SelfConjugate -> True, Indices -> {}, 
+   InsertOnly -> HighEnergyPhysics`FeynCalc`Loop`Loop}, V[20] == {SelfConjugate -> True, Indices -> {}, 
    Mass -> MZ, PropagatorLabel -> ComposedChar["Z", Null, Null, "\\hat"], 
    PropagatorType -> Sine, PropagatorArrow -> None, 
    InsertOnly -> {Internal, External}}, 
  V[3] == {SelfConjugate -> False, Indices -> {}, Mass -> MW, 
    QuantumNumbers -> -Charge, PropagatorLabel -> "W", PropagatorType -> Sine, 
-   PropagatorArrow -> Forward, InsertOnly -> Loop}, 
+   PropagatorArrow -> Forward, InsertOnly -> HighEnergyPhysics`FeynCalc`Loop`Loop}, 
  V[30] == {SelfConjugate -> False, Indices -> {}, Mass -> MW, 
    QuantumNumbers -> -Charge, PropagatorLabel -> ComposedChar["W", Null, 
      Null, "\\hat"], PropagatorType -> Sine, PropagatorArrow -> Forward, 
@@ -80,7 +61,7 @@ M$ClassesDescription =
  SV[2] == {SelfConjugate -> True, Indices -> {}, Mass -> MZ, 
    MixingPartners -> {S[2], V[2]}, PropagatorLabel -> 
     {ComposedChar["G", Null, "0"], "Z"}, PropagatorType -> 
-    {ScalarDash, Sine}, PropagatorArrow -> None, InsertOnly -> Loop}, 
+    {ScalarDash, Sine}, PropagatorArrow -> None, InsertOnly -> HighEnergyPhysics`FeynCalc`Loop`Loop}, 
  SV[20] == {SelfConjugate -> True, Indices -> {}, Mass -> MZ, 
    MixingPartners -> {S[2], V[2]}, PropagatorLabel -> 
     {ComposedChar["G", Null, "0", "\\hat"], ComposedChar["Z", Null, Null, 
@@ -89,7 +70,7 @@ M$ClassesDescription =
  SV[3] == {SelfConjugate -> False, Indices -> {}, Mass -> MW, 
    QuantumNumbers -> -Charge, MixingPartners -> {S[3], V[3]}, 
    PropagatorLabel -> {"G", "W"}, PropagatorType -> {ScalarDash, Sine}, 
-   PropagatorArrow -> Forward, InsertOnly -> Loop}, 
+   PropagatorArrow -> Forward, InsertOnly -> HighEnergyPhysics`FeynCalc`Loop`Loop}, 
  SV[30] == {SelfConjugate -> False, Indices -> {}, Mass -> MW, 
    QuantumNumbers -> -Charge, MixingPartners -> {S[3], V[3]}, 
    PropagatorLabel -> {ComposedChar["G", Null, Null, "\\hat"], 
@@ -98,7 +79,7 @@ M$ClassesDescription =
    InsertOnly -> {Internal, External}}, 
  S[1] == {SelfConjugate -> True, Indices -> {}, Mass -> MH, 
    PropagatorLabel -> "H", PropagatorType -> ScalarDash, 
-   PropagatorArrow -> None, InsertOnly -> Loop}, 
+   PropagatorArrow -> None, InsertOnly -> HighEnergyPhysics`FeynCalc`Loop`Loop}, 
  S[10] == {SelfConjugate -> True, Indices -> {}, Mass -> MH, 
    PropagatorLabel -> ComposedChar["H", Null, Null, "\\hat"], 
    PropagatorType -> ScalarDash, PropagatorArrow -> None, 
@@ -106,14 +87,14 @@ M$ClassesDescription =
  S[2] == {SelfConjugate -> True, Indices -> {}, Mass -> MZ, 
    PropagatorLabel -> ComposedChar["G", Null, "0"], 
    PropagatorType -> ScalarDash, PropagatorArrow -> None, 
-   InsertOnly -> Loop}, S[20] == {SelfConjugate -> True, Indices -> {}, 
+   InsertOnly -> HighEnergyPhysics`FeynCalc`Loop`Loop}, S[20] == {SelfConjugate -> True, Indices -> {}, 
    Mass -> MZ, PropagatorLabel -> ComposedChar["G", Null, "0", "\\hat"], 
    PropagatorType -> ScalarDash, PropagatorArrow -> None, 
    InsertOnly -> {Internal, External}}, 
  S[3] == {SelfConjugate -> False, Indices -> {}, Mass -> MW, 
    QuantumNumbers -> -Charge, PropagatorLabel -> "G", 
    PropagatorType -> ScalarDash, PropagatorArrow -> Forward, 
-   InsertOnly -> Loop}, S[30] == {SelfConjugate -> False, Indices -> {}, 
+   InsertOnly -> HighEnergyPhysics`FeynCalc`Loop`Loop}, S[30] == {SelfConjugate -> False, Indices -> {}, 
    Mass -> MW, QuantumNumbers -> -Charge, PropagatorLabel -> 
     ComposedChar["G", Null, Null, "\\hat"], PropagatorType -> ScalarDash, 
    PropagatorArrow -> Forward, InsertOnly -> {Internal, External}}, 
@@ -130,7 +111,6 @@ M$ClassesDescription =
    Indices -> {}, Mass -> MW, QuantumNumbers -> {Charge, GhostNumber}, 
    PropagatorLabel -> ComposedChar["u", "+"], PropagatorType -> GhostDash, 
    PropagatorArrow -> Forward}}
-
 M$CouplingMatrices =
 {C[-V[3], -V[3], V[3], V[3]] == {{((2*I)*EL^2)/SW^2}, {((-I)*EL^2)/SW^2}, 
    {((-I)*EL^2)/SW^2}}, C[-V[3], V[3], V[2], V[2]] == 
@@ -243,17 +223,17 @@ M$CouplingMatrices =
  C[-U[3], U[1], V[3]] == {{I*EL}, {0}}, C[-U[1], U[3], -V[3]] == 
   {{I*EL}, {0}}, C[-U[4], U[1], -V[3]] == {{(-I)*EL}, {0}}, 
  C[-U[1], U[4], V[3]] == {{(-I)*EL}, {0}}, C[S[1], -U[2], U[2]] == 
-  {{((-I/2)*EL*MZ*GaugeXi[Z])/(CW*SW)}}, C[S[1], -U[3], U[3]] == 
-  {{((-I/2)*EL*MW*GaugeXi[W])/SW}}, C[S[1], -U[4], U[4]] == 
-  {{((-I/2)*EL*MW*GaugeXi[W])/SW}}, C[S[2], -U[4], U[4]] == 
-  {{(EL*MW*GaugeXi[W])/(2*SW)}}, C[S[2], -U[3], U[3]] == 
-  {{-(EL*MW*GaugeXi[W])/(2*SW)}}, C[-S[3], -U[2], U[3]] == 
-  {{((I/2)*EL*MZ*GaugeXi[Z])/SW}}, C[S[3], -U[2], U[4]] == 
-  {{((I/2)*EL*MZ*GaugeXi[Z])/SW}}, C[-S[3], -U[4], U[2]] == 
-  {{((I/2)*EL*MW*(-CW^2 + SW^2)*GaugeXi[W])/(CW*SW)}}, 
- C[S[3], -U[3], U[2]] == {{((I/2)*EL*MW*(-CW^2 + SW^2)*GaugeXi[W])/(CW*SW)}}, 
- C[-S[3], -U[4], U[1]] == {{I*EL*MW*GaugeXi[W]}}, 
- C[S[3], -U[3], U[1]] == {{I*EL*MW*GaugeXi[W]}}, 
+  {{((-I/2)*EL*MZ*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z])/(CW*SW)}}, C[S[1], -U[3], U[3]] == 
+  {{((-I/2)*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/SW}}, C[S[1], -U[4], U[4]] == 
+  {{((-I/2)*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/SW}}, C[S[2], -U[4], U[4]] == 
+  {{(EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/(2*SW)}}, C[S[2], -U[3], U[3]] == 
+  {{-(EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/(2*SW)}}, C[-S[3], -U[2], U[3]] == 
+  {{((I/2)*EL*MZ*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z])/SW}}, C[S[3], -U[2], U[4]] == 
+  {{((I/2)*EL*MZ*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z])/SW}}, C[-S[3], -U[4], U[2]] == 
+  {{((I/2)*EL*MW*(-CW^2 + SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/(CW*SW)}}, 
+ C[S[3], -U[3], U[2]] == {{((I/2)*EL*MW*(-CW^2 + SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W])/(CW*SW)}}, 
+ C[-S[3], -U[4], U[1]] == {{I*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]}}, 
+ C[S[3], -U[3], U[1]] == {{I*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]}}, 
  C[-F[1, {j1}], F[1, {j2}]] == 
   {{0, (-I/2)*(Conjugate[dZfL1[1, j1, j1]] + dZfL1[1, j1, j1])*
      IndexDelta[j1, j2]}, {0, (I/2)*(Conjugate[dZfR1[1, j1, j1]] + 
@@ -992,28 +972,28 @@ M$CouplingMatrices =
  C[S[10], S[10]] == {{0, (-I)*dZH1}, {0, I*(-dMHsq1 - dZH1*MH^2)}}, 
  C[S[20], S[20]] == {{0, (-I)*dZH1}, {0, ((I/2)*dTH1*EL)/(MW*SW)}}, 
  C[S[30], -S[30]] == {{0, (-I)*dZH1}, {0, ((I/2)*dTH1*EL)/(MW*SW)}}, 
- C[V[10], -V[3], V[3]] == {{(-I)*EL}, {((-I)*EL)/GaugeXi[Q]}, 
-   {(I*EL)/GaugeXi[Q]}, {0}}, C[-V[30], V[3], V[1]] == 
-  {{(-I)*EL}, {((-I)*EL)/GaugeXi[Q]}, {(I*EL)/GaugeXi[Q]}, {0}}, 
- C[V[30], V[1], -V[3]] == {{(-I)*EL}, {((-I)*EL)/GaugeXi[Q]}, 
-   {(I*EL)/GaugeXi[Q]}, {0}}, C[V[20], -V[3], V[3]] == 
-  {{(I*CW*EL)/SW}, {(I*CW*EL)/(SW*GaugeXi[Q])}, 
-   {((-I)*CW*EL)/(SW*GaugeXi[Q])}, {0}}, C[-V[30], V[3], V[2]] == 
-  {{(I*CW*EL)/SW}, {(I*CW*EL)/(SW*GaugeXi[Q])}, 
-   {((-I)*CW*EL)/(SW*GaugeXi[Q])}, {0}}, C[V[30], V[2], -V[3]] == 
-  {{(I*CW*EL)/SW}, {(I*CW*EL)/(SW*GaugeXi[Q])}, 
-   {((-I)*CW*EL)/(SW*GaugeXi[Q])}, {0}}, C[S[10], S[1], S[1]] == 
+ C[V[10], -V[3], V[3]] == {{(-I)*EL}, {((-I)*EL)/HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}, 
+   {(I*EL)/HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}, {0}}, C[-V[30], V[3], V[1]] == 
+  {{(-I)*EL}, {((-I)*EL)/HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}, {(I*EL)/HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}, {0}}, 
+ C[V[30], V[1], -V[3]] == {{(-I)*EL}, {((-I)*EL)/HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}, 
+   {(I*EL)/HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}, {0}}, C[V[20], -V[3], V[3]] == 
+  {{(I*CW*EL)/SW}, {(I*CW*EL)/(SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])}, 
+   {((-I)*CW*EL)/(SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])}, {0}}, C[-V[30], V[3], V[2]] == 
+  {{(I*CW*EL)/SW}, {(I*CW*EL)/(SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])}, 
+   {((-I)*CW*EL)/(SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])}, {0}}, C[V[30], V[2], -V[3]] == 
+  {{(I*CW*EL)/SW}, {(I*CW*EL)/(SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])}, 
+   {((-I)*CW*EL)/(SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])}, {0}}, C[S[10], S[1], S[1]] == 
   {{(((-3*I)/2)*EL*MH^2)/(MW*SW)}}, C[S[10], S[2], S[2]] == 
-  {{I*EL*(-MH^2/(2*MW*SW) - (MW*GaugeXi[Q])/(CW^2*SW))}}, 
+  {{I*EL*(-MH^2/(2*MW*SW) - (MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW))}}, 
  C[S[1], S[20], S[2]] == 
-  {{I*EL*(-MH^2/(2*MW*SW) + (MW*GaugeXi[Q])/(CW^2*SW))}}, 
- C[S[10], -S[3], S[3]] == {{I*EL*(-MH^2/(2*MW*SW) - (MW*GaugeXi[Q])/SW)}}, 
+  {{I*EL*(-MH^2/(2*MW*SW) + (MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW))}}, 
+ C[S[10], -S[3], S[3]] == {{I*EL*(-MH^2/(2*MW*SW) - (MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW)}}, 
  C[S[1], -S[30], S[3]] == 
-  {{I*EL*(-MH^2/(2*MW*SW) + (MW*GaugeXi[Q])/(2*SW))}}, 
+  {{I*EL*(-MH^2/(2*MW*SW) + (MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW))}}, 
  C[S[1], -S[3], S[30]] == 
-  {{I*EL*(-MH^2/(2*MW*SW) + (MW*GaugeXi[Q])/(2*SW))}}, 
- C[S[2], -S[30], S[3]] == {{(EL*MW*SW*GaugeXi[Q])/(2*CW^2)}}, 
- C[S[2], -S[3], S[30]] == {{-(EL*MW*SW*GaugeXi[Q])/(2*CW^2)}}, 
+  {{I*EL*(-MH^2/(2*MW*SW) + (MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW))}}, 
+ C[S[2], -S[30], S[3]] == {{(EL*MW*SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*CW^2)}}, 
+ C[S[2], -S[3], S[30]] == {{-(EL*MW*SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*CW^2)}}, 
  C[S[30], S[1], -V[3]] == {{((-I)*EL)/SW}, {0}}, 
  C[-S[30], S[1], V[3]] == {{(I*EL)/SW}, {0}}, 
  C[S[10], S[3], -V[3]] == {{(I*EL)/SW}, {0}}, 
@@ -1046,84 +1026,84 @@ M$CouplingMatrices =
  C[-U[3], U[3], V[10]] == {{(-I)*EL}, {I*EL}}, 
  C[-U[4], U[4], V[20]] == {{((-I)*CW*EL)/SW}, {(I*CW*EL)/SW}}, 
  C[-U[3], U[3], V[20]] == {{(I*CW*EL)/SW}, {((-I)*CW*EL)/SW}}, 
- C[-S[30], -U[4], U[2]] == {{(I*EL*MW*SW*GaugeXi[Q])/CW}}, 
- C[S[30], -U[3], U[2]] == {{(I*EL*MW*SW*GaugeXi[Q])/CW}}, 
- C[-S[30], -U[4], U[1]] == {{I*EL*MW*GaugeXi[Q]}}, 
- C[S[30], -U[3], U[1]] == {{I*EL*MW*GaugeXi[Q]}}, 
- C[-S[30], -U[2], U[3]] == {{(I*EL*MW*SW*GaugeXi[Q])/CW}}, 
- C[S[30], -U[2], U[4]] == {{(I*EL*MW*SW*GaugeXi[Q])/CW}}, 
- C[-S[30], -U[1], U[3]] == {{I*EL*MW*GaugeXi[Q]}}, 
- C[S[30], -U[1], U[4]] == {{I*EL*MW*GaugeXi[Q]}}, 
- C[S[10], -U[4], U[4]] == {{((-I)*EL*MW*GaugeXi[Q])/SW}}, 
- C[S[10], -U[3], U[3]] == {{((-I)*EL*MW*GaugeXi[Q])/SW}}, 
- C[S[10], -U[2], U[2]] == {{((-I)*EL*MW*GaugeXi[Q])/(CW^2*SW)}}, 
+ C[-S[30], -U[4], U[2]] == {{(I*EL*MW*SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/CW}}, 
+ C[S[30], -U[3], U[2]] == {{(I*EL*MW*SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/CW}}, 
+ C[-S[30], -U[4], U[1]] == {{I*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}}, 
+ C[S[30], -U[3], U[1]] == {{I*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}}, 
+ C[-S[30], -U[2], U[3]] == {{(I*EL*MW*SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/CW}}, 
+ C[S[30], -U[2], U[4]] == {{(I*EL*MW*SW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/CW}}, 
+ C[-S[30], -U[1], U[3]] == {{I*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}}, 
+ C[S[30], -U[1], U[4]] == {{I*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}}, 
+ C[S[10], -U[4], U[4]] == {{((-I)*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[S[10], -U[3], U[3]] == {{((-I)*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[S[10], -U[2], U[2]] == {{((-I)*EL*MW*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW)}}, 
  C[V[10], V[10], -V[3], V[3]] == {{(-2*I)*EL^2}, 
-   {(-I)*EL^2*(-1 + GaugeXi[Q]^(-1))}, {(-I)*EL^2*(-1 + GaugeXi[Q]^(-1))}}, 
+   {(-I)*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1))}, {(-I)*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1))}}, 
  C[-V[30], V[30], V[1], V[1]] == {{(-2*I)*EL^2}, 
-   {(-I)*EL^2*(-1 + GaugeXi[Q]^(-1))}, {(-I)*EL^2*(-1 + GaugeXi[Q]^(-1))}}, 
+   {(-I)*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1))}, {(-I)*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1))}}, 
  C[V[20], V[20], -V[3], V[3]] == {{((-2*I)*CW^2*EL^2)/SW^2}, 
-   {((-I)*CW^2*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW^2}, 
-   {((-I)*CW^2*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW^2}}, 
+   {((-I)*CW^2*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}, 
+   {((-I)*CW^2*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}}, 
  C[-V[30], V[30], V[2], V[2]] == {{((-2*I)*CW^2*EL^2)/SW^2}, 
-   {((-I)*CW^2*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW^2}, 
-   {((-I)*CW^2*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW^2}}, 
+   {((-I)*CW^2*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}, 
+   {((-I)*CW^2*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}}, 
  C[V[10], V[20], -V[3], V[3]] == {{((2*I)*CW*EL^2)/SW}, 
-   {(I*CW*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW}, 
-   {(I*CW*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW}}, C[-V[30], V[30], V[1], V[2]] == 
-  {{((2*I)*CW*EL^2)/SW}, {(I*CW*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW}, 
-   {(I*CW*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW}}, C[V[30], V[30], -V[3], -V[3]] == 
-  {{((2*I)*EL^2)/SW^2}, {(I*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW^2}, 
-   {(I*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW^2}}, C[-V[30], -V[30], V[3], V[3]] == 
-  {{((2*I)*EL^2)/SW^2}, {(I*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW^2}, 
-   {(I*EL^2*(-1 + GaugeXi[Q]^(-1)))/SW^2}}, C[-V[30], V[10], V[3], V[1]] == 
-  {{I*EL^2}, {(-2*I)*EL^2}, {(-I)*EL^2*(-1 - GaugeXi[Q]^(-1))}}, 
+   {(I*CW*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW}, 
+   {(I*CW*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW}}, C[-V[30], V[30], V[1], V[2]] == 
+  {{((2*I)*CW*EL^2)/SW}, {(I*CW*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW}, 
+   {(I*CW*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW}}, C[V[30], V[30], -V[3], -V[3]] == 
+  {{((2*I)*EL^2)/SW^2}, {(I*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}, 
+   {(I*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}}, C[-V[30], -V[30], V[3], V[3]] == 
+  {{((2*I)*EL^2)/SW^2}, {(I*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}, 
+   {(I*EL^2*(-1 + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}}, C[-V[30], V[10], V[3], V[1]] == 
+  {{I*EL^2}, {(-2*I)*EL^2}, {(-I)*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1))}}, 
  C[V[30], V[10], -V[3], V[1]] == {{I*EL^2}, {(-2*I)*EL^2}, 
-   {(-I)*EL^2*(-1 - GaugeXi[Q]^(-1))}}, C[-V[30], V[20], V[3], V[2]] == 
+   {(-I)*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1))}}, C[-V[30], V[20], V[3], V[2]] == 
   {{(I*CW^2*EL^2)/SW^2}, {((-2*I)*CW^2*EL^2)/SW^2}, 
-   {((-I)*CW^2*EL^2*(-1 - GaugeXi[Q]^(-1)))/SW^2}}, 
+   {((-I)*CW^2*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}}, 
  C[V[30], V[20], -V[3], V[2]] == {{(I*CW^2*EL^2)/SW^2}, 
-   {((-2*I)*CW^2*EL^2)/SW^2}, {((-I)*CW^2*EL^2*(-1 - GaugeXi[Q]^(-1)))/
+   {((-2*I)*CW^2*EL^2)/SW^2}, {((-I)*CW^2*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/
      SW^2}}, C[-V[30], V[10], V[3], V[2]] == {{((-I)*CW*EL^2)/SW}, 
-   {((2*I)*CW*EL^2)/SW}, {(I*CW*EL^2*(-1 - GaugeXi[Q]^(-1)))/SW}}, 
+   {((2*I)*CW*EL^2)/SW}, {(I*CW*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW}}, 
  C[V[30], V[10], -V[3], V[2]] == {{((-I)*CW*EL^2)/SW}, {((2*I)*CW*EL^2)/SW}, 
-   {(I*CW*EL^2*(-1 - GaugeXi[Q]^(-1)))/SW}}, C[-V[30], V[20], V[3], V[1]] == 
+   {(I*CW*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW}}, C[-V[30], V[20], V[3], V[1]] == 
   {{((-I)*CW*EL^2)/SW}, {((2*I)*CW*EL^2)/SW}, 
-   {(I*CW*EL^2*(-1 - GaugeXi[Q]^(-1)))/SW}}, C[V[30], V[20], -V[3], V[1]] == 
+   {(I*CW*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW}}, C[V[30], V[20], -V[3], V[1]] == 
   {{((-I)*CW*EL^2)/SW}, {((2*I)*CW*EL^2)/SW}, 
-   {(I*CW*EL^2*(-1 - GaugeXi[Q]^(-1)))/SW}}, C[-V[30], V[30], -V[3], V[3]] == 
+   {(I*CW*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW}}, C[-V[30], V[30], -V[3], V[3]] == 
   {{((-I)*EL^2)/SW^2}, {((2*I)*EL^2)/SW^2}, 
-   {(I*EL^2*(-1 - GaugeXi[Q]^(-1)))/SW^2}}, C[S[1], S[1], -S[30], S[30]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - GaugeXi[Q]/(2*SW^2))}}, 
+   {(I*EL^2*(-1 - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]^(-1)))/SW^2}}, C[S[1], S[1], -S[30], S[30]] == 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(2*SW^2))}}, 
  C[S[10], S[10], -S[3], S[3]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - GaugeXi[Q]/(2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(2*SW^2))}}, 
  C[S[2], S[2], -S[30], S[30]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - GaugeXi[Q]/(2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(2*SW^2))}}, 
  C[S[20], S[20], -S[3], S[3]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - GaugeXi[Q]/(2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(2*SW^2))}}, 
  C[S[10], S[1], -S[30], S[3]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + GaugeXi[Q]/(4*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(4*SW^2))}}, 
  C[S[10], S[1], -S[3], S[30]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + GaugeXi[Q]/(4*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(4*SW^2))}}, 
  C[S[20], S[2], -S[30], S[3]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + GaugeXi[Q]/(4*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(4*SW^2))}}, 
  C[S[20], S[2], -S[3], S[30]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + GaugeXi[Q]/(4*SW^2))}}, 
- C[S[10], S[2], -S[30], S[3]] == {{(EL^2*GaugeXi[Q])/(4*CW^2)}}, 
- C[S[1], S[20], -S[30], S[3]] == {{-(EL^2*GaugeXi[Q])/(4*CW^2)}}, 
- C[S[10], S[2], -S[3], S[30]] == {{-(EL^2*GaugeXi[Q])/(4*CW^2)}}, 
- C[S[1], S[20], -S[3], S[30]] == {{(EL^2*GaugeXi[Q])/(4*CW^2)}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(4*SW^2))}}, 
+ C[S[10], S[2], -S[30], S[3]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW^2)}}, 
+ C[S[1], S[20], -S[30], S[3]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW^2)}}, 
+ C[S[10], S[2], -S[3], S[30]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW^2)}}, 
+ C[S[1], S[20], -S[3], S[30]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW^2)}}, 
  C[S[1], S[1], S[20], S[20]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - GaugeXi[Q]/(2*CW^2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(2*CW^2*SW^2))}}, 
  C[S[10], S[10], S[2], S[2]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - GaugeXi[Q]/(2*CW^2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(2*CW^2*SW^2))}}, 
  C[S[10], S[1], S[20], S[2]] == 
-  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + GaugeXi[Q]/(4*CW^2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(4*MW^2*SW^2) + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(4*CW^2*SW^2))}}, 
  C[-S[30], -S[30], S[3], S[3]] == 
-  {{I*EL^2*(-MH^2/(2*MW^2*SW^2) + GaugeXi[Q]/(2*CW^2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(2*MW^2*SW^2) + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(2*CW^2*SW^2))}}, 
  C[S[30], S[30], -S[3], -S[3]] == 
-  {{I*EL^2*(-MH^2/(2*MW^2*SW^2) + GaugeXi[Q]/(2*CW^2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(2*MW^2*SW^2) + HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(2*CW^2*SW^2))}}, 
  C[S[30], -S[30], S[3], -S[3]] == 
-  {{I*EL^2*(-MH^2/(2*MW^2*SW^2) - GaugeXi[Q]/(4*CW^2*SW^2))}}, 
+  {{I*EL^2*(-MH^2/(2*MW^2*SW^2) - HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]/(4*CW^2*SW^2))}}, 
  C[S[10], S[10], S[1], S[1]] == {{(((-3*I)/4)*EL^2*MH^2)/(MW^2*SW^2)}}, 
  C[S[20], S[20], S[2], S[2]] == {{(((-3*I)/4)*EL^2*MH^2)/(MW^2*SW^2)}}, 
  C[-S[30], S[3], V[10], V[1]] == {{(2*I)*EL^2}}, 
@@ -1237,105 +1217,101 @@ M$CouplingMatrices =
  C[-U[3], U[3], V[30], -V[30]] == {{(I*EL^2)/SW^2}}, 
  C[-U[4], U[3], -V[30], -V[30]] == {{((-2*I)*EL^2)/SW^2}}, 
  C[-U[3], U[4], V[30], V[30]] == {{((-2*I)*EL^2)/SW^2}}, 
- C[-S[30], S[3], -U[4], U[4]] == {{((-I/2)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[-S[3], S[30], -U[3], U[3]] == {{((-I/2)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[10], S[1], -U[4], U[4]] == {{((-I/4)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[10], S[1], -U[3], U[3]] == {{((-I/4)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[20], S[2], -U[4], U[4]] == {{((-I/4)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[20], S[2], -U[3], U[3]] == {{((-I/4)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[10], S[1], -U[2], U[2]] == {{((-I/4)*EL^2*GaugeXi[Q])/(CW^2*SW^2)}}, 
- C[S[20], S[2], -U[2], U[2]] == {{((-I/4)*EL^2*GaugeXi[Q])/(CW^2*SW^2)}}, 
- C[S[10], S[2], -U[4], U[4]] == {{(EL^2*GaugeXi[Q])/(4*SW^2)}}, 
- C[S[10], S[2], -U[3], U[3]] == {{-(EL^2*GaugeXi[Q])/(4*SW^2)}}, 
- C[S[1], S[20], -U[4], U[4]] == {{-(EL^2*GaugeXi[Q])/(4*SW^2)}}, 
- C[S[1], S[20], -U[3], U[3]] == {{(EL^2*GaugeXi[Q])/(4*SW^2)}}, 
+ C[-S[30], S[3], -U[4], U[4]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[-S[3], S[30], -U[3], U[3]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[10], S[1], -U[4], U[4]] == {{((-I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[10], S[1], -U[3], U[3]] == {{((-I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[20], S[2], -U[4], U[4]] == {{((-I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[20], S[2], -U[3], U[3]] == {{((-I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[10], S[1], -U[2], U[2]] == {{((-I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW^2)}}, 
+ C[S[20], S[2], -U[2], U[2]] == {{((-I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW^2)}}, 
+ C[S[10], S[2], -U[4], U[4]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*SW^2)}}, 
+ C[S[10], S[2], -U[3], U[3]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*SW^2)}}, 
+ C[S[1], S[20], -U[4], U[4]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*SW^2)}}, 
+ C[S[1], S[20], -U[3], U[3]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*SW^2)}}, 
  C[S[30], -S[3], -U[2], U[2]] == 
-  {{((I/4)*EL^2*(CW^2 - SW^2)^2*GaugeXi[Q])/(CW^2*SW^2)}}, 
+  {{((I/4)*EL^2*(CW^2 - SW^2)^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW^2)}}, 
  C[S[3], -S[30], -U[2], U[2]] == 
-  {{((I/4)*EL^2*(CW^2 - SW^2)^2*GaugeXi[Q])/(CW^2*SW^2)}}, 
+  {{((I/4)*EL^2*(CW^2 - SW^2)^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW^2)}}, 
  C[S[3], -S[30], -U[2], U[1]] == 
-  {{((I/2)*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW)}}, 
+  {{((I/2)*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW)}}, 
  C[S[30], -S[3], -U[2], U[1]] == 
-  {{((I/2)*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW)}}, 
+  {{((I/2)*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW)}}, 
  C[S[3], -S[30], -U[1], U[2]] == 
-  {{((I/2)*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW)}}, 
+  {{((I/2)*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW)}}, 
  C[S[30], -S[3], -U[1], U[2]] == 
-  {{((I/2)*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW)}}, 
- C[S[3], -S[30], -U[1], U[1]] == {{(-I)*EL^2*GaugeXi[Q]}}, 
- C[S[30], -S[3], -U[1], U[1]] == {{(-I)*EL^2*GaugeXi[Q]}}, 
- C[-S[30], S[1], -U[4], U[2]] == {{((I/4)*EL^2*GaugeXi[Q])/(CW*SW^2)}}, 
- C[S[30], S[1], -U[3], U[2]] == {{((I/4)*EL^2*GaugeXi[Q])/(CW*SW^2)}}, 
- C[-S[3], S[10], -U[2], U[3]] == {{((I/4)*EL^2*GaugeXi[Q])/(CW*SW^2)}}, 
- C[S[3], S[10], -U[2], U[4]] == {{((I/4)*EL^2*GaugeXi[Q])/(CW*SW^2)}}, 
+  {{((I/2)*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW)}}, 
+ C[S[3], -S[30], -U[1], U[1]] == {{(-I)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}}, 
+ C[S[30], -S[3], -U[1], U[1]] == {{(-I)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}}, 
+ C[-S[30], S[1], -U[4], U[2]] == {{((I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW^2)}}, 
+ C[S[30], S[1], -U[3], U[2]] == {{((I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW^2)}}, 
+ C[-S[3], S[10], -U[2], U[3]] == {{((I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW^2)}}, 
+ C[S[3], S[10], -U[2], U[4]] == {{((I/4)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW^2)}}, 
  C[-S[3], S[10], -U[4], U[2]] == 
-  {{((-I/4)*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW^2)}}, 
+  {{((-I/4)*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW^2)}}, 
  C[S[3], S[10], -U[3], U[2]] == 
-  {{((-I/4)*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW^2)}}, 
+  {{((-I/4)*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW^2)}}, 
  C[-S[30], S[1], -U[2], U[3]] == 
-  {{((-I/4)*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW^2)}}, 
+  {{((-I/4)*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW^2)}}, 
  C[S[30], S[1], -U[2], U[4]] == 
-  {{((I/4)*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW^2)}}, 
- C[-S[30], S[1], -U[4], U[1]] == {{((I/2)*EL^2*GaugeXi[Q])/SW}}, 
- C[S[30], S[1], -U[3], U[1]] == {{((I/2)*EL^2*GaugeXi[Q])/SW}}, 
- C[-S[3], S[10], -U[1], U[3]] == {{((I/2)*EL^2*GaugeXi[Q])/SW}}, 
- C[S[3], S[10], -U[1], U[4]] == {{((I/2)*EL^2*GaugeXi[Q])/SW}}, 
- C[-S[30], S[2], -U[4], U[2]] == {{(EL^2*GaugeXi[Q])/(4*CW*SW^2)}}, 
- C[S[30], S[2], -U[3], U[2]] == {{-(EL^2*GaugeXi[Q])/(4*CW*SW^2)}}, 
- C[-S[3], S[20], -U[2], U[3]] == {{(EL^2*GaugeXi[Q])/(4*CW*SW^2)}}, 
- C[S[3], S[20], -U[2], U[4]] == {{-(EL^2*GaugeXi[Q])/(4*CW*SW^2)}}, 
+  {{((I/4)*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW^2)}}, 
+ C[-S[30], S[1], -U[4], U[1]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[S[30], S[1], -U[3], U[1]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[-S[3], S[10], -U[1], U[3]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[S[3], S[10], -U[1], U[4]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[-S[30], S[2], -U[4], U[2]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW*SW^2)}}, 
+ C[S[30], S[2], -U[3], U[2]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW*SW^2)}}, 
+ C[-S[3], S[20], -U[2], U[3]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW*SW^2)}}, 
+ C[S[3], S[20], -U[2], U[4]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW*SW^2)}}, 
  C[-S[3], S[20], -U[4], U[2]] == 
-  {{-(EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(4*CW*SW^2)}}, 
+  {{-(EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW*SW^2)}}, 
  C[S[3], S[20], -U[3], U[2]] == 
-  {{(EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(4*CW*SW^2)}}, 
+  {{(EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW*SW^2)}}, 
  C[-S[30], S[2], -U[2], U[3]] == 
-  {{-(EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(4*CW*SW^2)}}, 
+  {{-(EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW*SW^2)}}, 
  C[S[30], S[2], -U[2], U[4]] == 
-  {{(EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(4*CW*SW^2)}}, 
- C[-S[3], S[20], -U[4], U[1]] == {{(EL^2*GaugeXi[Q])/(2*SW)}}, 
- C[S[3], S[20], -U[3], U[1]] == {{-(EL^2*GaugeXi[Q])/(2*SW)}}, 
- C[-S[30], S[2], -U[1], U[3]] == {{(EL^2*GaugeXi[Q])/(2*SW)}}, 
- C[S[30], S[2], -U[1], U[4]] == {{-(EL^2*GaugeXi[Q])/(2*SW)}}, 
- C[-S[30], S[30], -U[4], U[4]] == {{((-I/2)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[-S[30], S[30], -U[3], U[3]] == {{((-I/2)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[10], S[10], -U[4], U[4]] == {{((-I/2)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[10], S[10], -U[3], U[3]] == {{((-I/2)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[20], S[20], -U[4], U[4]] == {{((-I/2)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[20], S[20], -U[3], U[3]] == {{((-I/2)*EL^2*GaugeXi[Q])/SW^2}}, 
- C[S[10], S[10], -U[2], U[2]] == {{((-I/2)*EL^2*GaugeXi[Q])/(CW^2*SW^2)}}, 
- C[S[20], S[20], -U[2], U[2]] == {{((-I/2)*EL^2*GaugeXi[Q])/(CW^2*SW^2)}}, 
+  {{(EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(4*CW*SW^2)}}, 
+ C[-S[3], S[20], -U[4], U[1]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW)}}, 
+ C[S[3], S[20], -U[3], U[1]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW)}}, 
+ C[-S[30], S[2], -U[1], U[3]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW)}}, 
+ C[S[30], S[2], -U[1], U[4]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW)}}, 
+ C[-S[30], S[30], -U[4], U[4]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[-S[30], S[30], -U[3], U[3]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[10], S[10], -U[4], U[4]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[10], S[10], -U[3], U[3]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[20], S[20], -U[4], U[4]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[20], S[20], -U[3], U[3]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW^2}}, 
+ C[S[10], S[10], -U[2], U[2]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW^2)}}, 
+ C[S[20], S[20], -U[2], U[2]] == {{((-I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW^2)}}, 
  C[S[30], -S[30], -U[2], U[2]] == 
-  {{((I/2)*EL^2*(CW^2 - SW^2)^2*GaugeXi[Q])/(CW^2*SW^2)}}, 
+  {{((I/2)*EL^2*(CW^2 - SW^2)^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW^2*SW^2)}}, 
  C[S[30], -S[30], -U[2], U[1]] == 
-  {{(I*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW)}}, 
+  {{(I*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW)}}, 
  C[S[30], -S[30], -U[1], U[2]] == 
-  {{(I*EL^2*(CW^2 - SW^2)*GaugeXi[Q])/(CW*SW)}}, 
- C[S[30], -S[30], -U[1], U[1]] == {{(-2*I)*EL^2*GaugeXi[Q]}}, 
- C[-S[30], S[10], -U[4], U[2]] == {{((I/2)*EL^2*GaugeXi[Q])/CW}}, 
- C[S[30], S[10], -U[3], U[2]] == {{((I/2)*EL^2*GaugeXi[Q])/CW}}, 
- C[-S[30], S[10], -U[2], U[3]] == {{((I/2)*EL^2*GaugeXi[Q])/CW}}, 
- C[S[30], S[10], -U[2], U[4]] == {{((I/2)*EL^2*GaugeXi[Q])/CW}}, 
- C[-S[30], S[10], -U[4], U[1]] == {{((I/2)*EL^2*GaugeXi[Q])/SW}}, 
- C[S[30], S[10], -U[3], U[1]] == {{((I/2)*EL^2*GaugeXi[Q])/SW}}, 
- C[-S[30], S[10], -U[1], U[3]] == {{((I/2)*EL^2*GaugeXi[Q])/SW}}, 
- C[S[30], S[10], -U[1], U[4]] == {{((I/2)*EL^2*GaugeXi[Q])/SW}}, 
- C[-S[30], S[20], -U[4], U[2]] == {{(EL^2*GaugeXi[Q])/(2*CW)}}, 
- C[S[30], S[20], -U[3], U[2]] == {{-(EL^2*GaugeXi[Q])/(2*CW)}}, 
- C[-S[30], S[20], -U[2], U[3]] == {{(EL^2*GaugeXi[Q])/(2*CW)}}, 
- C[S[30], S[20], -U[2], U[4]] == {{-(EL^2*GaugeXi[Q])/(2*CW)}}, 
- C[-S[30], S[20], -U[4], U[1]] == {{(EL^2*GaugeXi[Q])/(2*SW)}}, 
- C[S[30], S[20], -U[3], U[1]] == {{-(EL^2*GaugeXi[Q])/(2*SW)}}, 
- C[-S[30], S[20], -U[1], U[3]] == {{(EL^2*GaugeXi[Q])/(2*SW)}}, 
- C[S[30], S[20], -U[1], U[4]] == {{-(EL^2*GaugeXi[Q])/(2*SW)}}}
-
-
-GaugeXi[ V[1 | 2 | 3] ] = GaugeXi[Q];
-GaugeXi[ V[10 | 30 | 30] ] = GaugeXi[bg];
-GaugeXi[ S[1 | 10] ] = 1;
-GaugeXi[ S[2 | 3] ] = GaugeXi[Q];   
-GaugeXi[ S[20 | 30] ] = GaugeXi[bg];
-GaugeXi[ U[1 | 2 | 3 | 4] ] = GaugeXi[Q]
-
-
+  {{(I*EL^2*(CW^2 - SW^2)*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(CW*SW)}}, 
+ C[S[30], -S[30], -U[1], U[1]] == {{(-2*I)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]}}, 
+ C[-S[30], S[10], -U[4], U[2]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/CW}}, 
+ C[S[30], S[10], -U[3], U[2]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/CW}}, 
+ C[-S[30], S[10], -U[2], U[3]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/CW}}, 
+ C[S[30], S[10], -U[2], U[4]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/CW}}, 
+ C[-S[30], S[10], -U[4], U[1]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[S[30], S[10], -U[3], U[1]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[-S[30], S[10], -U[1], U[3]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[S[30], S[10], -U[1], U[4]] == {{((I/2)*EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/SW}}, 
+ C[-S[30], S[20], -U[4], U[2]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*CW)}}, 
+ C[S[30], S[20], -U[3], U[2]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*CW)}}, 
+ C[-S[30], S[20], -U[2], U[3]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*CW)}}, 
+ C[S[30], S[20], -U[2], U[4]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*CW)}}, 
+ C[-S[30], S[20], -U[4], U[1]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW)}}, 
+ C[S[30], S[20], -U[3], U[1]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW)}}, 
+ C[-S[30], S[20], -U[1], U[3]] == {{(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW)}}, 
+ C[S[30], S[20], -U[1], U[4]] == {{-(EL^2*HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q])/(2*SW)}}}
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[1 | 2 | 3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[10 | 30 | 30] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[bg];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[1 | 10] ] = 1;
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[2 | 3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q];   
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[20 | 30] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[bg];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[1 | 2 | 3 | 4] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Q]
 MLE[1] = ME;
 MLE[2] = MM;
 MLE[3] = ML;
@@ -1347,7 +1323,6 @@ MQD[2] = MS;
 MQD[3] = MB;
 MQU[gen_, _] := MQU[gen];
 MQD[gen_, _] := MQD[gen]
-
 TheLabel[ F[1, {1}] ] = ComposedChar["\\nu", "e"];
 TheLabel[ F[1, {2}] ] = ComposedChar["\\nu", "\\mu"];
 TheLabel[ F[1, {3}] ] = ComposedChar["\\nu", "\\tau"];
@@ -1360,26 +1335,16 @@ TheLabel[ F[3, {3, ___}] ] = "t";
 TheLabel[ F[4, {1, ___}] ] = "d";
 TheLabel[ F[4, {2, ___}] ] = "s";
 TheLabel[ F[4, {3, ___}] ] = "b"
-
-
 M$LastModelRules = {}
-
-
 (* some short-hands for excluding classes of particles *)
-
 QEDOnly = ExcludeParticles -> {F[1], V[2], V[3], S, SV, U[2], U[3], U[4]}
-
 NoGeneration1 = ExcludeParticles -> F[_, {1}]
-
 NoGeneration2 = ExcludeParticles -> F[_, {2}]
-
 NoGeneration3 = ExcludeParticles -> F[_, {3}]
-
 NoElectronHCoupling =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[2, {1}], F[2, {1}], S],
     FieldPoint[_][-F[2, {1}], F[1, {1}], S] }
-
 NoLightFHCoupling =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[2], F[2], S],
@@ -1389,7 +1354,6 @@ NoLightFHCoupling =
     FieldPoint[_][-F[4], F[4], S],
     FieldPoint[_][-F[4], F[3, {1, ___}], S],
     FieldPoint[_][-F[4], F[3, {2, ___}], S] }
-
 NoQuarkMixing =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[4, {1}], F[3, {2}], S[3 | 30]],
@@ -1404,52 +1368,30 @@ NoQuarkMixing =
     FieldPoint[_][-F[4, {3}], F[3, {1}], V[3 | 30]],
     FieldPoint[_][-F[4, {3}], F[3, {2}], S[3 | 30]],
     FieldPoint[_][-F[4, {3}], F[3, {2}], V[3 | 30]] }
-
-
 (* The following definitions of renormalization constants
    are for the on-shell renormalization of the Standard Model in
    the background-field formulation in the scheme of A. Denner,
    S. Dittmaier, and G. Weiglein, Nucl Phys B440 (1995) 95.
-
    The renormalization constants are not directly used by
    FeynArts, and hence do not restrict the generation of diagrams
    and amplitudes in any way. *)
-
 Clear[RenConst]
-
 RenConst[ dMf1[type_, j1_] ] := MassRC[F[type, {j1}]]
-
 RenConst[ dZfL1[type_, j1_, j2_] ] :=
   FieldRC[F[type, {j1}], F[type, {j2}]][[1]]
-
 RenConst[ dZfR1[type_, j1_, j2_] ] :=
   FieldRC[F[type, {j1}], F[type, {j2}]][[2]]
-
 RenConst[ dMZsq1 ] := MassRC[V[20]]
-
 RenConst[ dMWsq1 ] := MassRC[V[30]]
-
 RenConst[ dMHsq1 ] := MassRC[S[10]]
-
 RenConst[ dZAA1 ] := FieldRC[V[10]]
-
 RenConst[ dZAZ1 ] := 2 CW/SW (dMWsq1/MW^2 - dMZsq1/MZ^2)
-
 RenConst[ dZZA1 ] := 0
-
 RenConst[ dZZZ1 ] := dZAA1 - (CW^2 - SW^2)/(2 CW SW) dZAZ1
-
 RenConst[ dZW1 ] := dZAA1 - CW/SW/2 dZAZ1
-
 RenConst[ dZH1 ] := dZW1 + dMWsq1/MW2
-
 RenConst[ dTH1 ] := TadpoleRC[S[10]]
-
 RenConst[ dZe1 ] := -1/2 dZAA1
-
 RenConst[ dWFZ1 ] := FieldRC[V[20]] - dZZZ1
-
 RenConst[ dWFAZ1 ] := FieldRC[V[10], V[20]] - dZAZ1
-
 RenConst[ dWFW1 ] := FieldRC[V[30]] - dZW1
-
diff --git FeynArts-3.7/Models/SMc.mod FeynArts-3.7/Models/SMc.mod
index 61793ac..2d73d05 100644
--- FeynArts-3.7/Models/SMc.mod
+++ FeynArts-3.7/Models/SMc.mod
@@ -3,26 +3,19 @@
 		Classes model file for the Standard Model
 		by Hagen Eck and Sepp Kueblbeck 1995
 		last modified 4 May 10 by Thomas Hahn
-
 This file contains the definition of a Classes model for FeynArts.
 It needs the Generic model file Lorentz.gen.
-
 When you change things, remember:
-
 -- All particles are arranged in classes. For single particle
    model definitions each particle lives in its own class.
-
 -- For each class the common SelfConjugate behaviour and the
    IndexRange MUST be present in the definitions.
-
 -- IMPORTANT: The coupling matrices MUST be declared in the
    SAME order as the Generic coupling.
-
 Reference:
 	Ansgar Denner, "Techniques for the calculation of electroweak
 	radiative corrections at one-loop level and results for
 	W-physics at LEP200", Fortschr. d. Physik, 41 (1993) 4
-
 Oct 95: one-loop counter terms added by Stefan Bauberger:
 	Some corrections and addition of all one-loop counter terms
 	according to A. Denner.  The gauge-fixing terms are assumed not
@@ -30,9 +23,7 @@ Oct 95: one-loop counter terms added by Stefan Bauberger:
 	include field renormalization of the Goldstone bosons.
 	The counter terms associated with quark mixing are not well
 	tested yet.
-
 Apr 99: Christian Schappacher added colour indices for the quarks
-
 Apr 99:	Terms for ghost sector updated by Ayres Freitas.
 	The gauge-fixing terms are still assumed not to be renormalized
 	but the renormalized gauge parameters follow the R_xi-gauge.
@@ -40,106 +31,70 @@ Apr 99:	Terms for ghost sector updated by Ayres Freitas.
 	The 2-loop counter terms for vector-boson selfenergies and for
 	the W-nu-l vertex have been added.
 	Old versions of the changes of sbau are removed!
-
 Apr 01:	Thomas Hahn added the definitions of the renormalization
 	constants a la A. Denner.
-
 This file introduces the following symbols:
-
 	coupling constants and masses:
 	------------------------------
 	EL:		electron charge (Thomson limit)
 	CW, SW:		cosine and sine of Weinberg angle
-
 	MW, MZ, MH:	W, Z, Higgs masses
-
 	MLE:		lepton class mass
 	ME, MM, ML:	lepton masses (e, mu, tau)
-
 	MQU:		u-type quark class mass
 	MU, MC, MT:	u-type quark masses (up, charm, top)
-
 	MQD:		d-type quark class mass
 	MD, MS, MB:	d-type quark masses (down, strange, bottom)
-
 	CKM:		quark mixing matrix
 			(set CKM = IndexDelta for no quark-mixing)
-
-	GaugeXi[A, W, Z]: photon, W, Z gauge parameters
-
-
+	HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A, W, Z]: photon, W, Z gauge parameters
 	one-loop renormalization constants (RCs):
 	-----------------------------------------
 	dZe1:		electromagnetic charge RC
 	dSW1, dCW1:	Weinberg angle sine/cosine RC
-
 	dZH1, dMHsq1:	Higgs field and mass RC
 	dZW1, dMWsq1:	W field and mass RC
 	dMZsq1:		Z mass RC
 	dZZZ1, dZZA1,
 	dZAZ1, dZAA1:	Z and photon field RCs
-
 	dMf1:		fermion mass RCs
 	dZfL1, dZfR1:	fermion field RCs
-
 	dCKM1:		quark mixing matrix RCs
-
 	dZG01, dZGp1:	field RC for unphysical scalars
 	dUZZ1, dUZA1,
 	dUAZ1, dUAA1:	field RCs for photon and Z ghosts
 	dUW1:		field RC for +/- ghosts
-
 	two-loop renormalization constants:
 	-----------------------------------
 	dZe2:           electromagnetic charge RC
 	dSW2:           weak mixing angle sine/cosine RC
-
 	dZW2, dMWsq2:	W field and mass RC
 	dMZsq2:		Z mass RC
 	dZZZ2, dZZA2,
 	dZAZ2, dZAA2:	Z and photon field RCs
-
 	dZfL2:		fermion field RCs
 *)
-
-
 IndexRange[ Index[Generation] ] = Range[3]
-
 IndexRange[ Index[Colour] ] = NoUnfold[Range[3]]
-
 IndexStyle[ Index[Generation, i_Integer] ] := Alph[i + 8]
-
 MaxGenerationIndex = 3
-
-
 ViolatesQ[ q__ ] := Plus[q] =!= 0
-
-
 mdZfLR1[ type_, j1_, j2_ ] :=
   Mass[F[type, {j1}]]/2 dZfL1[type, j1, j2] +
     Mass[F[type, {j2}]]/2 Conjugate[dZfR1[type, j2, j1]]
-
 mdZfRL1[ type_, j1_, j2_ ] :=
   Mass[F[type, {j1}]]/2 dZfR1[type, j1, j2] +
     Mass[F[type, {j2}]]/2 Conjugate[dZfL1[type, j2, j1]]
-
-
 (* the leptonic field RCs are diagonal: *)
-
 dZfL1[ type:1 | 2, j1_, j2_ ] :=
   IndexDelta[j1, j2] dZfL1[type, j1, j1] /; j1 =!= j2
-
 dZfR1[ type:1 | 2, j1_, j2_ ] :=
   IndexDelta[j1, j2] dZfR1[type, j1, j1] /; j1 =!= j2
-
-
 (* some short-hands for fermionic couplings: *)
-
 FermionCharge[1] = 0;
 FermionCharge[2] = -1;
 FermionCharge[3] = 2/3;
 FermionCharge[4] = -1/3
-
 gR[ type_ ] :=
   -SW/CW FermionCharge[type];
 gL[ type_ ] :=
@@ -149,10 +104,7 @@ dgR[ type_ ] :=
 dgL[ type_ ] :=
   If[ OddQ[type], 1/2, -1/2 ]/(SW CW) *
     (dZe1 + (SW^2 - CW^2)/(CW^2 SW) dSW1) + dgR[type]
-
-
 M$ClassesDescription = {
-
 	(* Leptons (neutrino): I_3 = +1/2, Q = 0 *)
   F[1] == {
 	SelfConjugate -> False,
@@ -162,7 +114,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["\\nu", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Leptons (electron): I_3 = -1/2, Q = -1 *)
   F[2] == {
 	SelfConjugate -> False,
@@ -172,7 +123,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["e", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Quarks (u): I_3 = +1/2, Q = +2/3 *)
   F[3] == {
 	SelfConjugate -> False,
@@ -182,7 +132,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", Index[Generation]],
 	PropagatorType -> Straight,
 	PropagatorArrow -> Forward },
-
 	(* Quarks (d): I_3 = -1/2, Q = -1/3 *) 
   F[4] == {
 	SelfConjugate -> False,
@@ -192,7 +141,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["d", Index[Generation]],
 	PropagatorType -> Straight, 
 	PropagatorArrow -> Forward },
-
 	(* Gauge bosons: Q = 0 *)
   V[1] == {
 	SelfConjugate -> True,
@@ -201,7 +149,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "\\gamma",
 	PropagatorType -> Sine,
 	PropagatorArrow -> None },
-
   V[2] == {
 	SelfConjugate -> True, 
 	Indices -> {},
@@ -209,7 +156,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "Z",
 	PropagatorType -> Sine,
 	PropagatorArrow -> None },
-
 	(* Gauge bosons: Q = -1 *)
   V[3] == {
 	SelfConjugate -> False,
@@ -219,7 +165,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "W",
 	PropagatorType -> Sine,
 	PropagatorArrow -> Forward },
-
 (*
   V[4] == {
 	SelfConjugate -> True,
@@ -230,7 +175,6 @@ M$ClassesDescription = {
 	PropagatorType -> Sine,
 	PropagatorArrow -> None },
 *)
-
 	(* mixing Higgs gauge bosons: Q = 0 *) 
   SV[2] == {
 	SelfConjugate -> True,
@@ -240,7 +184,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> {ComposedChar["G", Null, "0"], "Z"},
 	PropagatorType -> {ScalarDash, Sine},
 	PropagatorArrow -> None },
-
 	(* mixing Higgs gauge bosons: charged *) 
   SV[3] == {
 	SelfConjugate -> False,
@@ -251,7 +194,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> {"G", "W"},
 	PropagatorType -> {ScalarDash, Sine},
 	PropagatorArrow -> Forward },
-
 	(* physical Higgs: Q = 0 *) 
   S[1] == {
 	SelfConjugate -> True,
@@ -260,7 +202,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "H",
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> None },
-
 	(* unphysical Higgs: neutral *) 
   S[2] == {
 	SelfConjugate -> True,
@@ -269,7 +210,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["G", Null, "0"],
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> None },
-
 	(* unphysical Higgs: Q = -1 *)  
   S[3] == {
 	SelfConjugate -> False,
@@ -279,7 +219,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> "G",
 	PropagatorType -> ScalarDash,
 	PropagatorArrow -> Forward },
-
 	(* Ghosts: neutral *) 
   U[1] == {
 	SelfConjugate -> False,
@@ -289,7 +228,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "\\gamma"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
   U[2] == {
 	SelfConjugate -> False,
 	Indices -> {},
@@ -298,7 +236,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "Z"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
 	(* Ghosts: charged *) 
   U[3] == {
 	SelfConjugate -> False,
@@ -308,7 +245,6 @@ M$ClassesDescription = {
 	PropagatorLabel -> ComposedChar["u", "-"],
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward },
-
   U[4] == {
 	SelfConjugate -> False,
 	Indices -> {},
@@ -318,7 +254,6 @@ M$ClassesDescription = {
 	PropagatorType -> GhostDash,
 	PropagatorArrow -> Forward }
 }
-
 MLE[1] = ME;
 MLE[2] = MM;
 MLE[3] = ML;
@@ -330,7 +265,6 @@ MQD[2] = MS;
 MQD[3] = MB;
 MQU[gen_, _] := MQU[gen];
 MQD[gen_, _] := MQD[gen]
-
 TheLabel[ F[1, {1}] ] = ComposedChar["\\nu", "e"]; 
 TheLabel[ F[1, {2}] ] = ComposedChar["\\nu", "\\mu"]; 
 TheLabel[ F[1, {3}] ] = ComposedChar["\\nu", "\\tau"]; 
@@ -343,38 +277,30 @@ TheLabel[ F[3, {3, ___}] ] = "t";
 TheLabel[ F[4, {1, ___}] ] = "d"; 
 TheLabel[ F[4, {2, ___}] ] = "s";
 TheLabel[ F[4, {3, ___}] ] = "b"
-
-GaugeXi[ V[1] ] = GaugeXi[A];
-GaugeXi[ V[2] ] = GaugeXi[Z];
-GaugeXi[ V[3] ] = GaugeXi[W];
-GaugeXi[ S[1] ] = 1;
-GaugeXi[ S[2] ] = GaugeXi[Z];
-GaugeXi[ S[3] ] = GaugeXi[W];
-GaugeXi[ U[1] ] = GaugeXi[A];
-GaugeXi[ U[2] ] = GaugeXi[Z];
-GaugeXi[ U[3] ] = GaugeXi[W];
-GaugeXi[ U[4] ] = GaugeXi[W]
-
-
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[1] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[2] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ V[3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[1] ] = 1;
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[2] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ S[3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[1] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[A];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[2] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[3] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W];
+HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[ U[4] ] = HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]
 M$CouplingMatrices = {
-
 	(* V-V:  G(+) . { -g[mu, nu] mom^2, g[mu, nu], -mom[mu] mom[nu] } *)
-
   C[ -V[3], V[3] ] == I *
     { {0, dZW1, dZW2},
       {0, MW^2 dZW1 + dMWsq1, MW^2 dZW2 + dMWsq2 + dMWsq1 dZW1},
       {0, -dZW1, -dZW2} },
-
   C[ V[2], V[2] ] == I *
     { {0, dZZZ1, dZZZ2 + 1/4 dZAZ1^2},
       {0, MZ^2 dZZZ1 + dMZsq1, MZ^2 dZZZ2 + dMZsq2 + dMZsq1 dZZZ1},
       {0, -dZZZ1, -dZZZ2 - 1/4 dZAZ1^2} },
-
   C[ V[1], V[1] ] == I *
     { {0, dZAA1, dZAA2 + 1/4 dZZA1^2},
       {0, 0, 1/4 MZ^2 dZZA1^2},
       {0, -dZAA1, -dZAA2 - 1/4 dZZA1^2} },
-
   C[ V[1], V[2] ] == I *
     { {0, dZAZ1/2 + dZZA1/2,
     	  (dZAZ2 + dZZA2 + 1/2 dZZA1 dZZZ1 + 1/2 dZAZ1 dZAA1)/2},
@@ -382,48 +308,37 @@ M$CouplingMatrices = {
           (MZ^2 dZZA2 + 1/2 MZ^2 dZZZ1 dZZA1 + dMZsq1 dZZA1)/2},
       {0, -dZAZ1/2 - dZZA1/2,
           -(dZAZ2 + dZZA2 + 1/2 dZZA1 dZZZ1 + 1/2 dZAZ1 dZAA1)/2} },
-
 	(* S-V:  G(+) . { mom1[mu], mom2[mu] } *)
-
   C[ S[3], -V[3] ] == I MW/4 *
     { {0, -dZW1 - dZGp1 - dMWsq1/MW^2},
       {0, dZW1 + dZGp1 + dMWsq1/MW^2} },
-
   C[ -S[3], V[3] ] == I MW/4 *
     { {0, dZW1 + dZGp1 + dMWsq1/MW^2},
       {0, -dZW1 - dZGp1 - dMWsq1/MW^2} },
-
   C[ S[2], V[2] ] == MZ/4 *
     { {0, dZZZ1 + dZG01 + dMZsq1/MZ^2},
       {0, -dZZZ1 - dZG01 - dMZsq1/MZ^2} },
-
   C[ S[2], V[1] ] == MZ/4 *
     { {0, dZZA1},
       {0, -dZZA1} },
-
 	(* S-S:  G(+) . { -mom^2, 1 } *)
-
   C[ S[1], S[1] ] == -I *
     { {0, dZH1},
       {0, dMHsq1 + MH^2 dZH1} },
-
   C[ S[2], S[2] ] == -I *
     { {0, dZG01},
       {0, -EL/(2 MW SW) dTH1} },
-
   C[ S[3], -S[3] ] == -I *
     { {0, dZGp1},
       {0, -EL/(2 MW SW) dTH1} },
-
 	(* U-U:  G(+) . { -mom^2, 1 } *)
-
   C[ U[1], -U[1] ] == -I *
     { {0, -dZAA1/2 + dUAA1},
       {0, 0} },
   
   C[ U[2], -U[2] ] == -I *
     { {0, -dZZZ1/2 + dUZZ1},
-      {0, GaugeXi[Z] (MZ^2 (-dZG01/2 + dUZZ1) + dMZsq1/2) } },
+      {0, HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z] (MZ^2 (-dZG01/2 + dUZZ1) + dMZsq1/2) } },
   
   C[ U[2], -U[1] ] == -I *
     { {0, -dZAZ1/2 + dUAZ1},
@@ -431,57 +346,47 @@ M$CouplingMatrices = {
   
   C[ U[1], -U[2] ] == -I *
     { {0, -dZZA1/2 + dUZA1},
-      {0, GaugeXi[Z] MZ^2 dUZA1} },
+      {0, HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z] MZ^2 dUZA1} },
   
   C[ U[3], -U[3] ] == -I *
     { {0, -dZW1/2 + dUW1},
-      {0, GaugeXi[W] (MW^2 (-dZGp1/2 + dUW1) + dMWsq1/2) } },
-
+      {0, HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W] (MW^2 (-dZGp1/2 + dUW1) + dMWsq1/2) } },
   C[ U[4], -U[4] ] == -I *
     { {0, -dZW1/2 + dUW1},
-      {0, GaugeXi[W] (MW^2 (-dZGp1/2 + dUW1) + dMWsq1/2) } },
-
+      {0, HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W] (MW^2 (-dZGp1/2 + dUW1) + dMWsq1/2) } },
 	(* F-F:  G(+) . { slash[mom1] omega[-], slash[mom2] omega[+],
 	                  omega[-], omega[+] } *)
-
   C[ -F[1, {j1}], F[1, {j2}] ] == I *
     { {0, -AddHC[dZfL1[1, j1, j2]]},
       {0, AddHC[dZfR1[1, j1, j2]]},
       {0, 0},
       {0, 0} },
-
   C[ -F[2, {j1}], F[2, {j2}] ] == I *
     { {0, -AddHC[dZfL1[2, j1, j2]]},
       {0, AddHC[dZfR1[2, j1, j2]]},
       {0, -mdZfLR1[2, j1, j2] - IndexDelta[j1, j2] dMf1[2, j1]},
       {0, -mdZfRL1[2, j1, j2] - IndexDelta[j1, j2] dMf1[2, j1]} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}] ] == I IndexDelta[o1, o2] *
     { {0, -AddHC[dZfL1[3, j1, j2]]},
       {0, AddHC[dZfR1[3, j1, j2]]},
       {0, -mdZfLR1[3, j1, j2] - IndexDelta[j1, j2] dMf1[3, j1]},
       {0, -mdZfRL1[3, j1, j2] - IndexDelta[j1, j2] dMf1[3, j1]} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}] ] == I IndexDelta[o1, o2] *
     { {0, -AddHC[dZfL1[4, j1, j2]]},
       {0, AddHC[dZfR1[4, j1, j2]]},
       {0, -mdZfLR1[4, j1, j2] - IndexDelta[j1, j2] dMf1[4, j1]},
       {0, -mdZfRL1[4, j1, j2] - IndexDelta[j1, j2] dMf1[4, j1]} },
-
 	(* V-V-V-V:  G(+) . { g[mu1, mu2] g[mu3, mu4],
 	                      g[mu1, mu4] g[mu2, mu3],
 	                      g[mu1, mu3] g[mu2, mu4] } *)
-
   C[ -V[3], -V[3], V[3], V[3] ] == I EL^2/SW^2 *
     { {2, 4 dZe1 - 4 dSW1/SW + 4 dZW1}, 
       {-1, -2 dZe1 + 2 dSW1/SW - 2 dZW1},
       {-1, -2 dZe1 + 2 dSW1/SW - 2*dZW1} },
-
   C[ -V[3], V[3], V[2], V[2] ] == -I EL^2 CW^2/SW^2 *
     { {2, 4 dZe1 - 4 dSW1/(SW CW^2) + 2 dZW1 + 2 dZZZ1 - 2 dZAZ1 SW/CW}, 
       {-1, -2 dZe1 + 2 dSW1/(SW CW^2) - dZW1 - dZZZ1 + dZAZ1 SW/CW},
       {-1, -2 dZe1 + 2 dSW1/(SW CW^2) - dZW1 - dZZZ1 + dZAZ1 SW/CW} },
-
   C[ -V[3], V[3], V[1], V[2] ] == I EL^2 CW/SW *
     { {2, 4 dZe1 - 2 dSW1/(SW CW^2) + 2 dZW1 +
             dZZZ1 + dZAA1 - SW/CW dZAZ1 - CW/SW dZZA1},
@@ -489,50 +394,37 @@ M$CouplingMatrices = {
             dZZZ1/2 - dZAA1/2 + SW/CW dZAZ1/2 + CW/SW dZZA1/2},
       {-1, -2 dZe1 + dSW1/(SW CW^2) - dZW1 -
             dZZZ1/2 - dZAA1/2 + SW/CW dZAZ1/2 + CW/SW dZZA1/2} },
-
   C[ -V[3], V[3], V[1], V[1] ] == -I EL^2 *
     { {2, 4 dZe1 + 2 dZW1 + 2 dZAA1 - 2 CW/SW dZZA1}, 
       {-1, -2 dZe1 - dZW1 - dZAA1 + CW/SW dZZA1},
       {-1, -2 dZe1 - dZW1 - dZAA1 + CW/SW dZZA1} },
-
 	(* V-V-V:  G(-) . (g[mu1, mu2] (p2 - p1)_mu3 +
 	                   g[mu2, mu3] (p3 - p2)_mu1 +
 	                   g[mu3, mu1] (p1 - p3)_mu2) *)
-
   C[ V[1], -V[3], V[3] ] == -I EL *
     { {1, dZe1 + dZW1 + dZAA1/2 - CW/SW dZZA1/2} },
-
   C[ V[2], -V[3], V[3] ] == I EL CW/SW *
     { {1, dZe1 - dSW1/(SW CW^2) + dZW1 + dZZZ1/2 - SW/CW dZAZ1/2} },
-
 	(* S-S-S-S:  G(+) . 1 *)
-
   C[ S[1], S[1], S[1], S[1] ] == -3 I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + 2 dZH1} },
-
   C[ S[1], S[1], S[2], S[2] ] == -I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + dZH1 + dZG01} },
-
   C[ S[1], S[1], S[3], -S[3] ] == -I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + dZH1 + dZGp1} },
-
   C[ S[2], S[2], S[2], S[2] ] == -3 I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + 2 dZG01} },
-
   C[ S[2], S[2], S[3], -S[3] ] == -I EL^2 MH^2/(4 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + dZG01 + dZGp1} },
-
   C[ S[3], S[3], -S[3], -S[3] ] == -I EL^2 MH^2/(2 SW^2 MW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/MW^2 + 2 dZGp1} },
-
 	(* S-S-S:  G(+) . 1 *)
-
   C[ S[1], S[1], S[1] ] == -3 I EL MH^2/(2 SW MW) *
     { {1, dZe1 - dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/(2 MW^2) + 3/2 dZH1} },
@@ -540,140 +432,100 @@ M$CouplingMatrices = {
   C[ S[1], S[2], S[2] ] == -I EL MH^2/(2 SW MW) *
     { {1, dZe1 - dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/(2 MW^2) + dZH1/2 + dZG01} },
-
   C[ S[3], S[1], -S[3] ] == -I EL MH^2/(2 SW MW) *
     { {1, dZe1 - dSW1/SW + dMHsq1/MH^2 + EL/(2 SW MW MH^2) dTH1 -
             dMWsq1/(2 MW^2) + dZH1/2 + dZGp1} },
-
 	(* S-S-V-V:  G(+) . g[mu3, mu4] *)
-
   C[ S[1], S[1], V[3], -V[3] ] == I EL^2/(2 SW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dZW1 + dZH1} },
-
   C[ S[2], S[2], V[3], -V[3] ] == I EL^2/(2 SW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dZW1 + dZG01} },
-
   C[ S[3], -S[3], V[3], -V[3] ] == I EL^2/(2 SW^2) *
     { {1, 2 dZe1 - 2 dSW1/SW + dZW1 + dZGp1} },
-
   C[ S[3], -S[3], V[2], V[2] ] == I EL^2 (SW^2 - CW^2)^2/(2 CW^2 SW^2) *
     { {1, 2 dZe1 + 2/(SW CW^2 (SW^2 - CW^2)) dSW1 + dZZZ1 + dZGp1 +
             2 SW CW/(SW^2 - CW^2) dZAZ1} },
-
   C[ S[3], -S[3], V[1], V[2] ] == I EL^2 (SW^2 - CW^2)/(CW SW) *
     { {1, 2 dZe1 + dSW1/(SW CW^2 (SW^2 - CW^2)) + dZZZ1/2 + dZAA1/2 +
             dZGp1 + (SW^2 - CW^2)/(4 SW CW) dZZA1 +
             SW CW/(SW^2 - CW^2) dZAZ1} },
-
   C[ S[3], -S[3], V[1], V[1] ] == 2 I EL^2 *
     { {1, 2 dZe1 + dZAA1 + dZGp1 + (SW^2 - CW^2)/(2 SW CW) dZZA1} },
-
   C[ S[1], S[1], V[2], V[2] ] == I EL^2/(2 CW^2 SW^2) *
     { {1, 2 dZe1 + 2 (SW^2 - CW^2)/(SW CW^2) dSW1 + dZZZ1 + dZH1} },
-
   C[ S[2], S[2], V[2],  V[2] ] == I EL^2/(2 CW^2 SW^2) *
     { {1, 2 dZe1 + 2 (SW^2 - CW^2)/(SW CW^2) dSW1 + dZZZ1 + dZG01} },
-
   C[ S[1], S[1], V[1], V[2] ] == I EL^2/(2 CW^2 SW^2) *
     { {0, dZZA1/2} },
-
   C[ S[2], S[2], V[1], V[2] ] == I EL^2/(2 CW^2 SW^2) *
     { {0, dZZA1/2} },
-
   C[ S[1], -S[3], V[3], V[2] ] == -I EL^2/(2 CW) *
     { {1, 2 dZe1 - dCW1/CW + dZW1/2 + dZH1/2 + dZGp1/2 +
             dZZZ1/2 + CW/SW dZAZ1/2} },
-
   C[ S[1], S[3], -V[3], V[2] ] == -I EL^2/(2 CW) *
     { {1, 2 dZe1 - dCW1/CW + dZW1/2 + dZH1/2 + dZGp1/2 +
             dZZZ1/2 + CW/SW dZAZ1/2} },
-
   C[ S[1], S[3], -V[3], V[1] ] == -I EL^2/(2 SW) *
     { {1, 2 dZe1 - dSW1/SW + dZW1/2 + dZH1/2 + dZGp1/2 +
             dZAA1/2 + SW/CW dZZA1/2} },
-
   C[ S[1], -S[3], V[3], V[1] ] == -I EL^2/(2 SW) *
     { {1, 2 dZe1 - dSW1/SW + dZW1/2 + dZH1/2 + dZGp1/2 +
             dZAA1/2 + SW/CW dZZA1/2} },
-
   C[ S[3], S[2], V[2], -V[3] ] == EL^2/(2 CW) *
     { {1, 2 dZe1 - dCW1/CW + dZW1/2 + dZZZ1/2 + dZGp1/2 + dZG01/2 +
             CW/SW dZAZ1/2} },
-
   C[ -S[3], S[2], V[2], V[3] ] == -EL^2/(2 CW) *
     { {1, 2 dZe1 - dCW1/CW + dZW1/2 + dZZZ1/2 + dZGp1/2 + dZG01/2 +
             CW/SW dZAZ1/2} },
-
   C[ S[3], S[2], V[1], -V[3] ] == EL^2/(2 SW) *
     { {1, 2 dZe1 - dSW1/SW + dZW1/2 + dZAA1/2 + dZGp1/2 + dZG01/2 +
             SW/CW dZZA1/2} },
-
   C[ -S[3], S[2], V[1], V[3] ] == -EL^2/(2 SW) *
     { {1, 2 dZe1 - dSW1/SW + dZW1/2 + dZAA1/2 + dZGp1/2 + dZG01/2 +
             SW/CW dZZA1/2} },
-
 	(* S-S-V:  G(-) . (p1 - p2)_mu3 *)
-
   C[ S[2], S[1], V[1] ] == EL/(2 CW SW) *
     { {0, dZZA1/2} },
-
   C[ S[2], S[1], V[2] ] == EL/(2 CW SW) *
     { {1, dZe1 + (SW^2 - CW^2)/(CW^2 SW) dSW1 + dZH1/2 + dZZZ1/2 +
             dZG01/2} },
-
   C[ -S[3], S[3], V[1] ] == -I EL *
     { {1, dZe1 + dZAA1/2 + dZGp1 + (SW^2 - CW^2)/(2 SW CW) dZZA1/2} },
-
   C[ -S[3], S[3], V[2] ] == -I EL (SW^2 - CW^2)/(2 CW SW) *
     { {1, dZe1 + dSW1/((SW^2 - CW^2) CW^2 SW) + dZZZ1/2 + dZGp1 +
             2 SW CW/(SW^2 - CW^2) dZAZ1/2} },
-
   C[ S[3], S[1], -V[3] ] == -I EL/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZW1/2 + dZH1/2 + dZGp1/2} },
-
   C[ -S[3], S[1], V[3] ] == I EL/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZW1/2 + dZH1/2 + dZGp1/2} },
-
   C[ S[3], S[2], -V[3] ] == EL/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZW1/2 + dZGp1/2 + dZG01/2} },
-
   C[ -S[3], S[2], V[3] ] == EL/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZW1/2 + dZGp1/2 + dZG01/2} },
-
 	(* S-V-V:  G(+) . g[mu2, mu3] *)
-
   C[ S[1], -V[3], V[3] ] == I EL MW/SW *
     { {1, dZe1 - dSW1/SW + dMWsq1/(2 MW^2) + dZH1/2 + dZW1} },
-
   C[ S[1], V[2], V[2] ] == I EL MW/(SW CW^2) *
     { {1, dZe1 + (2 SW^2 - CW^2)/(CW^2 SW) dSW1 + dMWsq1/(2 MW^2) +
             dZH1/2 + dZZZ1} },
-
   C[ S[1], V[2], V[1] ] == I EL MW/(SW CW^2) *
     { {0, dZZA1/2} },
-
   C[ -S[3], V[3], V[2] ] == -I EL MW SW/CW *
     { {1, dZe1 + dSW1/(CW^2 SW) + dMWsq1/(2 MW^2) + dZW1/2 + dZZZ1/2 +
             dZGp1/2 + CW/SW dZAZ1/2} },
-
   C[ S[3], -V[3], V[2] ] == -I EL MW SW/CW *
     { {1, dZe1 + dSW1/(CW^2 SW) + dMWsq1/(2 MW^2) + dZW1/2 + dZZZ1/2 +
             dZGp1/2 + CW/SW dZAZ1/2} },
-
   C[ -S[3], V[3], V[1] ] == -I EL MW *
     { {1, dZe1 + dMWsq1/(2 MW^2) + dZW1/2 + dZAA1/2 + dZGp1/2 +
             SW/CW dZZA1/2} },
-
   C[ S[3], -V[3], V[1] ] == -I EL MW *
     { {1, dZe1 + dMWsq1/(2 MW^2) + dZW1/2 + dZAA1/2 + dZGp1/2 +
             SW/CW dZZA1/2} },
-
 	(* F-F-V:  G(-) . { gamma[mu3] omega[-], gamma[mu3] omega[+] } *)
-
   C[ -F[1, {j1}], F[1, {j2}], V[1] ] == I EL *
     { {0, gL[1] IndexDelta[j1, j2] dZZA1/2},
       {0, 0} },
-
   C[ -F[2, {j1}], F[2, {j2}], V[1] ] == I EL *
     { {-FermionCharge[2] IndexDelta[j1, j2],
         -FermionCharge[2] *
@@ -683,7 +535,6 @@ M$CouplingMatrices = {
         -FermionCharge[2] *
           (IndexDelta[j1, j2] (dZe1 + dZAA1/2) + AddHC[dZfR1[2, j1, j2]]) +
           gR[2] IndexDelta[j1, j2] dZZA1/2} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}], V[1] ] == I EL IndexDelta[o1, o2] *
     { {-FermionCharge[3] IndexDelta[j1, j2],
         -FermionCharge[3] *
@@ -693,7 +544,6 @@ M$CouplingMatrices = {
         -FermionCharge[3] *
           (IndexDelta[j1, j2] (dZe1 + dZAA1/2) + AddHC[dZfR1[3, j1, j2]]) +
           gR[3] IndexDelta[j1, j2] dZZA1/2} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}], V[1] ] == I EL IndexDelta[o1, o2] *
     { {-FermionCharge[4] IndexDelta[j1, j2],
         -FermionCharge[4] *
@@ -703,13 +553,11 @@ M$CouplingMatrices = {
         -FermionCharge[4] *
           (IndexDelta[j1, j2] (dZe1 + dZAA1/2) + AddHC[dZfR1[4, j1, j2]]) +
           gR[4] IndexDelta[j1, j2] dZZA1/2} },
-
   C[ -F[1, {j1}], F[1, {j2}], V[2] ] == I EL *
     { {gL[1] IndexDelta[j1, j2],
         IndexDelta[j1, j2] (gL[1] dZZZ1/2 + dgL[1]) +
         gL[1] AddHC[dZfL1[1, j1, j2]]},
       {0, 0} },
-
   C[ -F[2, {j1}], F[2, {j2}], V[2] ] == I EL *
     { {gL[2] IndexDelta[j1, j2],
         IndexDelta[j1, j2] *
@@ -719,7 +567,6 @@ M$CouplingMatrices = {
         IndexDelta[j1, j2] *
           (gR[2] dZZZ1/2 + dgR[2] - FermionCharge[2] dZAZ1/2) +
           gR[2] AddHC[dZfR1[2, j1, j2]]} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}], V[2] ] == I EL IndexDelta[o1, o2] *
     { {gL[3] IndexDelta[j1, j2],
         IndexDelta[j1, j2] *
@@ -729,7 +576,6 @@ M$CouplingMatrices = {
         IndexDelta[j1, j2] *
           (gR[3] dZZZ1/2 + dgR[3] - FermionCharge[3] dZAZ1/2) +
           gR[3] AddHC[dZfR1[3, j1, j2]]} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}], V[2] ] == I EL IndexDelta[o1, o2] *
     { {gL[4] IndexDelta[j1, j2],
         IndexDelta[j1, j2] *
@@ -739,7 +585,6 @@ M$CouplingMatrices = {
         IndexDelta[j1, j2] *
           (gR[4] dZZZ1/2 + dgR[4] - FermionCharge[4] dZAZ1/2) +
           gR[4] AddHC[dZfR1[4, j1, j2]]} },
-
   C[ -F[1, {j1}], F[2, {j2}], -V[3] ] ==
     I EL/(Sqrt[2] SW) IndexDelta[j1, j2] *
     { {1, dZe1 - dSW1/SW + dZW1/2 +
@@ -754,7 +599,6 @@ M$CouplingMatrices = {
             1/4 (dZW1 dZfL1[2, j1, j1] + dZW1 Conjugate[dZfL1[1, j1, j1]] +
                    Conjugate[dZfL1[1, j1, j1]] dZfL1[2, j1, j1]) },
       {0, 0, 0} },
-
   C[ -F[2, {j1}], F[1, {j2}], V[3] ] ==
     I EL/(Sqrt[2] SW) IndexDelta[j1, j2] *
     { {1, dZe1 - dSW1/SW + dZW1/2 +
@@ -769,7 +613,6 @@ M$CouplingMatrices = {
 	    1/4 (dZW1 Conjugate[dZfL1[2, j1, j1]] + dZW1 dZfL1[1, j1, j1] +
               dZfL1[1, j1, j1] Conjugate[dZfL1[2, j1, j1]]) },
       {0, 0, 0} },
-
   C[ -F[3, {j1, o1}], F[4, {j2, o2}], -V[3] ] ==
     I EL/(Sqrt[2] SW) IndexDelta[o1, o2] *
     { {CKM[j1, j2],
@@ -779,7 +622,6 @@ M$CouplingMatrices = {
           CKM[j1, gn] dZfL1[4, gn, j2],
         {gn, MaxGenerationIndex}]},
       {0, 0} },
-
   C[ -F[4, {j2, o2}], F[3, {j1, o1}], V[3] ] ==
     I EL/(Sqrt[2] SW) IndexDelta[o1, o2] *
     { {Conjugate[CKM[j1, j2]],
@@ -790,9 +632,7 @@ M$CouplingMatrices = {
             Conjugate[CKM[gn, j2]] dZfL1[3, gn, j1],
           {gn, MaxGenerationIndex}]},
       {0, 0} },
-
 	(* F-F-S:  G(+) . { omega[-], omega[+] } *)
-
   C[ -F[2, {j1}], F[2, {j2}], S[1] ] == -I EL/(2 SW MW) *
     { {Mass[F[2, {j1}]] IndexDelta[j1, j2],
         Mass[F[2, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
@@ -802,7 +642,6 @@ M$CouplingMatrices = {
         Mass[F[2, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[2, j1]/Mass[F[2, {j1}]] - dMWsq1/(2 MW^2) + dZH1/2) +
           mdZfRL1[2, j1, j2]} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}], S[1] ] ==
     -I EL/(2 SW MW) IndexDelta[o1, o2] *
     { {Mass[F[3, {j1}]] IndexDelta[j1, j2],
@@ -813,7 +652,6 @@ M$CouplingMatrices = {
         Mass[F[3, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[3, j1]/Mass[F[3, {j1}]] - dMWsq1/(2 MW^2) + dZH1/2) +
           mdZfRL1[3, j1, j2]} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}], S[1] ] ==
     -I EL/(2 SW MW) IndexDelta[o1, o2] *
     { {Mass[F[4, {j1}]] IndexDelta[j1, j2],
@@ -824,7 +662,6 @@ M$CouplingMatrices = {
         Mass[F[4, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[4, j1]/Mass[F[4, {j1}]] - dMWsq1/(2 MW^2) + dZH1/2) +
           mdZfRL1[4, j1, j2]} },
-
   C[ -F[2, {j1}], F[2, {j2}], S[2] ] == -EL/(2 SW MW) *
     { {Mass[F[2, {j1}]] IndexDelta[j1, j2],
         Mass[F[2, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
@@ -834,7 +671,6 @@ M$CouplingMatrices = {
         -Mass[F[2, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[2, j1]/Mass[F[2, {j1}]] - dMWsq1/(2 MW^2) + dZG01/2) -
           mdZfRL1[2, j1, j2]} },
-
   C[ -F[3, {j1, o1}], F[3, {j2, o2}], S[2] ] ==
     EL/(2 SW MW) IndexDelta[o1, o2] *
     { {Mass[F[3, {j1}]] IndexDelta[j1, j2],
@@ -845,7 +681,6 @@ M$CouplingMatrices = {
         -Mass[F[3, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[3, j1]/Mass[F[3, {j1}]] - dMWsq1/(2 MW^2) + dZG01/2) -
           mdZfRL1[3, j1, j2]} },
-
   C[ -F[4, {j1, o1}], F[4, {j2, o2}], S[2] ] ==
     -EL/(2 SW MW) IndexDelta[o1, o2] *
     { {Mass[F[4, {j1}]] IndexDelta[j1, j2],
@@ -856,7 +691,6 @@ M$CouplingMatrices = {
         -Mass[F[4, {j1}]] IndexDelta[j1, j2] (dZe1 - dSW1/SW +
           dMf1[4, j1]/Mass[F[4, {j1}]] - dMWsq1/(2 MW^2) + dZG01/2) -
           mdZfRL1[4, j1, j2]} },
-
   C[ -F[3, {j1, o1}], F[4, {j2, o2}], -S[3] ] ==
     I EL/(Sqrt[2] SW MW) IndexDelta[o1, o2] *
     { {Mass[F[3, {j1}]] CKM[j1, j2],
@@ -875,7 +709,6 @@ M$CouplingMatrices = {
             Mass[F[4, {j2}]] Conjugate[dZfL1[3, gn, j1]] CKM[gn, j2] +
             Mass[F[4, {gn}]] CKM[j1, gn] dZfR1[4, gn, j2],
           {gn, MaxGenerationIndex}]} },
-
   C[ -F[4, {j2, o2}], F[3, {j1, o1}], S[3] ] ==
     -I EL/(Sqrt[2] SW MW) IndexDelta[o1, o2] *
     { {Mass[F[4, {j2}]] Conjugate[CKM[j1, j2]],
@@ -899,130 +732,93 @@ M$CouplingMatrices = {
             Mass[F[3, {gn}]] Conjugate[CKM[gn, j2]] *
               dZfR1[3, gn, j1],
           {gn, MaxGenerationIndex}]} },
-
   C[ -F[1, {j1}], F[2, {j2}], -S[3] ] ==
     -I EL Mass[F[2, {j1}]]/(Sqrt[2] SW MW) IndexDelta[j1, j2] *
     { {0, 0},
       {1, dZe1 - dSW1/SW + dMf1[2, j1]/Mass[F[2, {j1}]] -
             dMWsq1/(2 MW^2) + dZGp1/2 +
             Conjugate[dZfL1[1, j1, j1]]/2 + dZfR1[2, j1, j1]/2} },
-
   C[ -F[2, {j1}], F[1, {j2}], S[3] ] ==
     -I EL Mass[F[2, {j1}]]/(Sqrt[2] SW MW) IndexDelta[j1, j2] *
     { {1, dZe1 - dSW1/SW + dMf1[2, j1]/Mass[F[2, {j1}]] -
             dMWsq1/(2 MW^2) + dZGp1/2 +
             dZfL1[1, j1, j1]/2 + Conjugate[dZfR1[2, j1, j1]]/2},
       {0, 0} },
-
 	(* U-U-V:  G(+) . { p1_mu3, p2_mu3 } *)
-
   C[ -U[3], U[3], V[1] ] == -I EL *
     { {1, dZe1 + dZAA1/2 - dZW1/2 + dUW1 - CW/SW dZZA1/2},
       {0, 0} },
-
   C[ -U[4], U[4], V[1] ] == I EL *
     { {1, dZe1 + dZAA1/2 - dZW1/2 + dUW1 - CW/SW dZZA1/2},
       {0, 0} },
-
   C[ -U[3], U[3], V[2] ] == I EL CW/SW *
     { {1, dZe1 - 1/(CW^2 SW) dSW1 + dZZZ1/2 - dZW1/2 + dUW1 - SW/CW dZAZ1/2},
       {0, 0} },
-
   C[ -U[4], U[4], V[2] ] == -I EL CW/SW *
     { {1, dZe1 - 1/(CW^2 SW) dSW1 + dZZZ1/2 - dZW1/2 + dUW1 - SW/CW dZAZ1/2},
       {0, 0} },
-
   C[ -U[3], U[2], V[3] ] == -I EL CW/SW *
     { {1, dZe1 - 1/(CW^2 SW) dSW1 + dUZZ1 - SW/CW dUAZ1},
       {0, 0} },
-
   C[ -U[2], U[3], -V[3] ] == -I EL *
     { {CW/SW,
        CW/SW (dZe1 - 1/(CW^2 SW) dSW1 + dZW1/2 - dZZZ1/2 + dUW1) + dZZA1/2},
       {0, 0} }, 
-
   C[ -U[4], U[2], -V[3] ] == I EL CW/SW *
     { {1, dZe1 - 1/(CW^2 SW) dSW1 + dUZZ1 - SW/CW dUAZ1},
       {0, 0} },
-
   C[ -U[2], U[4], V[3] ] == I EL *
     { {CW/SW,
        CW/SW (dZe1 - 1/(CW^2 SW) dSW1 + dZW1/2 - dZZZ1/2 + dUW1) + dZZA1/2},
       {0, 0} },
-
   C[ -U[3], U[1], V[3] ] == I EL *
     { {1, dZe1 + dUAA1 - CW/SW dUZA1},
       {0, 0} },
-
   C[ -U[1], U[3], -V[3] ] == I EL *
     { {1, dZe1 + dZW1/2 - dZAA1/2 + dUW1 + CW/SW dZAZ1/2},
       {0, 0} },
-
   C[ -U[4], U[1], -V[3] ] == -I EL *
     { {1, dZe1 + dUAA1 - CW/SW dUZA1},
       {0, 0} },
-
   C[ -U[1], U[4], V[3] ] == -I EL *
     { {1, dZe1 + dZW1/2 - dZAA1/2 + dUW1 + CW/SW dZAZ1/2},
       {0, 0} },
-
 	(* S-U-U:  G(+) . 1 *)
-
-  C[ S[1], -U[2], U[2] ] == -I EL MZ GaugeXi[Z]/(2 SW CW) *
+  C[ S[1], -U[2], U[2] ] == -I EL MZ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z]/(2 SW CW) *
     { {1, dZe1 + (SW^2 - CW^2)/(CW^2 SW) dSW1 + dZH1/2 - dZG01/2 + dUZZ1} },
-
-  C[ S[1], -U[3], U[3] ] == -I EL MW GaugeXi[W]/(2 SW) *
+  C[ S[1], -U[3], U[3] ] == -I EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZH1/2 - dZGp1/2 + dUW1} },
-
-  C[ S[1], -U[4], U[4] ] == -I EL MW GaugeXi[W]/(2 SW) *
+  C[ S[1], -U[4], U[4] ] == -I EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZH1/2 - dZGp1/2 + dUW1} },
-
-  C[ S[2], -U[4], U[4] ] == EL MW GaugeXi[W]/(2 SW) *
+  C[ S[2], -U[4], U[4] ] == EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZG01/2 - dZGp1/2 + dUW1} },
-
-  C[ S[2], -U[3], U[3] ] == -EL MW GaugeXi[W]/(2 SW) *
+  C[ S[2], -U[3], U[3] ] == -EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZG01/2 - dZGp1/2 + dUW1} },
-
-  C[ -S[3], -U[2], U[3] ] == I EL MZ GaugeXi[Z]/(2 SW) *
+  C[ -S[3], -U[2], U[3] ] == I EL MZ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z]/(2 SW) *
     { {1, dZe1 - dSW1/SW + dZGp1/2 - dZG01/2 + dUW1} },
-
-  C[ S[3], -U[2], U[4] ] == I EL MZ GaugeXi[Z]/(2 SW) *
+  C[ S[3], -U[2], U[4] ] == I EL MZ HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[Z]/(2 SW) *
     { {1, dZe1 + dSW1/SW + dZGp1/2 - dZG01/2 + dUW1} },
-
-  C[ -S[3], -U[4], U[2] ] == I EL (SW^2 - CW^2) MW GaugeXi[W]/(2 CW SW) *
+  C[ -S[3], -U[4], U[2] ] == I EL (SW^2 - CW^2) MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 CW SW) *
     { {1, dZe1 + dSW1/((SW^2 - CW^2) CW^2 SW) + dUZZ1 +
         (2 SW CW)/(SW^2 - CW^2) dUAZ1} },
-
-  C[ S[3], -U[3], U[2] ] == I EL (SW^2 - CW^2) MW GaugeXi[W]/(2 CW SW) *
+  C[ S[3], -U[3], U[2] ] == I EL (SW^2 - CW^2) MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W]/(2 CW SW) *
     { {1, dZe1 + dSW1/((SW^2 - CW^2) CW^2 SW) + dUZZ1 +
         (2 SW CW)/(SW^2 - CW^2) dUAZ1} },
-
-  C[ -S[3], -U[4], U[1] ] == I EL MW GaugeXi[W] *
+  C[ -S[3], -U[4], U[1] ] == I EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W] *
     { {1, dZe1 + dUAA1 + (SW^2 - CW^2)/(2 SW CW) dUZA1} },
-
-  C[ S[3], -U[3], U[1] ] == I EL MW GaugeXi[W] *
+  C[ S[3], -U[3], U[1] ] == I EL MW HighEnergyPhysics`FeynCalc`GaugeXi`GaugeXi[W] *
     { {1, dZe1 + dUAA1 + (SW^2 - CW^2)/(2 SW CW) dUZA1} }
 }
-
-
 M$LastModelRules = {}
-
-
 (* some short-hands for excluding classes of particles *)
-
 QEDOnly = ExcludeParticles -> {F[1], V[2], V[3], S, SV, U[2], U[3], U[4]}
-
 NoGeneration1 = ExcludeParticles -> F[_, {1, ___}]
-
 NoGeneration2 = ExcludeParticles -> F[_, {2, ___}]
-
 NoGeneration3 = ExcludeParticles -> F[_, {3, ___}]
-
 NoElectronHCoupling =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[2, {1}], F[2, {1}], S],
     FieldPoint[_][-F[2, {1}], F[1, {1}], S] }
-
 NoLightFHCoupling =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[2], F[2], S],
@@ -1032,7 +828,6 @@ NoLightFHCoupling =
     FieldPoint[_][-F[4], F[4], S],
     FieldPoint[_][-F[4], F[3, {1, ___}], S],
     FieldPoint[_][-F[4], F[3, {2, ___}], S] }
-
 NoQuarkMixing =
   ExcludeFieldPoints -> {
     FieldPoint[_][-F[4, {1, ___}], F[3, {2, ___}], S[3]],
@@ -1047,56 +842,33 @@ NoQuarkMixing =
     FieldPoint[_][-F[4, {3, ___}], F[3, {1, ___}], V[3]],
     FieldPoint[_][-F[4, {3, ___}], F[3, {2, ___}], S[3]],
     FieldPoint[_][-F[4, {3, ___}], F[3, {2, ___}], V[3]] }
-
-
 (* The following definitions of renormalization constants
    are for the on-shell renormalization of the Standard Model in
    the scheme of A. Denner, Fortschr. d. Physik, 41 (1993) 4.
-
    The renormalization constants are not directly used by
    FeynArts, and hence do not restrict the generation of diagrams
    and amplitudes in any way. *)
-
 Clear[RenConst]
-
 RenConst[ dMf1[type_, j1_] ] := MassRC[F[type, {j1}]]
-
 RenConst[ dZfL1[type_, j1_, j2_] ] :=
   FieldRC[F[type, {j1}], F[type, {j2}]][[1]]
-
 RenConst[ dZfR1[type_, j1_, j2_] ] :=
   FieldRC[F[type, {j1}], F[type, {j2}]][[2]]
-
 RenConst[ dCKM1[j1_, j2_] ] := 1/4 IndexSum[
   (dZfL1[3, j1, gn] - Conjugate[dZfL1[3, gn, j1]]) CKM[gn, j2] -
   CKM[j1, gn] (dZfL1[4, gn, j2] - Conjugate[dZfL1[4, j2, gn]]),
   {gn, MaxGenerationIndex} ]
-
 RenConst[ dMZsq1 ] := MassRC[V[2]]
-
 RenConst[ dMWsq1 ] := MassRC[V[3]]
-
 RenConst[ dMHsq1 ] := MassRC[S[1]]
-
 RenConst[ dZAA1 ] := FieldRC[V[1]]
-
 RenConst[ dZAZ1 ] := FieldRC[V[1], V[2]]
-
 RenConst[ dZZA1 ] := FieldRC[V[2], V[1]]
-
 RenConst[ dZZZ1 ] := FieldRC[V[2]]
-
 RenConst[ dZG01 ] := FieldRC[S[2]]
-
 RenConst[ dZW1 ] := FieldRC[V[3]]
-
 RenConst[ dZGp1 ] := FieldRC[S[3]]
-
 RenConst[ dZH1 ] := FieldRC[S[1]]
-
 RenConst[ dTH1 ] := TadpoleRC[S[1]]
-
 RenConst[ dSW1 ] := CW^2/SW/2 (dMZsq1/MZ^2 - dMWsq1/MW^2)
-
 RenConst[ dZe1 ] := -1/2 (dZAA1 + SW/CW dZZA1)
-
diff --git FeynArts-3.7/Setup.m FeynArts-3.7/Setup.m
index 790f5d3..ce2fd88 100644
--- FeynArts-3.7/Setup.m
+++ FeynArts-3.7/Setup.m
@@ -2,34 +2,30 @@
 	Setup.m
 		FeynArts startup file
 		last modified 17 Mar 08 th
-
 Here you can set up your own changes and enhancements to FeynArts,
 e.g. some particular options you always want set, or $SVMixing = True.
 It is a good idea to do this here since changing the FeynArts code 
 directly is inherently unportable.
-
 *)
-
-
-$Verbose = 2
-
+$Verbose := HighEnergyPhysics`FeynCalc`$VeryVerbose
 $ModelPath = { Directory[],
   ToFileName[{Directory[], "Models"}],
   ToFileName[{$FeynArtsDir, "Models"}] }
-
 $ModelDebug = False
-
 $ModelDebugForm = Short[#, 5]&
-
 $ShapeDataDir = ToFileName[{$FeynArtsDir, "ShapeData"}]
-
 $SVMixing = False
-
 $CounterTerms = True
-
 $FermionLines = True
-
 	(* eliminate those `>' in front of continuation lines so
 	   one can cut and paste more easily *)
-Format[ Continuation[_] ] = "    "
-
+format1[ Continuation[_] ] = "    "
+P$Generic = Union[Flatten[P$Generic | HighEnergyPhysics`Phi`Objects`$ParticleHeads]];
+P$NonCommuting =  Union[Flatten[P$NonCommuting | HighEnergyPhysics`Phi`Objects`$FermionHeads]];
+(*
+SetOptions[FourVector, FeynCalcInternal -> False];
+SetOptions[MetricTensor, FeynCalcInternal -> False];
+SetOptions[DiracSlash, FeynCalcInternal -> False];
+*)
+(*Important. OneHighEnergyPhysics`FeynCalc`Loop`Loop is broken if HighEnergyPhysics`FeynCalc`FeynAmpDenominator`FeynAmpDenominator is orderless*)
+ClearAttributes[HighEnergyPhysics`FeynCalc`FeynAmpDenominator`FeynAmpDenominator, Orderless];

